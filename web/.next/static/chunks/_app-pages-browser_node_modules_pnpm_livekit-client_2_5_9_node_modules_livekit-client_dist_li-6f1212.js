/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.14_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.80.3/node_modules/next/dist/build/polyfills/process.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.14_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.80.3/node_modules/next/dist/build/polyfills/process.js ***!
  \***************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.14_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.80.3/node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMTRfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuODAuMy9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxxQ0FBcUMscUJBQU0saUZBQWlGLHFCQUFNLGtFQUFrRSxxQkFBTSxXQUFXLG1CQUFPLENBQUMsb01BQTRCOztBQUV6UCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjE0X3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjFfc2Fzc0AxLjgwLjMvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvcHJvY2Vzcy5qcz9lYWJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9nbG9iYWxfcHJvY2VzcywgX2dsb2JhbF9wcm9jZXNzMTtcbm1vZHVsZS5leHBvcnRzID0gKChfZ2xvYmFsX3Byb2Nlc3MgPSBnbG9iYWwucHJvY2VzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbG9iYWxfcHJvY2Vzcy5lbnYpICYmIHR5cGVvZiAoKF9nbG9iYWxfcHJvY2VzczEgPSBnbG9iYWwucHJvY2VzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbG9iYWxfcHJvY2VzczEuZW52KSA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbC5wcm9jZXNzIDogcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzXCIpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9jZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.14_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.80.3/node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@14.2.14_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.80.3/node_modules/next/dist/compiled/process/browser.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.14_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.80.3/node_modules/next/dist/compiled/process/browser.js ***!
  \****************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE0LjIuMTRfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9zYXNzQDEuODAuMy9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGdCQUFnQixtQkFBbUIsTUFBTSxNQUFNLDRCQUE0QixtREFBbUQsK0JBQStCLHFEQUFxRCxZQUFZLElBQUksbUNBQW1DLGFBQWEsS0FBSyxvQkFBb0IsU0FBUyxtQkFBbUIsSUFBSSxxQ0FBcUMsZUFBZSxLQUFLLHVCQUF1QixTQUFTLHVCQUF1QixJQUFJLHVCQUF1QixtQkFBbUIsdUJBQXVCLDJDQUEyQyxhQUFhLHVCQUF1QixJQUFJLGNBQWMsU0FBUyxJQUFJLHdCQUF3QixTQUFTLDBCQUEwQiw0QkFBNEIscUJBQXFCLHVCQUF1QixnREFBZ0QsZUFBZSx1QkFBdUIsSUFBSSxZQUFZLFNBQVMsSUFBSSxzQkFBc0IsU0FBUyx3QkFBd0IsU0FBUyxZQUFZLE1BQU0sU0FBUywyQkFBMkIsV0FBVyxPQUFPLFFBQVEsYUFBYSxjQUFjLEtBQUssS0FBSyxhQUFhLGNBQWMsc0JBQXNCLE1BQU0sT0FBTyxrQ0FBa0MsT0FBTyxlQUFlLFNBQVMsSUFBSSxLQUFLLGFBQWEsTUFBTSxZQUFZLEtBQUssV0FBVyxPQUFPLFFBQVEsbUJBQW1CLHVCQUF1QixvQ0FBb0MsdUJBQXVCLFlBQVksbUJBQW1CLEtBQUsscUJBQXFCLHNCQUFzQixxQkFBcUIseUJBQXlCLG1CQUFtQixXQUFXLGFBQWEsOEJBQThCLGlDQUFpQyxrQkFBa0IsZUFBZSxTQUFTLFVBQVUsYUFBYSxjQUFjLGlCQUFpQixVQUFVLG1CQUFtQixZQUFZLFdBQVcsc0JBQXNCLDBCQUEwQixZQUFZLHVCQUF1QiwyQkFBMkIsd0JBQXdCLFVBQVUsc0JBQXNCLHFEQUFxRCxpQkFBaUIsV0FBVyxvQkFBb0IsbURBQW1ELG1CQUFtQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTQuMi4xNF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3Nhc3NAMS44MC4zL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzPzM2NTIiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezIyOTpmdW5jdGlvbihlKXt2YXIgdD1lLmV4cG9ydHM9e307dmFyIHI7dmFyIG47ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX0oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe3I9c2V0VGltZW91dH1lbHNle3I9ZGVmYXVsdFNldFRpbW91dH19Y2F0Y2goZSl7cj1kZWZhdWx0U2V0VGltb3V0fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtuPWNsZWFyVGltZW91dH1lbHNle249ZGVmYXVsdENsZWFyVGltZW91dH19Y2F0Y2goZSl7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0pKCk7ZnVuY3Rpb24gcnVuVGltZW91dChlKXtpZihyPT09c2V0VGltZW91dCl7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX1pZigocj09PWRlZmF1bHRTZXRUaW1vdXR8fCFyKSYmc2V0VGltZW91dCl7cj1zZXRUaW1lb3V0O3JldHVybiBzZXRUaW1lb3V0KGUsMCl9dHJ5e3JldHVybiByKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlLDApfX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KGUpe2lmKG49PT1jbGVhclRpbWVvdXQpe3JldHVybiBjbGVhclRpbWVvdXQoZSl9aWYoKG49PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhbikmJmNsZWFyVGltZW91dCl7bj1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChlKX10cnl7cmV0dXJuIG4oZSl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlKX1jYXRjaCh0KXtyZXR1cm4gbi5jYWxsKHRoaXMsZSl9fX12YXIgaT1bXTt2YXIgbz1mYWxzZTt2YXIgdTt2YXIgYT0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighb3x8IXUpe3JldHVybn1vPWZhbHNlO2lmKHUubGVuZ3RoKXtpPXUuY29uY2F0KGkpfWVsc2V7YT0tMX1pZihpLmxlbmd0aCl7ZHJhaW5RdWV1ZSgpfX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYobyl7cmV0dXJufXZhciBlPXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtvPXRydWU7dmFyIHQ9aS5sZW5ndGg7d2hpbGUodCl7dT1pO2k9W107d2hpbGUoKythPHQpe2lmKHUpe3VbYV0ucnVuKCl9fWE9LTE7dD1pLmxlbmd0aH11PW51bGw7bz1mYWxzZTtydW5DbGVhclRpbWVvdXQoZSl9dC5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3Rbci0xXT1hcmd1bWVudHNbcl19fWkucHVzaChuZXcgSXRlbShlLHQpKTtpZihpLmxlbmd0aD09PTEmJiFvKXtydW5UaW1lb3V0KGRyYWluUXVldWUpfX07ZnVuY3Rpb24gSXRlbShlLHQpe3RoaXMuZnVuPWU7dGhpcy5hcnJheT10fUl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9O3QudGl0bGU9XCJicm93c2VyXCI7dC5icm93c2VyPXRydWU7dC5lbnY9e307dC5hcmd2PVtdO3QudmVyc2lvbj1cIlwiO3QudmVyc2lvbnM9e307ZnVuY3Rpb24gbm9vcCgpe310Lm9uPW5vb3A7dC5hZGRMaXN0ZW5lcj1ub29wO3Qub25jZT1ub29wO3Qub2ZmPW5vb3A7dC5yZW1vdmVMaXN0ZW5lcj1ub29wO3QucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3A7dC5lbWl0PW5vb3A7dC5wcmVwZW5kTGlzdGVuZXI9bm9vcDt0LnByZXBlbmRPbmNlTGlzdGVuZXI9bm9vcDt0Lmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm5bXX07dC5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifTt0LmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX07dC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXRbcl09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2Vbcl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIHRbcl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9X19uY2N3cGNrX3JlcXVpcmVfXygyMjkpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@14.2.14_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.80.3/node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/livekit-client@2.5.9/node_modules/livekit-client/dist/livekit-client.e2ee.worker.mjs":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/livekit-client@2.5.9/node_modules/livekit-client/dist/livekit-client.e2ee.worker.mjs ***!
  \*****************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.14_react-dom@18.3.1_react@18.3.1__react@18.3.1_sass@1.80.3/node_modules/next/dist/build/polyfills/process.js\");\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nvar loglevel$1 = {exports: {}};\n\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\nvar loglevel = loglevel$1.exports;\nvar hasRequiredLoglevel;\nfunction requireLoglevel() {\n  if (hasRequiredLoglevel) return loglevel$1.exports;\n  hasRequiredLoglevel = 1;\n  (function (module) {\n    (function (root, definition) {\n\n      if (module.exports) {\n        module.exports = definition();\n      } else {\n        root.log = definition();\n      }\n    })(loglevel, function () {\n\n      // Slightly dubious tricks to cut down minimized file size\n      var noop = function () {};\n      var undefinedType = \"undefined\";\n      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n      var logMethods = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n      var _loggersByName = {};\n      var defaultLogger = null;\n\n      // Cross-browser bind equivalent that works at least back to IE6\n      function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n          return method.bind(obj);\n        } else {\n          try {\n            return Function.prototype.bind.call(method, obj);\n          } catch (e) {\n            // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n            return function () {\n              return Function.prototype.apply.apply(method, [obj, arguments]);\n            };\n          }\n        }\n      }\n\n      // Trace() doesn't print the message in IE, so for that case we need to wrap it\n      function traceForIE() {\n        if (console.log) {\n          if (console.log.apply) {\n            console.log.apply(console, arguments);\n          } else {\n            // In old IE, native console methods themselves don't have apply().\n            Function.prototype.apply.apply(console.log, [console, arguments]);\n          }\n        }\n        if (console.trace) console.trace();\n      }\n\n      // Build the best logging method possible for this env\n      // Wherever possible we want to bind, not wrap, to preserve stack traces\n      function realMethod(methodName) {\n        if (methodName === 'debug') {\n          methodName = 'log';\n        }\n        if (typeof console === undefinedType) {\n          return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n          return traceForIE;\n        } else if (console[methodName] !== undefined) {\n          return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n          return bindMethod(console, 'log');\n        } else {\n          return noop;\n        }\n      }\n\n      // These private functions always need `this` to be set properly\n\n      function replaceLoggingMethods() {\n        /*jshint validthis:true */\n        var level = this.getLevel();\n\n        // Replace the actual methods.\n        for (var i = 0; i < logMethods.length; i++) {\n          var methodName = logMethods[i];\n          this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n\n        // Return any important warnings.\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\n          return \"No console available for logging\";\n        }\n      }\n\n      // In old IE versions, the console isn't present until you first open it.\n      // We build realMethod() replacements here that regenerate logging methods\n      function enableLoggingWhenConsoleArrives(methodName) {\n        return function () {\n          if (typeof console !== undefinedType) {\n            replaceLoggingMethods.call(this);\n            this[methodName].apply(this, arguments);\n          }\n        };\n      }\n\n      // By default, we use closely bound real methods wherever possible, and\n      // otherwise we wait for a console to appear, and then try again.\n      function defaultMethodFactory(methodName, _level, _loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n      }\n      function Logger(name, factory) {\n        // Private instance variables.\n        var self = this;\n        /**\n         * The level inherited from a parent logger (or a global default). We\n         * cache this here rather than delegating to the parent so that it stays\n         * in sync with the actual logging methods that we have installed (the\n         * parent could change levels but we might not have rebuilt the loggers\n         * in this child yet).\n         * @type {number}\n         */\n        var inheritedLevel;\n        /**\n         * The default level for this logger, if any. If set, this overrides\n         * `inheritedLevel`.\n         * @type {number|null}\n         */\n        var defaultLevel;\n        /**\n         * A user-specific level for this logger. If set, this overrides\n         * `defaultLevel`.\n         * @type {number|null}\n         */\n        var userLevel;\n        var storageKey = \"loglevel\";\n        if (typeof name === \"string\") {\n          storageKey += \":\" + name;\n        } else if (typeof name === \"symbol\") {\n          storageKey = undefined;\n        }\n        function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n            window.localStorage[storageKey] = levelName;\n            return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n            window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n        }\n        function getPersistedLevel() {\n          var storedLevel;\n          if (typeof window === undefinedType || !storageKey) return;\n          try {\n            storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n            try {\n              var cookie = window.document.cookie;\n              var cookieName = encodeURIComponent(storageKey);\n              var location = cookie.indexOf(cookieName + \"=\");\n              if (location !== -1) {\n                storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];\n              }\n            } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n            storedLevel = undefined;\n          }\n          return storedLevel;\n        }\n        function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n            window.localStorage.removeItem(storageKey);\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n            window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n        }\n        function normalizeLevel(input) {\n          var level = input;\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n            level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n            return level;\n          } else {\n            throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n          }\n        }\n\n        /*\n         *\n         * Public logger API - see https://github.com/pimterry/loglevel for details\n         *\n         */\n\n        self.name = name;\n        self.levels = {\n          \"TRACE\": 0,\n          \"DEBUG\": 1,\n          \"INFO\": 2,\n          \"WARN\": 3,\n          \"ERROR\": 4,\n          \"SILENT\": 5\n        };\n        self.methodFactory = factory || defaultMethodFactory;\n        self.getLevel = function () {\n          if (userLevel != null) {\n            return userLevel;\n          } else if (defaultLevel != null) {\n            return defaultLevel;\n          } else {\n            return inheritedLevel;\n          }\n        };\n        self.setLevel = function (level, persist) {\n          userLevel = normalizeLevel(level);\n          if (persist !== false) {\n            // defaults to true\n            persistLevelIfPossible(userLevel);\n          }\n\n          // NOTE: in v2, this should call rebuild(), which updates children.\n          return replaceLoggingMethods.call(self);\n        };\n        self.setDefaultLevel = function (level) {\n          defaultLevel = normalizeLevel(level);\n          if (!getPersistedLevel()) {\n            self.setLevel(level, false);\n          }\n        };\n        self.resetLevel = function () {\n          userLevel = null;\n          clearPersistedLevel();\n          replaceLoggingMethods.call(self);\n        };\n        self.enableAll = function (persist) {\n          self.setLevel(self.levels.TRACE, persist);\n        };\n        self.disableAll = function (persist) {\n          self.setLevel(self.levels.SILENT, persist);\n        };\n        self.rebuild = function () {\n          if (defaultLogger !== self) {\n            inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n          }\n          replaceLoggingMethods.call(self);\n          if (defaultLogger === self) {\n            for (var childName in _loggersByName) {\n              _loggersByName[childName].rebuild();\n            }\n          }\n        };\n\n        // Initialize all the internal levels.\n        inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : \"WARN\");\n        var initialLevel = getPersistedLevel();\n        if (initialLevel != null) {\n          userLevel = normalizeLevel(initialLevel);\n        }\n        replaceLoggingMethods.call(self);\n      }\n\n      /*\n       *\n       * Top-level API\n       *\n       */\n\n      defaultLogger = new Logger();\n      defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);\n        }\n        return logger;\n      };\n\n      // Grab the current global log variable in case of overwrite\n      var _log = typeof window !== undefinedType ? window.log : undefined;\n      defaultLogger.noConflict = function () {\n        if (typeof window !== undefinedType && window.log === defaultLogger) {\n          window.log = _log;\n        }\n        return defaultLogger;\n      };\n      defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n      };\n\n      // ES6 default export, for compatibility\n      defaultLogger['default'] = defaultLogger;\n      return defaultLogger;\n    });\n  })(loglevel$1);\n  return loglevel$1.exports;\n}\n\nvar loglevelExports = requireLoglevel();\n\nvar LogLevel;\n(function (LogLevel) {\n  LogLevel[LogLevel[\"trace\"] = 0] = \"trace\";\n  LogLevel[LogLevel[\"debug\"] = 1] = \"debug\";\n  LogLevel[LogLevel[\"info\"] = 2] = \"info\";\n  LogLevel[LogLevel[\"warn\"] = 3] = \"warn\";\n  LogLevel[LogLevel[\"error\"] = 4] = \"error\";\n  LogLevel[LogLevel[\"silent\"] = 5] = \"silent\";\n})(LogLevel || (LogLevel = {}));\nvar LoggerNames;\n(function (LoggerNames) {\n  LoggerNames[\"Default\"] = \"livekit\";\n  LoggerNames[\"Room\"] = \"livekit-room\";\n  LoggerNames[\"Participant\"] = \"livekit-participant\";\n  LoggerNames[\"Track\"] = \"livekit-track\";\n  LoggerNames[\"Publication\"] = \"livekit-track-publication\";\n  LoggerNames[\"Engine\"] = \"livekit-engine\";\n  LoggerNames[\"Signal\"] = \"livekit-signal\";\n  LoggerNames[\"PCManager\"] = \"livekit-pc-manager\";\n  LoggerNames[\"PCTransport\"] = \"livekit-pc-transport\";\n  LoggerNames[\"E2EE\"] = \"lk-e2ee\";\n})(LoggerNames || (LoggerNames = {}));\nlet livekitLogger = loglevelExports.getLogger('livekit');\nObject.values(LoggerNames).map(name => loglevelExports.getLogger(name));\nlivekitLogger.setDefaultLevel(LogLevel.info);\n/**\n * @internal\n */\nfunction getLogger(name) {\n  const logger = loglevelExports.getLogger(name);\n  logger.setDefaultLevel(livekitLogger.getLevel());\n  return logger;\n}\nconst workerLogger = loglevelExports.getLogger('lk-e2ee');\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Assert that condition is truthy or throw error (with message)\n */\nfunction assert(condition, msg) {\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- we want the implicit conversion to boolean\n  if (!condition) {\n    throw new Error(msg);\n  }\n}\nconst FLOAT32_MAX = 3.4028234663852886e38,\n  FLOAT32_MIN = -3.4028234663852886e38,\n  UINT32_MAX = 0xffffffff,\n  INT32_MAX = 0x7fffffff,\n  INT32_MIN = -0x80000000;\n/**\n * Assert a valid signed protobuf 32-bit integer.\n */\nfunction assertInt32(arg) {\n  if (typeof arg !== \"number\") throw new Error(\"invalid int 32: \" + typeof arg);\n  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error(\"invalid int 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid unsigned protobuf 32-bit integer.\n */\nfunction assertUInt32(arg) {\n  if (typeof arg !== \"number\") throw new Error(\"invalid uint 32: \" + typeof arg);\n  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error(\"invalid uint 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid protobuf float value.\n */\nfunction assertFloat32(arg) {\n  if (typeof arg !== \"number\") throw new Error(\"invalid float 32: \" + typeof arg);\n  if (!Number.isFinite(arg)) return;\n  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error(\"invalid float 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst enumTypeSymbol = Symbol(\"@bufbuild/protobuf/enum-type\");\n/**\n * Get reflection information from a generated enum.\n * If this function is called on something other than a generated\n * enum, it raises an error.\n */\nfunction getEnumType(enumObject) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any\n  const t = enumObject[enumTypeSymbol];\n  assert(t, \"missing enum type on enum object\");\n  return t; // eslint-disable-line @typescript-eslint/no-unsafe-return\n}\n/**\n * Sets reflection information on a generated enum.\n */\nfunction setEnumType(enumObject, typeName, values, opt) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n  enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map(v => ({\n    no: v.no,\n    name: v.name,\n    localName: enumObject[v.no]\n  })));\n}\n/**\n * Create a new EnumType with the given values.\n */\nfunction makeEnumType(typeName, values,\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n_opt) {\n  const names = Object.create(null);\n  const numbers = Object.create(null);\n  const normalValues = [];\n  for (const value of values) {\n    // We do not surface options at this time\n    // const value: EnumValueInfo = {...v, options: v.options ?? emptyReadonlyObject};\n    const n = normalizeEnumValue(value);\n    normalValues.push(n);\n    names[value.name] = n;\n    numbers[value.no] = n;\n  }\n  return {\n    typeName,\n    values: normalValues,\n    // We do not surface options at this time\n    // options: opt?.options ?? Object.create(null),\n    findName(name) {\n      return names[name];\n    },\n    findNumber(no) {\n      return numbers[no];\n    }\n  };\n}\n/**\n * Create a new enum object with the given values.\n * Sets reflection information.\n */\nfunction makeEnum(typeName, values, opt) {\n  const enumObject = {};\n  for (const value of values) {\n    const n = normalizeEnumValue(value);\n    enumObject[n.localName] = n.no;\n    enumObject[n.no] = n.localName;\n  }\n  setEnumType(enumObject, typeName, values);\n  return enumObject;\n}\nfunction normalizeEnumValue(value) {\n  if (\"localName\" in value) {\n    return value;\n  }\n  return Object.assign(Object.assign({}, value), {\n    localName: value.name\n  });\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Message is the base class of every message, generated, or created at\n * runtime.\n *\n * It is _not_ safe to extend this class. If you want to create a message at\n * run time, use proto3.makeMessageType().\n */\nclass Message {\n  /**\n   * Compare with a message of the same type.\n   * Note that this function disregards extensions and unknown fields.\n   */\n  equals(other) {\n    return this.getType().runtime.util.equals(this.getType(), this, other);\n  }\n  /**\n   * Create a deep copy.\n   */\n  clone() {\n    return this.getType().runtime.util.clone(this);\n  }\n  /**\n   * Parse from binary data, merging fields.\n   *\n   * Repeated fields are appended. Map entries are added, overwriting\n   * existing keys.\n   *\n   * If a message field is already present, it will be merged with the\n   * new data.\n   */\n  fromBinary(bytes, options) {\n    const type = this.getType(),\n      format = type.runtime.bin,\n      opt = format.makeReadOptions(options);\n    format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);\n    return this;\n  }\n  /**\n   * Parse a message from a JSON value.\n   */\n  fromJson(jsonValue, options) {\n    const type = this.getType(),\n      format = type.runtime.json,\n      opt = format.makeReadOptions(options);\n    format.readMessage(type, jsonValue, opt, this);\n    return this;\n  }\n  /**\n   * Parse a message from a JSON string.\n   */\n  fromJsonString(jsonString, options) {\n    let json;\n    try {\n      json = JSON.parse(jsonString);\n    } catch (e) {\n      throw new Error(\"cannot decode \".concat(this.getType().typeName, \" from JSON: \").concat(e instanceof Error ? e.message : String(e)));\n    }\n    return this.fromJson(json, options);\n  }\n  /**\n   * Serialize the message to binary data.\n   */\n  toBinary(options) {\n    const type = this.getType(),\n      bin = type.runtime.bin,\n      opt = bin.makeWriteOptions(options),\n      writer = opt.writerFactory();\n    bin.writeMessage(this, writer, opt);\n    return writer.finish();\n  }\n  /**\n   * Serialize the message to a JSON value, a JavaScript value that can be\n   * passed to JSON.stringify().\n   */\n  toJson(options) {\n    const type = this.getType(),\n      json = type.runtime.json,\n      opt = json.makeWriteOptions(options);\n    return json.writeMessage(this, opt);\n  }\n  /**\n   * Serialize the message to a JSON string.\n   */\n  toJsonString(options) {\n    var _a;\n    const value = this.toJson(options);\n    return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);\n  }\n  /**\n   * Override for serialization behavior. This will be invoked when calling\n   * JSON.stringify on this message (i.e. JSON.stringify(msg)).\n   *\n   * Note that this will not serialize google.protobuf.Any with a packed\n   * message because the protobuf JSON format specifies that it needs to be\n   * unpacked, and this is only possible with a type registry to look up the\n   * message type.  As a result, attempting to serialize a message with this\n   * type will throw an Error.\n   *\n   * This method is protected because you should not need to invoke it\n   * directly -- instead use JSON.stringify or toJsonString for\n   * stringified JSON.  Alternatively, if actual JSON is desired, you should\n   * use toJson.\n   */\n  toJSON() {\n    return this.toJson({\n      emitDefaultValues: true\n    });\n  }\n  /**\n   * Retrieve the MessageType of this message - a singleton that represents\n   * the protobuf message declaration and provides metadata for reflection-\n   * based operations.\n   */\n  getType() {\n    // Any class that extends Message _must_ provide a complete static\n    // implementation of MessageType.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\n    return Object.getPrototypeOf(this).constructor;\n  }\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new message type using the given runtime.\n */\nfunction makeMessageType(runtime, typeName, fields, opt) {\n  var _a;\n  const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(\".\") + 1);\n  const type = {\n    [localName]: function (data) {\n      runtime.util.initFields(this);\n      runtime.util.initPartial(data, this);\n    }\n  }[localName];\n  Object.setPrototypeOf(type.prototype, new Message());\n  Object.assign(type, {\n    runtime,\n    typeName,\n    fields: runtime.util.newFieldList(fields),\n    fromBinary(bytes, options) {\n      return new type().fromBinary(bytes, options);\n    },\n    fromJson(jsonValue, options) {\n      return new type().fromJson(jsonValue, options);\n    },\n    fromJsonString(jsonString, options) {\n      return new type().fromJsonString(jsonString, options);\n    },\n    equals(a, b) {\n      return runtime.util.equals(type, a, b);\n    }\n  });\n  return type;\n}\n\n// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */\n/**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [1]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */\nfunction varint64read() {\n  let lowBits = 0;\n  let highBits = 0;\n  for (let shift = 0; shift < 28; shift += 7) {\n    let b = this.buf[this.pos++];\n    lowBits |= (b & 0x7f) << shift;\n    if ((b & 0x80) == 0) {\n      this.assertBounds();\n      return [lowBits, highBits];\n    }\n  }\n  let middleByte = this.buf[this.pos++];\n  // last four bits of the first 32 bit number\n  lowBits |= (middleByte & 0x0f) << 28;\n  // 3 upper bits are part of the next 32 bit number\n  highBits = (middleByte & 0x70) >> 4;\n  if ((middleByte & 0x80) == 0) {\n    this.assertBounds();\n    return [lowBits, highBits];\n  }\n  for (let shift = 3; shift <= 31; shift += 7) {\n    let b = this.buf[this.pos++];\n    highBits |= (b & 0x7f) << shift;\n    if ((b & 0x80) == 0) {\n      this.assertBounds();\n      return [lowBits, highBits];\n    }\n  }\n  throw new Error(\"invalid varint\");\n}\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */\nfunction varint64write(lo, hi, bytes) {\n  for (let i = 0; i < 28; i = i + 7) {\n    const shift = lo >>> i;\n    const hasNext = !(shift >>> 7 == 0 && hi == 0);\n    const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n    bytes.push(byte);\n    if (!hasNext) {\n      return;\n    }\n  }\n  const splitBits = lo >>> 28 & 0x0f | (hi & 0x07) << 4;\n  const hasMoreBits = !(hi >> 3 == 0);\n  bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\n  if (!hasMoreBits) {\n    return;\n  }\n  for (let i = 3; i < 31; i = i + 7) {\n    const shift = hi >>> i;\n    const hasNext = !(shift >>> 7 == 0);\n    const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n    bytes.push(byte);\n    if (!hasNext) {\n      return;\n    }\n  }\n  bytes.push(hi >>> 31 & 0x01);\n}\n// constants for binary math\nconst TWO_PWR_32_DBL = 0x100000000;\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nfunction int64FromString(dec) {\n  // Check for minus sign.\n  const minus = dec[0] === \"-\";\n  if (minus) {\n    dec = dec.slice(1);\n  }\n  // Work 6 decimal digits at a time, acting like we're converting base 1e6\n  // digits to binary. This is safe to do with floating point math because\n  // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n  const base = 1e6;\n  let lowBits = 0;\n  let highBits = 0;\n  function add1e6digit(begin, end) {\n    // Note: Number('') is 0.\n    const digit1e6 = Number(dec.slice(begin, end));\n    highBits *= base;\n    lowBits = lowBits * base + digit1e6;\n    // Carry bits from lowBits to\n    if (lowBits >= TWO_PWR_32_DBL) {\n      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);\n      lowBits = lowBits % TWO_PWR_32_DBL;\n    }\n  }\n  add1e6digit(-24, -18);\n  add1e6digit(-18, -12);\n  add1e6digit(-12, -6);\n  add1e6digit(-6);\n  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\n}\n/**\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nfunction int64ToString(lo, hi) {\n  let bits = newBits(lo, hi);\n  // If we're treating the input as a signed value and the high bit is set, do\n  // a manual two's complement conversion before the decimal conversion.\n  const negative = bits.hi & 0x80000000;\n  if (negative) {\n    bits = negate(bits.lo, bits.hi);\n  }\n  const result = uInt64ToString(bits.lo, bits.hi);\n  return negative ? \"-\" + result : result;\n}\n/**\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nfunction uInt64ToString(lo, hi) {\n  ({\n    lo,\n    hi\n  } = toUnsigned(lo, hi));\n  // Skip the expensive conversion if the number is small enough to use the\n  // built-in conversions.\n  // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\n  // highBits <= 0x1FFFFF can be safely expressed with a double and retain\n  // integer precision.\n  // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\n  if (hi <= 0x1FFFFF) {\n    return String(TWO_PWR_32_DBL * hi + lo);\n  }\n  // What this code is doing is essentially converting the input number from\n  // base-2 to base-1e7, which allows us to represent the 64-bit range with\n  // only 3 (very large) digits. Those digits are then trivial to convert to\n  // a base-10 string.\n  // The magic numbers used here are -\n  // 2^24 = 16777216 = (1,6777216) in base-1e7.\n  // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n  // Split 32:32 representation into 16:24:24 representation so our\n  // intermediate digits don't overflow.\n  const low = lo & 0xFFFFFF;\n  const mid = (lo >>> 24 | hi << 8) & 0xFFFFFF;\n  const high = hi >> 16 & 0xFFFF;\n  // Assemble our three base-1e7 digits, ignoring carries. The maximum\n  // value in a digit at this step is representable as a 48-bit integer, which\n  // can be stored in a 64-bit floating point number.\n  let digitA = low + mid * 6777216 + high * 6710656;\n  let digitB = mid + high * 8147497;\n  let digitC = high * 2;\n  // Apply carries from A to B and from B to C.\n  const base = 10000000;\n  if (digitA >= base) {\n    digitB += Math.floor(digitA / base);\n    digitA %= base;\n  }\n  if (digitB >= base) {\n    digitC += Math.floor(digitB / base);\n    digitB %= base;\n  }\n  // If digitC is 0, then we should have returned in the trivial code path\n  // at the top for non-safe integers. Given this, we can assume both digitB\n  // and digitA need leading zeros.\n  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);\n}\nfunction toUnsigned(lo, hi) {\n  return {\n    lo: lo >>> 0,\n    hi: hi >>> 0\n  };\n}\nfunction newBits(lo, hi) {\n  return {\n    lo: lo | 0,\n    hi: hi | 0\n  };\n}\n/**\n * Returns two's compliment negation of input.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n */\nfunction negate(lowBits, highBits) {\n  highBits = ~highBits;\n  if (lowBits) {\n    lowBits = ~lowBits + 1;\n  } else {\n    // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\n    // adding 1 to that, results in 0x100000000, which leaves\n    // the low bits 0x0 and simply adds one to the high bits.\n    highBits += 1;\n  }\n  return newBits(lowBits, highBits);\n}\n/**\n * Returns decimal representation of digit1e7 with leading zeros.\n */\nconst decimalFrom1e7WithLeadingZeros = digit1e7 => {\n  const partial = String(digit1e7);\n  return \"0000000\".slice(partial.length) + partial;\n};\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */\nfunction varint32write(value, bytes) {\n  if (value >= 0) {\n    // write value as varint 32\n    while (value > 0x7f) {\n      bytes.push(value & 0x7f | 0x80);\n      value = value >>> 7;\n    }\n    bytes.push(value);\n  } else {\n    for (let i = 0; i < 9; i++) {\n      bytes.push(value & 127 | 128);\n      value = value >> 7;\n    }\n    bytes.push(1);\n  }\n}\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */\nfunction varint32read() {\n  let b = this.buf[this.pos++];\n  let result = b & 0x7f;\n  if ((b & 0x80) == 0) {\n    this.assertBounds();\n    return result;\n  }\n  b = this.buf[this.pos++];\n  result |= (b & 0x7f) << 7;\n  if ((b & 0x80) == 0) {\n    this.assertBounds();\n    return result;\n  }\n  b = this.buf[this.pos++];\n  result |= (b & 0x7f) << 14;\n  if ((b & 0x80) == 0) {\n    this.assertBounds();\n    return result;\n  }\n  b = this.buf[this.pos++];\n  result |= (b & 0x7f) << 21;\n  if ((b & 0x80) == 0) {\n    this.assertBounds();\n    return result;\n  }\n  // Extract only last 4 bits\n  b = this.buf[this.pos++];\n  result |= (b & 0x0f) << 28;\n  for (let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++) b = this.buf[this.pos++];\n  if ((b & 0x80) != 0) throw new Error(\"invalid varint\");\n  this.assertBounds();\n  // Result can have 32 bits, convert it to unsigned\n  return result >>> 0;\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeInt64Support() {\n  const dv = new DataView(new ArrayBuffer(8));\n  // note that Safari 14 implements BigInt, but not the DataView methods\n  const ok = typeof BigInt === \"function\" && typeof dv.getBigInt64 === \"function\" && typeof dv.getBigUint64 === \"function\" && typeof dv.setBigInt64 === \"function\" && typeof dv.setBigUint64 === \"function\" && (typeof process != \"object\" || typeof process.env != \"object\" || process.env.BUF_BIGINT_DISABLE !== \"1\");\n  if (ok) {\n    const MIN = BigInt(\"-9223372036854775808\"),\n      MAX = BigInt(\"9223372036854775807\"),\n      UMIN = BigInt(\"0\"),\n      UMAX = BigInt(\"18446744073709551615\");\n    return {\n      zero: BigInt(0),\n      supported: true,\n      parse(value) {\n        const bi = typeof value == \"bigint\" ? value : BigInt(value);\n        if (bi > MAX || bi < MIN) {\n          throw new Error(\"int64 invalid: \".concat(value));\n        }\n        return bi;\n      },\n      uParse(value) {\n        const bi = typeof value == \"bigint\" ? value : BigInt(value);\n        if (bi > UMAX || bi < UMIN) {\n          throw new Error(\"uint64 invalid: \".concat(value));\n        }\n        return bi;\n      },\n      enc(value) {\n        dv.setBigInt64(0, this.parse(value), true);\n        return {\n          lo: dv.getInt32(0, true),\n          hi: dv.getInt32(4, true)\n        };\n      },\n      uEnc(value) {\n        dv.setBigInt64(0, this.uParse(value), true);\n        return {\n          lo: dv.getInt32(0, true),\n          hi: dv.getInt32(4, true)\n        };\n      },\n      dec(lo, hi) {\n        dv.setInt32(0, lo, true);\n        dv.setInt32(4, hi, true);\n        return dv.getBigInt64(0, true);\n      },\n      uDec(lo, hi) {\n        dv.setInt32(0, lo, true);\n        dv.setInt32(4, hi, true);\n        return dv.getBigUint64(0, true);\n      }\n    };\n  }\n  const assertInt64String = value => assert(/^-?[0-9]+$/.test(value), \"int64 invalid: \".concat(value));\n  const assertUInt64String = value => assert(/^[0-9]+$/.test(value), \"uint64 invalid: \".concat(value));\n  return {\n    zero: \"0\",\n    supported: false,\n    parse(value) {\n      if (typeof value != \"string\") {\n        value = value.toString();\n      }\n      assertInt64String(value);\n      return value;\n    },\n    uParse(value) {\n      if (typeof value != \"string\") {\n        value = value.toString();\n      }\n      assertUInt64String(value);\n      return value;\n    },\n    enc(value) {\n      if (typeof value != \"string\") {\n        value = value.toString();\n      }\n      assertInt64String(value);\n      return int64FromString(value);\n    },\n    uEnc(value) {\n      if (typeof value != \"string\") {\n        value = value.toString();\n      }\n      assertUInt64String(value);\n      return int64FromString(value);\n    },\n    dec(lo, hi) {\n      return int64ToString(lo, hi);\n    },\n    uDec(lo, hi) {\n      return uInt64ToString(lo, hi);\n    }\n  };\n}\nconst protoInt64 = makeInt64Support();\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Scalar value types. This is a subset of field types declared by protobuf\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\n * are omitted, but the numerical values are identical.\n */\nvar ScalarType;\n(function (ScalarType) {\n  // 0 is reserved for errors.\n  // Order is weird for historical reasons.\n  ScalarType[ScalarType[\"DOUBLE\"] = 1] = \"DOUBLE\";\n  ScalarType[ScalarType[\"FLOAT\"] = 2] = \"FLOAT\";\n  // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n  // negative values are likely.\n  ScalarType[ScalarType[\"INT64\"] = 3] = \"INT64\";\n  ScalarType[ScalarType[\"UINT64\"] = 4] = \"UINT64\";\n  // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n  // negative values are likely.\n  ScalarType[ScalarType[\"INT32\"] = 5] = \"INT32\";\n  ScalarType[ScalarType[\"FIXED64\"] = 6] = \"FIXED64\";\n  ScalarType[ScalarType[\"FIXED32\"] = 7] = \"FIXED32\";\n  ScalarType[ScalarType[\"BOOL\"] = 8] = \"BOOL\";\n  ScalarType[ScalarType[\"STRING\"] = 9] = \"STRING\";\n  // Tag-delimited aggregate.\n  // Group type is deprecated and not supported in proto3. However, Proto3\n  // implementations should still be able to parse the group wire format and\n  // treat group fields as unknown fields.\n  // TYPE_GROUP = 10,\n  // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\n  // New in version 2.\n  ScalarType[ScalarType[\"BYTES\"] = 12] = \"BYTES\";\n  ScalarType[ScalarType[\"UINT32\"] = 13] = \"UINT32\";\n  // TYPE_ENUM = 14,\n  ScalarType[ScalarType[\"SFIXED32\"] = 15] = \"SFIXED32\";\n  ScalarType[ScalarType[\"SFIXED64\"] = 16] = \"SFIXED64\";\n  ScalarType[ScalarType[\"SINT32\"] = 17] = \"SINT32\";\n  ScalarType[ScalarType[\"SINT64\"] = 18] = \"SINT64\";\n})(ScalarType || (ScalarType = {}));\n/**\n * JavaScript representation of fields with 64 bit integral types (int64, uint64,\n * sint64, fixed64, sfixed64).\n *\n * This is a subset of google.protobuf.FieldOptions.JSType, which defines JS_NORMAL,\n * JS_STRING, and JS_NUMBER. Protobuf-ES uses BigInt by default, but will use\n * String if `[jstype = JS_STRING]` is specified.\n *\n * ```protobuf\n * uint64 field_a = 1; // BigInt\n * uint64 field_b = 2 [jstype = JS_NORMAL]; // BigInt\n * uint64 field_b = 2 [jstype = JS_NUMBER]; // BigInt\n * uint64 field_b = 2 [jstype = JS_STRING]; // String\n * ```\n */\nvar LongType;\n(function (LongType) {\n  /**\n   * Use JavaScript BigInt.\n   */\n  LongType[LongType[\"BIGINT\"] = 0] = \"BIGINT\";\n  /**\n   * Use JavaScript String.\n   *\n   * Field option `[jstype = JS_STRING]`.\n   */\n  LongType[LongType[\"STRING\"] = 1] = \"STRING\";\n})(LongType || (LongType = {}));\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns true if both scalar values are equal.\n */\nfunction scalarEquals(type, a, b) {\n  if (a === b) {\n    // This correctly matches equal values except BYTES and (possibly) 64-bit integers.\n    return true;\n  }\n  // Special case BYTES - we need to compare each byte individually\n  if (type == ScalarType.BYTES) {\n    if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {\n      return false;\n    }\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // Special case 64-bit integers - we support number, string and bigint representation.\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n  switch (type) {\n    case ScalarType.UINT64:\n    case ScalarType.FIXED64:\n    case ScalarType.INT64:\n    case ScalarType.SFIXED64:\n    case ScalarType.SINT64:\n      // Loose comparison will match between 0n, 0 and \"0\".\n      return a == b;\n  }\n  // Anything that hasn't been caught by strict comparison or special cased\n  // BYTES and 64-bit integers is not equal.\n  return false;\n}\n/**\n * Returns the zero value for the given scalar type.\n */\nfunction scalarZeroValue(type, longType) {\n  switch (type) {\n    case ScalarType.BOOL:\n      return false;\n    case ScalarType.UINT64:\n    case ScalarType.FIXED64:\n    case ScalarType.INT64:\n    case ScalarType.SFIXED64:\n    case ScalarType.SINT64:\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n      return longType == 0 ? protoInt64.zero : \"0\";\n    case ScalarType.DOUBLE:\n    case ScalarType.FLOAT:\n      return 0.0;\n    case ScalarType.BYTES:\n      return new Uint8Array(0);\n    case ScalarType.STRING:\n      return \"\";\n    default:\n      // Handles INT32, UINT32, SINT32, FIXED32, SFIXED32.\n      // We do not use individual cases to save a few bytes code size.\n      return 0;\n  }\n}\n/**\n * Returns true for a zero-value. For example, an integer has the zero-value `0`,\n * a boolean is `false`, a string is `\"\"`, and bytes is an empty Uint8Array.\n *\n * In proto3, zero-values are not written to the wire, unless the field is\n * optional or repeated.\n */\nfunction isScalarZeroValue(type, value) {\n  switch (type) {\n    case ScalarType.BOOL:\n      return value === false;\n    case ScalarType.STRING:\n      return value === \"\";\n    case ScalarType.BYTES:\n      return value instanceof Uint8Array && !value.byteLength;\n    default:\n      return value == 0;\n    // Loose comparison matches 0n, 0 and \"0\"\n  }\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/restrict-plus-operands */\n/**\n * Protobuf binary format wire types.\n *\n * A wire type provides just enough information to find the length of the\n * following value.\n *\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\n */\nvar WireType;\n(function (WireType) {\n  /**\n   * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\n   */\n  WireType[WireType[\"Varint\"] = 0] = \"Varint\";\n  /**\n   * Used for fixed64, sfixed64, double.\n   * Always 8 bytes with little-endian byte order.\n   */\n  WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\n  /**\n   * Used for string, bytes, embedded messages, packed repeated fields\n   *\n   * Only repeated numeric types (types which use the varint, 32-bit,\n   * or 64-bit wire types) can be packed. In proto3, such fields are\n   * packed by default.\n   */\n  WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\n  /**\n   * Start of a tag-delimited aggregate, such as a proto2 group, or a message\n   * in editions with message_encoding = DELIMITED.\n   */\n  WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\n  /**\n   * End of a tag-delimited aggregate.\n   */\n  WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\n  /**\n   * Used for fixed32, sfixed32, float.\n   * Always 4 bytes with little-endian byte order.\n   */\n  WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\n})(WireType || (WireType = {}));\nclass BinaryWriter {\n  constructor(textEncoder) {\n    /**\n     * Previous fork states.\n     */\n    this.stack = [];\n    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();\n    this.chunks = [];\n    this.buf = [];\n  }\n  /**\n   * Return all bytes written and reset this writer.\n   */\n  finish() {\n    this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\n    let len = 0;\n    for (let i = 0; i < this.chunks.length; i++) len += this.chunks[i].length;\n    let bytes = new Uint8Array(len);\n    let offset = 0;\n    for (let i = 0; i < this.chunks.length; i++) {\n      bytes.set(this.chunks[i], offset);\n      offset += this.chunks[i].length;\n    }\n    this.chunks = [];\n    return bytes;\n  }\n  /**\n   * Start a new fork for length-delimited data like a message\n   * or a packed repeated field.\n   *\n   * Must be joined later with `join()`.\n   */\n  fork() {\n    this.stack.push({\n      chunks: this.chunks,\n      buf: this.buf\n    });\n    this.chunks = [];\n    this.buf = [];\n    return this;\n  }\n  /**\n   * Join the last fork. Write its length and bytes, then\n   * return to the previous state.\n   */\n  join() {\n    // get chunk of fork\n    let chunk = this.finish();\n    // restore previous state\n    let prev = this.stack.pop();\n    if (!prev) throw new Error(\"invalid state, fork stack empty\");\n    this.chunks = prev.chunks;\n    this.buf = prev.buf;\n    // write length of chunk as varint\n    this.uint32(chunk.byteLength);\n    return this.raw(chunk);\n  }\n  /**\n   * Writes a tag (field number and wire type).\n   *\n   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\n   *\n   * Generated code should compute the tag ahead of time and call `uint32()`.\n   */\n  tag(fieldNo, type) {\n    return this.uint32((fieldNo << 3 | type) >>> 0);\n  }\n  /**\n   * Write a chunk of raw bytes.\n   */\n  raw(chunk) {\n    if (this.buf.length) {\n      this.chunks.push(new Uint8Array(this.buf));\n      this.buf = [];\n    }\n    this.chunks.push(chunk);\n    return this;\n  }\n  /**\n   * Write a `uint32` value, an unsigned 32 bit varint.\n   */\n  uint32(value) {\n    assertUInt32(value);\n    // write value as varint 32, inlined for speed\n    while (value > 0x7f) {\n      this.buf.push(value & 0x7f | 0x80);\n      value = value >>> 7;\n    }\n    this.buf.push(value);\n    return this;\n  }\n  /**\n   * Write a `int32` value, a signed 32 bit varint.\n   */\n  int32(value) {\n    assertInt32(value);\n    varint32write(value, this.buf);\n    return this;\n  }\n  /**\n   * Write a `bool` value, a variant.\n   */\n  bool(value) {\n    this.buf.push(value ? 1 : 0);\n    return this;\n  }\n  /**\n   * Write a `bytes` value, length-delimited arbitrary data.\n   */\n  bytes(value) {\n    this.uint32(value.byteLength); // write length of chunk as varint\n    return this.raw(value);\n  }\n  /**\n   * Write a `string` value, length-delimited data converted to UTF-8 text.\n   */\n  string(value) {\n    let chunk = this.textEncoder.encode(value);\n    this.uint32(chunk.byteLength); // write length of chunk as varint\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `float` value, 32-bit floating point number.\n   */\n  float(value) {\n    assertFloat32(value);\n    let chunk = new Uint8Array(4);\n    new DataView(chunk.buffer).setFloat32(0, value, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `double` value, a 64-bit floating point number.\n   */\n  double(value) {\n    let chunk = new Uint8Array(8);\n    new DataView(chunk.buffer).setFloat64(0, value, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\n   */\n  fixed32(value) {\n    assertUInt32(value);\n    let chunk = new Uint8Array(4);\n    new DataView(chunk.buffer).setUint32(0, value, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\n   */\n  sfixed32(value) {\n    assertInt32(value);\n    let chunk = new Uint8Array(4);\n    new DataView(chunk.buffer).setInt32(0, value, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\n   */\n  sint32(value) {\n    assertInt32(value);\n    // zigzag encode\n    value = (value << 1 ^ value >> 31) >>> 0;\n    varint32write(value, this.buf);\n    return this;\n  }\n  /**\n   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\n   */\n  sfixed64(value) {\n    let chunk = new Uint8Array(8),\n      view = new DataView(chunk.buffer),\n      tc = protoInt64.enc(value);\n    view.setInt32(0, tc.lo, true);\n    view.setInt32(4, tc.hi, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\n   */\n  fixed64(value) {\n    let chunk = new Uint8Array(8),\n      view = new DataView(chunk.buffer),\n      tc = protoInt64.uEnc(value);\n    view.setInt32(0, tc.lo, true);\n    view.setInt32(4, tc.hi, true);\n    return this.raw(chunk);\n  }\n  /**\n   * Write a `int64` value, a signed 64-bit varint.\n   */\n  int64(value) {\n    let tc = protoInt64.enc(value);\n    varint64write(tc.lo, tc.hi, this.buf);\n    return this;\n  }\n  /**\n   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\n   */\n  sint64(value) {\n    let tc = protoInt64.enc(value),\n      // zigzag encode\n      sign = tc.hi >> 31,\n      lo = tc.lo << 1 ^ sign,\n      hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;\n    varint64write(lo, hi, this.buf);\n    return this;\n  }\n  /**\n   * Write a `uint64` value, an unsigned 64-bit varint.\n   */\n  uint64(value) {\n    let tc = protoInt64.uEnc(value);\n    varint64write(tc.lo, tc.hi, this.buf);\n    return this;\n  }\n}\nclass BinaryReader {\n  constructor(buf, textDecoder) {\n    this.varint64 = varint64read; // dirty cast for `this`\n    /**\n     * Read a `uint32` field, an unsigned 32 bit varint.\n     */\n    this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`\n    this.buf = buf;\n    this.len = buf.length;\n    this.pos = 0;\n    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();\n  }\n  /**\n   * Reads a tag - field number and wire type.\n   */\n  tag() {\n    let tag = this.uint32(),\n      fieldNo = tag >>> 3,\n      wireType = tag & 7;\n    if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\n    return [fieldNo, wireType];\n  }\n  /**\n   * Skip one element and return the skipped data.\n   *\n   * When skipping StartGroup, provide the tags field number to check for\n   * matching field number in the EndGroup tag.\n   */\n  skip(wireType, fieldNo) {\n    let start = this.pos;\n    switch (wireType) {\n      case WireType.Varint:\n        while (this.buf[this.pos++] & 0x80) {\n          // ignore\n        }\n        break;\n      // eslint-disable-next-line\n      // @ts-ignore TS7029: Fallthrough case in switch\n      case WireType.Bit64:\n        this.pos += 4;\n      // eslint-disable-next-line\n      // @ts-ignore TS7029: Fallthrough case in switch\n      case WireType.Bit32:\n        this.pos += 4;\n        break;\n      case WireType.LengthDelimited:\n        let len = this.uint32();\n        this.pos += len;\n        break;\n      case WireType.StartGroup:\n        for (;;) {\n          const [fn, wt] = this.tag();\n          if (wt === WireType.EndGroup) {\n            if (fieldNo !== undefined && fn !== fieldNo) {\n              throw new Error(\"invalid end group tag\");\n            }\n            break;\n          }\n          this.skip(wt, fn);\n        }\n        break;\n      default:\n        throw new Error(\"cant skip wire type \" + wireType);\n    }\n    this.assertBounds();\n    return this.buf.subarray(start, this.pos);\n  }\n  /**\n   * Throws error if position in byte array is out of range.\n   */\n  assertBounds() {\n    if (this.pos > this.len) throw new RangeError(\"premature EOF\");\n  }\n  /**\n   * Read a `int32` field, a signed 32 bit varint.\n   */\n  int32() {\n    return this.uint32() | 0;\n  }\n  /**\n   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\n   */\n  sint32() {\n    let zze = this.uint32();\n    // decode zigzag\n    return zze >>> 1 ^ -(zze & 1);\n  }\n  /**\n   * Read a `int64` field, a signed 64-bit varint.\n   */\n  int64() {\n    return protoInt64.dec(...this.varint64());\n  }\n  /**\n   * Read a `uint64` field, an unsigned 64-bit varint.\n   */\n  uint64() {\n    return protoInt64.uDec(...this.varint64());\n  }\n  /**\n   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\n   */\n  sint64() {\n    let [lo, hi] = this.varint64();\n    // decode zig zag\n    let s = -(lo & 1);\n    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;\n    hi = hi >>> 1 ^ s;\n    return protoInt64.dec(lo, hi);\n  }\n  /**\n   * Read a `bool` field, a variant.\n   */\n  bool() {\n    let [lo, hi] = this.varint64();\n    return lo !== 0 || hi !== 0;\n  }\n  /**\n   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\n   */\n  fixed32() {\n    return this.view.getUint32((this.pos += 4) - 4, true);\n  }\n  /**\n   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\n   */\n  sfixed32() {\n    return this.view.getInt32((this.pos += 4) - 4, true);\n  }\n  /**\n   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\n   */\n  fixed64() {\n    return protoInt64.uDec(this.sfixed32(), this.sfixed32());\n  }\n  /**\n   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\n   */\n  sfixed64() {\n    return protoInt64.dec(this.sfixed32(), this.sfixed32());\n  }\n  /**\n   * Read a `float` field, 32-bit floating point number.\n   */\n  float() {\n    return this.view.getFloat32((this.pos += 4) - 4, true);\n  }\n  /**\n   * Read a `double` field, a 64-bit floating point number.\n   */\n  double() {\n    return this.view.getFloat64((this.pos += 8) - 8, true);\n  }\n  /**\n   * Read a `bytes` field, length-delimited arbitrary data.\n   */\n  bytes() {\n    let len = this.uint32(),\n      start = this.pos;\n    this.pos += len;\n    this.assertBounds();\n    return this.buf.subarray(start, start + len);\n  }\n  /**\n   * Read a `string` field, length-delimited data converted to UTF-8 text.\n   */\n  string() {\n    return this.textDecoder.decode(this.bytes());\n  }\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new extension using the given runtime.\n */\nfunction makeExtension(runtime, typeName, extendee, field) {\n  let fi;\n  return {\n    typeName,\n    extendee,\n    get field() {\n      if (!fi) {\n        const i = typeof field == \"function\" ? field() : field;\n        i.name = typeName.split(\".\").pop();\n        i.jsonName = \"[\".concat(typeName, \"]\");\n        fi = runtime.util.newFieldList([i]).list()[0];\n      }\n      return fi;\n    },\n    runtime\n  };\n}\n/**\n * Create a container that allows us to read extension fields into it with the\n * same logic as regular fields.\n */\nfunction createExtensionContainer(extension) {\n  const localName = extension.field.localName;\n  const container = Object.create(null);\n  container[localName] = initExtensionField(extension);\n  return [container, () => container[localName]];\n}\nfunction initExtensionField(ext) {\n  const field = ext.field;\n  if (field.repeated) {\n    return [];\n  }\n  if (field.default !== undefined) {\n    return field.default;\n  }\n  switch (field.kind) {\n    case \"enum\":\n      return field.T.values[0].no;\n    case \"scalar\":\n      return scalarZeroValue(field.T, field.L);\n    case \"message\":\n      // eslint-disable-next-line no-case-declarations\n      const T = field.T,\n        value = new T();\n      return T.fieldWrapper ? T.fieldWrapper.unwrapField(value) : value;\n    case \"map\":\n      throw \"map fields are not allowed to be extensions\";\n  }\n}\n/**\n * Helper to filter unknown fields, optimized based on field type.\n */\nfunction filterUnknownFields(unknownFields, field) {\n  if (!field.repeated && (field.kind == \"enum\" || field.kind == \"scalar\")) {\n    // singular scalar fields do not merge, we pick the last\n    for (let i = unknownFields.length - 1; i >= 0; --i) {\n      if (unknownFields[i].no == field.no) {\n        return [unknownFields[i]];\n      }\n    }\n    return [];\n  }\n  return unknownFields.filter(uf => uf.no === field.no);\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unnecessary-condition, prefer-const */\n// lookup table from base64 character to byte\nlet encTable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n// lookup table from base64 character *code* to byte because lookup by number is fast\nlet decTable = [];\nfor (let i = 0; i < encTable.length; i++) decTable[encTable[i].charCodeAt(0)] = i;\n// support base64url variants\ndecTable[\"-\".charCodeAt(0)] = encTable.indexOf(\"+\");\ndecTable[\"_\".charCodeAt(0)] = encTable.indexOf(\"/\");\nconst protoBase64 = {\n  /**\n   * Decodes a base64 string to a byte array.\n   *\n   * - ignores white-space, including line breaks and tabs\n   * - allows inner padding (can decode concatenated base64 strings)\n   * - does not require padding\n   * - understands base64url encoding:\n   *   \"-\" instead of \"+\",\n   *   \"_\" instead of \"/\",\n   *   no padding\n   */\n  dec(base64Str) {\n    // estimate byte size, not accounting for inner padding and whitespace\n    let es = base64Str.length * 3 / 4;\n    if (base64Str[base64Str.length - 2] == \"=\") es -= 2;else if (base64Str[base64Str.length - 1] == \"=\") es -= 1;\n    let bytes = new Uint8Array(es),\n      bytePos = 0,\n      // position in byte array\n      groupPos = 0,\n      // position in base64 group\n      b,\n      // current byte\n      p = 0; // previous byte\n    for (let i = 0; i < base64Str.length; i++) {\n      b = decTable[base64Str.charCodeAt(i)];\n      if (b === undefined) {\n        switch (base64Str[i]) {\n          // @ts-ignore TS7029: Fallthrough case in switch\n          case \"=\":\n            groupPos = 0;\n          // reset state when padding found\n          // @ts-ignore TS7029: Fallthrough case in switch\n          case \"\\n\":\n          case \"\\r\":\n          case \"\\t\":\n          case \" \":\n            continue;\n          // skip white-space, and padding\n          default:\n            throw Error(\"invalid base64 string.\");\n        }\n      }\n      switch (groupPos) {\n        case 0:\n          p = b;\n          groupPos = 1;\n          break;\n        case 1:\n          bytes[bytePos++] = p << 2 | (b & 48) >> 4;\n          p = b;\n          groupPos = 2;\n          break;\n        case 2:\n          bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;\n          p = b;\n          groupPos = 3;\n          break;\n        case 3:\n          bytes[bytePos++] = (p & 3) << 6 | b;\n          groupPos = 0;\n          break;\n      }\n    }\n    if (groupPos == 1) throw Error(\"invalid base64 string.\");\n    return bytes.subarray(0, bytePos);\n  },\n  /**\n   * Encode a byte array to a base64 string.\n   */\n  enc(bytes) {\n    let base64 = \"\",\n      groupPos = 0,\n      // position in base64 group\n      b,\n      // current byte\n      p = 0; // carry over from previous byte\n    for (let i = 0; i < bytes.length; i++) {\n      b = bytes[i];\n      switch (groupPos) {\n        case 0:\n          base64 += encTable[b >> 2];\n          p = (b & 3) << 4;\n          groupPos = 1;\n          break;\n        case 1:\n          base64 += encTable[p | b >> 4];\n          p = (b & 15) << 2;\n          groupPos = 2;\n          break;\n        case 2:\n          base64 += encTable[p | b >> 6];\n          base64 += encTable[b & 63];\n          groupPos = 0;\n          break;\n      }\n    }\n    // add output padding\n    if (groupPos) {\n      base64 += encTable[p];\n      base64 += \"=\";\n      if (groupPos == 1) base64 += \"=\";\n    }\n    return base64;\n  }\n};\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Retrieve an extension value from a message.\n *\n * The function never returns undefined. Use hasExtension() to check whether an\n * extension is set. If the extension is not set, this function returns the\n * default value (if one was specified in the protobuf source), or the zero value\n * (for example `0` for numeric types, `[]` for repeated extension fields, and\n * an empty message instance for message fields).\n *\n * Extensions are stored as unknown fields on a message. To mutate an extension\n * value, make sure to store the new value with setExtension() after mutating.\n *\n * If the extension does not extend the given message, an error is raised.\n */\nfunction getExtension(message, extension, options) {\n  assertExtendee(extension, message);\n  const opt = extension.runtime.bin.makeReadOptions(options);\n  const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);\n  const [container, get] = createExtensionContainer(extension);\n  for (const uf of ufs) {\n    extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);\n  }\n  return get();\n}\n/**\n * Set an extension value on a message. If the message already has a value for\n * this extension, the value is replaced.\n *\n * If the extension does not extend the given message, an error is raised.\n */\nfunction setExtension(message, extension, value, options) {\n  assertExtendee(extension, message);\n  const readOpt = extension.runtime.bin.makeReadOptions(options);\n  const writeOpt = extension.runtime.bin.makeWriteOptions(options);\n  if (hasExtension(message, extension)) {\n    const ufs = message.getType().runtime.bin.listUnknownFields(message).filter(uf => uf.no != extension.field.no);\n    message.getType().runtime.bin.discardUnknownFields(message);\n    for (const uf of ufs) {\n      message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);\n    }\n  }\n  const writer = writeOpt.writerFactory();\n  let f = extension.field;\n  // Implicit presence does not apply to extensions, see https://github.com/protocolbuffers/protobuf/issues/8234\n  // We patch the field info to use explicit presence:\n  if (!f.opt && !f.repeated && (f.kind == \"enum\" || f.kind == \"scalar\")) {\n    f = Object.assign(Object.assign({}, extension.field), {\n      opt: true\n    });\n  }\n  extension.runtime.bin.writeField(f, value, writer, writeOpt);\n  const reader = readOpt.readerFactory(writer.finish());\n  while (reader.pos < reader.len) {\n    const [no, wireType] = reader.tag();\n    const data = reader.skip(wireType, no);\n    message.getType().runtime.bin.onUnknownField(message, no, wireType, data);\n  }\n}\n/**\n * Check whether an extension is set on a message.\n */\nfunction hasExtension(message, extension) {\n  const messageType = message.getType();\n  return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find(uf => uf.no == extension.field.no);\n}\nfunction assertExtendee(extension, message) {\n  assert(extension.extendee.typeName == message.getType().typeName, \"extension \".concat(extension.typeName, \" can only be applied to message \").concat(extension.extendee.typeName));\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns true if the field is set.\n */\nfunction isFieldSet(field, target) {\n  const localName = field.localName;\n  if (field.repeated) {\n    return target[localName].length > 0;\n  }\n  if (field.oneof) {\n    return target[field.oneof.localName].case === localName; // eslint-disable-line @typescript-eslint/no-unsafe-member-access\n  }\n  switch (field.kind) {\n    case \"enum\":\n    case \"scalar\":\n      if (field.opt || field.req) {\n        // explicit presence\n        return target[localName] !== undefined;\n      }\n      // implicit presence\n      if (field.kind == \"enum\") {\n        return target[localName] !== field.T.values[0].no;\n      }\n      return !isScalarZeroValue(field.T, target[localName]);\n    case \"message\":\n      return target[localName] !== undefined;\n    case \"map\":\n      return Object.keys(target[localName]).length > 0;\n    // eslint-disable-line @typescript-eslint/no-unsafe-argument\n  }\n}\n/**\n * Resets the field, so that isFieldSet() will return false.\n */\nfunction clearField(field, target) {\n  const localName = field.localName;\n  const implicitPresence = !field.opt && !field.req;\n  if (field.repeated) {\n    target[localName] = [];\n  } else if (field.oneof) {\n    target[field.oneof.localName] = {\n      case: undefined\n    };\n  } else {\n    switch (field.kind) {\n      case \"map\":\n        target[localName] = {};\n        break;\n      case \"enum\":\n        target[localName] = implicitPresence ? field.T.values[0].no : undefined;\n        break;\n      case \"scalar\":\n        target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : undefined;\n        break;\n      case \"message\":\n        target[localName] = undefined;\n        break;\n    }\n  }\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Check whether the given object is any subtype of Message or is a specific\n * Message by passing the type.\n *\n * Just like `instanceof`, `isMessage` narrows the type. The advantage of\n * `isMessage` is that it compares identity by the message type name, not by\n * class identity. This makes it robust against the dual package hazard and\n * similar situations, where the same message is duplicated.\n *\n * This function is _mostly_ equivalent to the `instanceof` operator. For\n * example, `isMessage(foo, MyMessage)` is the same as `foo instanceof MyMessage`,\n * and `isMessage(foo)` is the same as `foo instanceof Message`. In most cases,\n * `isMessage` should be preferred over `instanceof`.\n *\n * However, due to the fact that `isMessage` does not use class identity, there\n * are subtle differences between this function and `instanceof`. Notably,\n * calling `isMessage` on an explicit type of Message will return false.\n */\nfunction isMessage(arg, type) {\n  if (arg === null || typeof arg != \"object\") {\n    return false;\n  }\n  if (!Object.getOwnPropertyNames(Message.prototype).every(m => m in arg && typeof arg[m] == \"function\")) {\n    return false;\n  }\n  const actualType = arg.getType();\n  if (actualType === null || typeof actualType != \"function\" || !(\"typeName\" in actualType) || typeof actualType.typeName != \"string\") {\n    return false;\n  }\n  return type === undefined ? true : actualType.typeName == type.typeName;\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Wrap a primitive message field value in its corresponding wrapper\n * message. This function is idempotent.\n */\nfunction wrapField(type, value) {\n  if (isMessage(value) || !type.fieldWrapper) {\n    return value;\n  }\n  return type.fieldWrapper.wrapField(value);\n}\n({\n  \"google.protobuf.DoubleValue\": ScalarType.DOUBLE,\n  \"google.protobuf.FloatValue\": ScalarType.FLOAT,\n  \"google.protobuf.Int64Value\": ScalarType.INT64,\n  \"google.protobuf.UInt64Value\": ScalarType.UINT64,\n  \"google.protobuf.Int32Value\": ScalarType.INT32,\n  \"google.protobuf.UInt32Value\": ScalarType.UINT32,\n  \"google.protobuf.BoolValue\": ScalarType.BOOL,\n  \"google.protobuf.StringValue\": ScalarType.STRING,\n  \"google.protobuf.BytesValue\": ScalarType.BYTES\n});\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call */\n// Default options for parsing JSON.\nconst jsonReadDefaults = {\n  ignoreUnknownFields: false\n};\n// Default options for serializing to JSON.\nconst jsonWriteDefaults = {\n  emitDefaultValues: false,\n  enumAsInteger: false,\n  useProtoFieldName: false,\n  prettySpaces: 0\n};\nfunction makeReadOptions$1(options) {\n  return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;\n}\nfunction makeWriteOptions$1(options) {\n  return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;\n}\nconst tokenNull = Symbol();\nconst tokenIgnoredUnknownEnum = Symbol();\nfunction makeJsonFormat() {\n  return {\n    makeReadOptions: makeReadOptions$1,\n    makeWriteOptions: makeWriteOptions$1,\n    readMessage(type, json, options, message) {\n      if (json == null || Array.isArray(json) || typeof json != \"object\") {\n        throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\n      }\n      message = message !== null && message !== void 0 ? message : new type();\n      const oneofSeen = new Map();\n      const registry = options.typeRegistry;\n      for (const [jsonKey, jsonValue] of Object.entries(json)) {\n        const field = type.fields.findJsonName(jsonKey);\n        if (field) {\n          if (field.oneof) {\n            if (jsonValue === null && field.kind == \"scalar\") {\n              // see conformance test Required.Proto3.JsonInput.OneofFieldNull{First,Second}\n              continue;\n            }\n            const seen = oneofSeen.get(field.oneof);\n            if (seen !== undefined) {\n              throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: multiple keys for oneof \\\"\").concat(field.oneof.name, \"\\\" present: \\\"\").concat(seen, \"\\\", \\\"\").concat(jsonKey, \"\\\"\"));\n            }\n            oneofSeen.set(field.oneof, jsonKey);\n          }\n          readField$1(message, jsonValue, field, options, type);\n        } else {\n          let found = false;\n          if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith(\"[\") && jsonKey.endsWith(\"]\")) {\n            const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));\n            if (ext && ext.extendee.typeName == type.typeName) {\n              found = true;\n              const [container, get] = createExtensionContainer(ext);\n              readField$1(container, jsonValue, ext.field, options, ext);\n              // We pass on the options as BinaryReadOptions/BinaryWriteOptions,\n              // so that users can bring their own binary reader and writer factories\n              // if necessary.\n              setExtension(message, ext, get(), options);\n            }\n          }\n          if (!found && !options.ignoreUnknownFields) {\n            throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: key \\\"\").concat(jsonKey, \"\\\" is unknown\"));\n          }\n        }\n      }\n      return message;\n    },\n    writeMessage(message, options) {\n      const type = message.getType();\n      const json = {};\n      let field;\n      try {\n        for (field of type.fields.byNumber()) {\n          if (!isFieldSet(field, message)) {\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            if (field.req) {\n              throw \"required field not set\";\n            }\n            if (!options.emitDefaultValues) {\n              continue;\n            }\n            if (!canEmitFieldDefaultValue(field)) {\n              continue;\n            }\n          }\n          const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];\n          const jsonValue = writeField$1(field, value, options);\n          if (jsonValue !== undefined) {\n            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\n          }\n        }\n        const registry = options.typeRegistry;\n        if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {\n          for (const uf of type.runtime.bin.listUnknownFields(message)) {\n            const ext = registry.findExtensionFor(type.typeName, uf.no);\n            if (ext && hasExtension(message, ext)) {\n              // We pass on the options as BinaryReadOptions, so that users can bring their own\n              // binary reader factory if necessary.\n              const value = getExtension(message, ext, options);\n              const jsonValue = writeField$1(ext.field, value, options);\n              if (jsonValue !== undefined) {\n                json[ext.field.jsonName] = jsonValue;\n              }\n            }\n          }\n        }\n      } catch (e) {\n        const m = field ? \"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to JSON\") : \"cannot encode message \".concat(type.typeName, \" to JSON\");\n        const r = e instanceof Error ? e.message : String(e);\n        throw new Error(m + (r.length > 0 ? \": \".concat(r) : \"\"));\n      }\n      return json;\n    },\n    readScalar(type, json, longType) {\n      // The signature of our internal function has changed. For backwards-\n      // compatibility, we support the old form that is part of the public API\n      // through the interface JsonFormat.\n      return readScalar$1(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);\n    },\n    writeScalar(type, value, emitDefaultValues) {\n      // The signature of our internal function has changed. For backwards-\n      // compatibility, we support the old form that is part of the public API\n      // through the interface JsonFormat.\n      if (value === undefined) {\n        return undefined;\n      }\n      if (emitDefaultValues || isScalarZeroValue(type, value)) {\n        return writeScalar$1(type, value);\n      }\n      return undefined;\n    },\n    debug: debugJsonValue\n  };\n}\nfunction debugJsonValue(json) {\n  if (json === null) {\n    return \"null\";\n  }\n  switch (typeof json) {\n    case \"object\":\n      return Array.isArray(json) ? \"array\" : \"object\";\n    case \"string\":\n      return json.length > 100 ? \"string\" : \"\\\"\".concat(json.split('\"').join('\\\\\"'), \"\\\"\");\n    default:\n      return String(json);\n  }\n}\n// Read a JSON value for a field.\n// The \"parentType\" argument is only used to provide context in errors.\nfunction readField$1(target, jsonValue, field, options, parentType) {\n  let localName = field.localName;\n  if (field.repeated) {\n    assert(field.kind != \"map\");\n    if (jsonValue === null) {\n      return;\n    }\n    if (!Array.isArray(jsonValue)) {\n      throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue)));\n    }\n    const targetArray = target[localName];\n    for (const jsonItem of jsonValue) {\n      if (jsonItem === null) {\n        throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonItem)));\n      }\n      switch (field.kind) {\n        case \"message\":\n          targetArray.push(field.T.fromJson(jsonItem, options));\n          break;\n        case \"enum\":\n          const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);\n          if (enumValue !== tokenIgnoredUnknownEnum) {\n            targetArray.push(enumValue);\n          }\n          break;\n        case \"scalar\":\n          try {\n            targetArray.push(readScalar$1(field.T, jsonItem, field.L, true));\n          } catch (e) {\n            let m = \"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonItem));\n            if (e instanceof Error && e.message.length > 0) {\n              m += \": \".concat(e.message);\n            }\n            throw new Error(m);\n          }\n          break;\n      }\n    }\n  } else if (field.kind == \"map\") {\n    if (jsonValue === null) {\n      return;\n    }\n    if (typeof jsonValue != \"object\" || Array.isArray(jsonValue)) {\n      throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue)));\n    }\n    const targetMap = target[localName];\n    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {\n      if (jsonMapValue === null) {\n        throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: map value null\"));\n      }\n      let key;\n      try {\n        key = readMapKey(field.K, jsonMapKey);\n      } catch (e) {\n        let m = \"cannot decode map key for field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n        if (e instanceof Error && e.message.length > 0) {\n          m += \": \".concat(e.message);\n        }\n        throw new Error(m);\n      }\n      switch (field.V.kind) {\n        case \"message\":\n          targetMap[key] = field.V.T.fromJson(jsonMapValue, options);\n          break;\n        case \"enum\":\n          const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);\n          if (enumValue !== tokenIgnoredUnknownEnum) {\n            targetMap[key] = enumValue;\n          }\n          break;\n        case \"scalar\":\n          try {\n            targetMap[key] = readScalar$1(field.V.T, jsonMapValue, LongType.BIGINT, true);\n          } catch (e) {\n            let m = \"cannot decode map value for field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n            if (e instanceof Error && e.message.length > 0) {\n              m += \": \".concat(e.message);\n            }\n            throw new Error(m);\n          }\n          break;\n      }\n    }\n  } else {\n    if (field.oneof) {\n      target = target[field.oneof.localName] = {\n        case: localName\n      };\n      localName = \"value\";\n    }\n    switch (field.kind) {\n      case \"message\":\n        const messageType = field.T;\n        if (jsonValue === null && messageType.typeName != \"google.protobuf.Value\") {\n          return;\n        }\n        let currentValue = target[localName];\n        if (isMessage(currentValue)) {\n          currentValue.fromJson(jsonValue, options);\n        } else {\n          target[localName] = currentValue = messageType.fromJson(jsonValue, options);\n          if (messageType.fieldWrapper && !field.oneof) {\n            target[localName] = messageType.fieldWrapper.unwrapField(currentValue);\n          }\n        }\n        break;\n      case \"enum\":\n        const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);\n        switch (enumValue) {\n          case tokenNull:\n            clearField(field, target);\n            break;\n          case tokenIgnoredUnknownEnum:\n            break;\n          default:\n            target[localName] = enumValue;\n            break;\n        }\n        break;\n      case \"scalar\":\n        try {\n          const scalarValue = readScalar$1(field.T, jsonValue, field.L, false);\n          switch (scalarValue) {\n            case tokenNull:\n              clearField(field, target);\n              break;\n            default:\n              target[localName] = scalarValue;\n              break;\n          }\n        } catch (e) {\n          let m = \"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n          if (e instanceof Error && e.message.length > 0) {\n            m += \": \".concat(e.message);\n          }\n          throw new Error(m);\n        }\n        break;\n    }\n  }\n}\nfunction readMapKey(type, json) {\n  if (type === ScalarType.BOOL) {\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch (json) {\n      case \"true\":\n        json = true;\n        break;\n      case \"false\":\n        json = false;\n        break;\n    }\n  }\n  return readScalar$1(type, json, LongType.BIGINT, true).toString();\n}\nfunction readScalar$1(type, json, longType, nullAsZeroValue) {\n  if (json === null) {\n    if (nullAsZeroValue) {\n      return scalarZeroValue(type, longType);\n    }\n    return tokenNull;\n  }\n  // every valid case in the switch below returns, and every fall\n  // through is regarded as a failure.\n  switch (type) {\n    // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n    // Either numbers or strings are accepted. Exponent notation is also accepted.\n    case ScalarType.DOUBLE:\n    case ScalarType.FLOAT:\n      if (json === \"NaN\") return Number.NaN;\n      if (json === \"Infinity\") return Number.POSITIVE_INFINITY;\n      if (json === \"-Infinity\") return Number.NEGATIVE_INFINITY;\n      if (json === \"\") {\n        // empty string is not a number\n        break;\n      }\n      if (typeof json == \"string\" && json.trim().length !== json.length) {\n        // extra whitespace\n        break;\n      }\n      if (typeof json != \"string\" && typeof json != \"number\") {\n        break;\n      }\n      const float = Number(json);\n      if (Number.isNaN(float)) {\n        // not a number\n        break;\n      }\n      if (!Number.isFinite(float)) {\n        // infinity and -infinity are handled by string representation above, so this is an error\n        break;\n      }\n      if (type == ScalarType.FLOAT) assertFloat32(float);\n      return float;\n    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n    case ScalarType.INT32:\n    case ScalarType.FIXED32:\n    case ScalarType.SFIXED32:\n    case ScalarType.SINT32:\n    case ScalarType.UINT32:\n      let int32;\n      if (typeof json == \"number\") int32 = json;else if (typeof json == \"string\" && json.length > 0) {\n        if (json.trim().length === json.length) int32 = Number(json);\n      }\n      if (int32 === undefined) break;\n      if (type == ScalarType.UINT32 || type == ScalarType.FIXED32) assertUInt32(int32);else assertInt32(int32);\n      return int32;\n    // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.\n    case ScalarType.INT64:\n    case ScalarType.SFIXED64:\n    case ScalarType.SINT64:\n      if (typeof json != \"number\" && typeof json != \"string\") break;\n      const long = protoInt64.parse(json);\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      return longType ? long.toString() : long;\n    case ScalarType.FIXED64:\n    case ScalarType.UINT64:\n      if (typeof json != \"number\" && typeof json != \"string\") break;\n      const uLong = protoInt64.uParse(json);\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      return longType ? uLong.toString() : uLong;\n    // bool:\n    case ScalarType.BOOL:\n      if (typeof json !== \"boolean\") break;\n      return json;\n    // string:\n    case ScalarType.STRING:\n      if (typeof json !== \"string\") {\n        break;\n      }\n      // A string must always contain UTF-8 encoded or 7-bit ASCII.\n      // We validate with encodeURIComponent, which appears to be the fastest widely available option.\n      try {\n        encodeURIComponent(json);\n      } catch (e) {\n        throw new Error(\"invalid UTF8\");\n      }\n      return json;\n    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n    // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n    case ScalarType.BYTES:\n      if (json === \"\") return new Uint8Array(0);\n      if (typeof json !== \"string\") break;\n      return protoBase64.dec(json);\n  }\n  throw new Error();\n}\nfunction readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {\n  if (json === null) {\n    if (type.typeName == \"google.protobuf.NullValue\") {\n      return 0; // google.protobuf.NullValue.NULL_VALUE = 0\n    }\n    return nullAsZeroValue ? type.values[0].no : tokenNull;\n  }\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n  switch (typeof json) {\n    case \"number\":\n      if (Number.isInteger(json)) {\n        return json;\n      }\n      break;\n    case \"string\":\n      const value = type.findName(json);\n      if (value !== undefined) {\n        return value.no;\n      }\n      if (ignoreUnknownFields) {\n        return tokenIgnoredUnknownEnum;\n      }\n      break;\n  }\n  throw new Error(\"cannot decode enum \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\n}\n// Decide whether an unset field should be emitted with JSON write option `emitDefaultValues`\nfunction canEmitFieldDefaultValue(field) {\n  if (field.repeated || field.kind == \"map\") {\n    // maps are {}, repeated fields are []\n    return true;\n  }\n  if (field.oneof) {\n    // oneof fields are never emitted\n    return false;\n  }\n  if (field.kind == \"message\") {\n    // singular message field are allowed to emit JSON null, but we do not\n    return false;\n  }\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n  if (field.opt || field.req) {\n    // the field uses explicit presence, so we cannot emit a zero value\n    return false;\n  }\n  return true;\n}\nfunction writeField$1(field, value, options) {\n  if (field.kind == \"map\") {\n    assert(typeof value == \"object\" && value != null);\n    const jsonObj = {};\n    const entries = Object.entries(value);\n    switch (field.V.kind) {\n      case \"scalar\":\n        for (const [entryKey, entryValue] of entries) {\n          jsonObj[entryKey.toString()] = writeScalar$1(field.V.T, entryValue); // JSON standard allows only (double quoted) string as property key\n        }\n        break;\n      case \"message\":\n        for (const [entryKey, entryValue] of entries) {\n          // JSON standard allows only (double quoted) string as property key\n          jsonObj[entryKey.toString()] = entryValue.toJson(options);\n        }\n        break;\n      case \"enum\":\n        const enumType = field.V.T;\n        for (const [entryKey, entryValue] of entries) {\n          // JSON standard allows only (double quoted) string as property key\n          jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);\n        }\n        break;\n    }\n    return options.emitDefaultValues || entries.length > 0 ? jsonObj : undefined;\n  }\n  if (field.repeated) {\n    assert(Array.isArray(value));\n    const jsonArr = [];\n    switch (field.kind) {\n      case \"scalar\":\n        for (let i = 0; i < value.length; i++) {\n          jsonArr.push(writeScalar$1(field.T, value[i]));\n        }\n        break;\n      case \"enum\":\n        for (let i = 0; i < value.length; i++) {\n          jsonArr.push(writeEnum(field.T, value[i], options.enumAsInteger));\n        }\n        break;\n      case \"message\":\n        for (let i = 0; i < value.length; i++) {\n          jsonArr.push(value[i].toJson(options));\n        }\n        break;\n    }\n    return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : undefined;\n  }\n  switch (field.kind) {\n    case \"scalar\":\n      return writeScalar$1(field.T, value);\n    case \"enum\":\n      return writeEnum(field.T, value, options.enumAsInteger);\n    case \"message\":\n      return wrapField(field.T, value).toJson(options);\n  }\n}\nfunction writeEnum(type, value, enumAsInteger) {\n  var _a;\n  assert(typeof value == \"number\");\n  if (type.typeName == \"google.protobuf.NullValue\") {\n    return null;\n  }\n  if (enumAsInteger) {\n    return value;\n  }\n  const val = type.findNumber(value);\n  return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value; // if we don't know the enum value, just return the number\n}\nfunction writeScalar$1(type, value) {\n  switch (type) {\n    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n    case ScalarType.INT32:\n    case ScalarType.SFIXED32:\n    case ScalarType.SINT32:\n    case ScalarType.FIXED32:\n    case ScalarType.UINT32:\n      assert(typeof value == \"number\");\n      return value;\n    // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n    // Either numbers or strings are accepted. Exponent notation is also accepted.\n    case ScalarType.FLOAT:\n    // assertFloat32(value);\n    case ScalarType.DOUBLE:\n      // eslint-disable-line no-fallthrough\n      assert(typeof value == \"number\");\n      if (Number.isNaN(value)) return \"NaN\";\n      if (value === Number.POSITIVE_INFINITY) return \"Infinity\";\n      if (value === Number.NEGATIVE_INFINITY) return \"-Infinity\";\n      return value;\n    // string:\n    case ScalarType.STRING:\n      assert(typeof value == \"string\");\n      return value;\n    // bool:\n    case ScalarType.BOOL:\n      assert(typeof value == \"boolean\");\n      return value;\n    // JSON value will be a decimal string. Either numbers or strings are accepted.\n    case ScalarType.UINT64:\n    case ScalarType.FIXED64:\n    case ScalarType.INT64:\n    case ScalarType.SFIXED64:\n    case ScalarType.SINT64:\n      assert(typeof value == \"bigint\" || typeof value == \"string\" || typeof value == \"number\");\n      return value.toString();\n    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n    // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n    case ScalarType.BYTES:\n      assert(value instanceof Uint8Array);\n      return protoBase64.enc(value);\n  }\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-return */\nconst unknownFieldsSymbol = Symbol(\"@bufbuild/protobuf/unknown-fields\");\n// Default options for parsing binary data.\nconst readDefaults = {\n  readUnknownFields: true,\n  readerFactory: bytes => new BinaryReader(bytes)\n};\n// Default options for serializing binary data.\nconst writeDefaults = {\n  writeUnknownFields: true,\n  writerFactory: () => new BinaryWriter()\n};\nfunction makeReadOptions(options) {\n  return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;\n}\nfunction makeWriteOptions(options) {\n  return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;\n}\nfunction makeBinaryFormat() {\n  return {\n    makeReadOptions,\n    makeWriteOptions,\n    listUnknownFields(message) {\n      var _a;\n      return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];\n    },\n    discardUnknownFields(message) {\n      delete message[unknownFieldsSymbol];\n    },\n    writeUnknownFields(message, writer) {\n      const m = message;\n      const c = m[unknownFieldsSymbol];\n      if (c) {\n        for (const f of c) {\n          writer.tag(f.no, f.wireType).raw(f.data);\n        }\n      }\n    },\n    onUnknownField(message, no, wireType, data) {\n      const m = message;\n      if (!Array.isArray(m[unknownFieldsSymbol])) {\n        m[unknownFieldsSymbol] = [];\n      }\n      m[unknownFieldsSymbol].push({\n        no,\n        wireType,\n        data\n      });\n    },\n    readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {\n      const type = message.getType();\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n      const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;\n      let fieldNo, wireType;\n      while (reader.pos < end) {\n        [fieldNo, wireType] = reader.tag();\n        if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {\n          break;\n        }\n        const field = type.fields.find(fieldNo);\n        if (!field) {\n          const data = reader.skip(wireType, fieldNo);\n          if (options.readUnknownFields) {\n            this.onUnknownField(message, fieldNo, wireType, data);\n          }\n          continue;\n        }\n        readField(message, reader, field, wireType, options);\n      }\n      if (delimitedMessageEncoding && (\n      // eslint-disable-line @typescript-eslint/strict-boolean-expressions\n      wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {\n        throw new Error(\"invalid end group tag\");\n      }\n    },\n    readField,\n    writeMessage(message, writer, options) {\n      const type = message.getType();\n      for (const field of type.fields.byNumber()) {\n        if (!isFieldSet(field, message)) {\n          if (field.req) {\n            throw new Error(\"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to binary: required field not set\"));\n          }\n          continue;\n        }\n        const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];\n        writeField(field, value, writer, options);\n      }\n      if (options.writeUnknownFields) {\n        this.writeUnknownFields(message, writer);\n      }\n      return writer;\n    },\n    writeField(field, value, writer, options) {\n      // The behavior of our internal function has changed, it does no longer\n      // accept `undefined` values for singular scalar and map.\n      // For backwards-compatibility, we support the old form that is part of\n      // the public API through the interface BinaryFormat.\n      if (value === undefined) {\n        return undefined;\n      }\n      writeField(field, value, writer, options);\n    }\n  };\n}\nfunction readField(target,\n// eslint-disable-line @typescript-eslint/no-explicit-any -- `any` is the best choice for dynamic access\nreader, field, wireType, options) {\n  let {\n    repeated,\n    localName\n  } = field;\n  if (field.oneof) {\n    target = target[field.oneof.localName];\n    if (target.case != localName) {\n      delete target.value;\n    }\n    target.case = localName;\n    localName = \"value\";\n  }\n  switch (field.kind) {\n    case \"scalar\":\n    case \"enum\":\n      const scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n      let read = readScalar;\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n      if (field.kind == \"scalar\" && field.L > 0) {\n        read = readScalarLTString;\n      }\n      if (repeated) {\n        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\n        const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;\n        if (isPacked) {\n          let e = reader.uint32() + reader.pos;\n          while (reader.pos < e) {\n            arr.push(read(reader, scalarType));\n          }\n        } else {\n          arr.push(read(reader, scalarType));\n        }\n      } else {\n        target[localName] = read(reader, scalarType);\n      }\n      break;\n    case \"message\":\n      const messageType = field.T;\n      if (repeated) {\n        // safe to assume presence of array, oneof cannot contain repeated values\n        target[localName].push(readMessageField(reader, new messageType(), options, field));\n      } else {\n        if (isMessage(target[localName])) {\n          readMessageField(reader, target[localName], options, field);\n        } else {\n          target[localName] = readMessageField(reader, new messageType(), options, field);\n          if (messageType.fieldWrapper && !field.oneof && !field.repeated) {\n            target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n          }\n        }\n      }\n      break;\n    case \"map\":\n      let [mapKey, mapVal] = readMapEntry(field, reader, options);\n      // safe to assume presence of map object, oneof cannot contain repeated values\n      target[localName][mapKey] = mapVal;\n      break;\n  }\n}\n// Read a message, avoiding MessageType.fromBinary() to re-use the\n// BinaryReadOptions and the IBinaryReader.\nfunction readMessageField(reader, message, options, field) {\n  const format = message.getType().runtime.bin;\n  const delimited = field === null || field === void 0 ? void 0 : field.delimited;\n  format.readMessage(message, reader, delimited ? field.no : reader.uint32(),\n  // eslint-disable-line @typescript-eslint/strict-boolean-expressions\n  options, delimited);\n  return message;\n}\n// Read a map field, expecting key field = 1, value field = 2\nfunction readMapEntry(field, reader, options) {\n  const length = reader.uint32(),\n    end = reader.pos + length;\n  let key, val;\n  while (reader.pos < end) {\n    const [fieldNo] = reader.tag();\n    switch (fieldNo) {\n      case 1:\n        key = readScalar(reader, field.K);\n        break;\n      case 2:\n        switch (field.V.kind) {\n          case \"scalar\":\n            val = readScalar(reader, field.V.T);\n            break;\n          case \"enum\":\n            val = reader.int32();\n            break;\n          case \"message\":\n            val = readMessageField(reader, new field.V.T(), options, undefined);\n            break;\n        }\n        break;\n    }\n  }\n  if (key === undefined) {\n    key = scalarZeroValue(field.K, LongType.BIGINT);\n  }\n  if (typeof key != \"string\" && typeof key != \"number\") {\n    key = key.toString();\n  }\n  if (val === undefined) {\n    switch (field.V.kind) {\n      case \"scalar\":\n        val = scalarZeroValue(field.V.T, LongType.BIGINT);\n        break;\n      case \"enum\":\n        val = field.V.T.values[0].no;\n        break;\n      case \"message\":\n        val = new field.V.T();\n        break;\n    }\n  }\n  return [key, val];\n}\n// Read a scalar value, but return 64 bit integral types (int64, uint64,\n// sint64, fixed64, sfixed64) as string instead of bigint.\nfunction readScalarLTString(reader, type) {\n  const v = readScalar(reader, type);\n  return typeof v == \"bigint\" ? v.toString() : v;\n}\n// Does not use scalarTypeInfo() for better performance.\nfunction readScalar(reader, type) {\n  switch (type) {\n    case ScalarType.STRING:\n      return reader.string();\n    case ScalarType.BOOL:\n      return reader.bool();\n    case ScalarType.DOUBLE:\n      return reader.double();\n    case ScalarType.FLOAT:\n      return reader.float();\n    case ScalarType.INT32:\n      return reader.int32();\n    case ScalarType.INT64:\n      return reader.int64();\n    case ScalarType.UINT64:\n      return reader.uint64();\n    case ScalarType.FIXED64:\n      return reader.fixed64();\n    case ScalarType.BYTES:\n      return reader.bytes();\n    case ScalarType.FIXED32:\n      return reader.fixed32();\n    case ScalarType.SFIXED32:\n      return reader.sfixed32();\n    case ScalarType.SFIXED64:\n      return reader.sfixed64();\n    case ScalarType.SINT64:\n      return reader.sint64();\n    case ScalarType.UINT32:\n      return reader.uint32();\n    case ScalarType.SINT32:\n      return reader.sint32();\n  }\n}\nfunction writeField(field, value, writer, options) {\n  assert(value !== undefined);\n  const repeated = field.repeated;\n  switch (field.kind) {\n    case \"scalar\":\n    case \"enum\":\n      let scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n      if (repeated) {\n        assert(Array.isArray(value));\n        if (field.packed) {\n          writePacked(writer, scalarType, field.no, value);\n        } else {\n          for (const item of value) {\n            writeScalar(writer, scalarType, field.no, item);\n          }\n        }\n      } else {\n        writeScalar(writer, scalarType, field.no, value);\n      }\n      break;\n    case \"message\":\n      if (repeated) {\n        assert(Array.isArray(value));\n        for (const item of value) {\n          writeMessageField(writer, options, field, item);\n        }\n      } else {\n        writeMessageField(writer, options, field, value);\n      }\n      break;\n    case \"map\":\n      assert(typeof value == \"object\" && value != null);\n      for (const [key, val] of Object.entries(value)) {\n        writeMapEntry(writer, options, field, key, val);\n      }\n      break;\n  }\n}\nfunction writeMapEntry(writer, options, field, key, value) {\n  writer.tag(field.no, WireType.LengthDelimited);\n  writer.fork();\n  // javascript only allows number or string for object properties\n  // we convert from our representation to the protobuf type\n  let keyValue = key;\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- we deliberately handle just the special cases for map keys\n  switch (field.K) {\n    case ScalarType.INT32:\n    case ScalarType.FIXED32:\n    case ScalarType.UINT32:\n    case ScalarType.SFIXED32:\n    case ScalarType.SINT32:\n      keyValue = Number.parseInt(key);\n      break;\n    case ScalarType.BOOL:\n      assert(key == \"true\" || key == \"false\");\n      keyValue = key == \"true\";\n      break;\n  }\n  // write key, expecting key field number = 1\n  writeScalar(writer, field.K, 1, keyValue);\n  // write value, expecting value field number = 2\n  switch (field.V.kind) {\n    case \"scalar\":\n      writeScalar(writer, field.V.T, 2, value);\n      break;\n    case \"enum\":\n      writeScalar(writer, ScalarType.INT32, 2, value);\n      break;\n    case \"message\":\n      assert(value !== undefined);\n      writer.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));\n      break;\n  }\n  writer.join();\n}\n// Value must not be undefined\nfunction writeMessageField(writer, options, field, value) {\n  const message = wrapField(field.T, value);\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n  if (field.delimited) writer.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);else writer.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));\n}\nfunction writeScalar(writer, type, fieldNo, value) {\n  assert(value !== undefined);\n  let [wireType, method] = scalarTypeInfo(type);\n  writer.tag(fieldNo, wireType)[method](value);\n}\nfunction writePacked(writer, type, fieldNo, value) {\n  if (!value.length) {\n    return;\n  }\n  writer.tag(fieldNo, WireType.LengthDelimited).fork();\n  let [, method] = scalarTypeInfo(type);\n  for (let i = 0; i < value.length; i++) {\n    writer[method](value[i]);\n  }\n  writer.join();\n}\n/**\n * Get information for writing a scalar value.\n *\n * Returns tuple:\n * [0]: appropriate WireType\n * [1]: name of the appropriate method of IBinaryWriter\n * [2]: whether the given value is a default value for proto3 semantics\n *\n * If argument `value` is omitted, [2] is always false.\n */\n// TODO replace call-sites writeScalar() and writePacked(), then remove\nfunction scalarTypeInfo(type) {\n  let wireType = WireType.Varint;\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- INT32, UINT32, SINT32 are covered by the defaults\n  switch (type) {\n    case ScalarType.BYTES:\n    case ScalarType.STRING:\n      wireType = WireType.LengthDelimited;\n      break;\n    case ScalarType.DOUBLE:\n    case ScalarType.FIXED64:\n    case ScalarType.SFIXED64:\n      wireType = WireType.Bit64;\n      break;\n    case ScalarType.FIXED32:\n    case ScalarType.SFIXED32:\n    case ScalarType.FLOAT:\n      wireType = WireType.Bit32;\n      break;\n  }\n  const method = ScalarType[type].toLowerCase();\n  return [wireType, method];\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-argument,no-case-declarations */\nfunction makeUtilCommon() {\n  return {\n    setEnumType,\n    initPartial(source, target) {\n      if (source === undefined) {\n        return;\n      }\n      const type = target.getType();\n      for (const member of type.fields.byMember()) {\n        const localName = member.localName,\n          t = target,\n          s = source;\n        if (s[localName] == null) {\n          // TODO if source is a Message instance, we should use isFieldSet() here to support future field presence\n          continue;\n        }\n        switch (member.kind) {\n          case \"oneof\":\n            const sk = s[localName].case;\n            if (sk === undefined) {\n              continue;\n            }\n            const sourceField = member.findField(sk);\n            let val = s[localName].value;\n            if (sourceField && sourceField.kind == \"message\" && !isMessage(val, sourceField.T)) {\n              val = new sourceField.T(val);\n            } else if (sourceField && sourceField.kind === \"scalar\" && sourceField.T === ScalarType.BYTES) {\n              val = toU8Arr(val);\n            }\n            t[localName] = {\n              case: sk,\n              value: val\n            };\n            break;\n          case \"scalar\":\n          case \"enum\":\n            let copy = s[localName];\n            if (member.T === ScalarType.BYTES) {\n              copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);\n            }\n            t[localName] = copy;\n            break;\n          case \"map\":\n            switch (member.V.kind) {\n              case \"scalar\":\n              case \"enum\":\n                if (member.V.T === ScalarType.BYTES) {\n                  for (const [k, v] of Object.entries(s[localName])) {\n                    t[localName][k] = toU8Arr(v);\n                  }\n                } else {\n                  Object.assign(t[localName], s[localName]);\n                }\n                break;\n              case \"message\":\n                const messageType = member.V.T;\n                for (const k of Object.keys(s[localName])) {\n                  let val = s[localName][k];\n                  if (!messageType.fieldWrapper) {\n                    // We only take partial input for messages that are not a wrapper type.\n                    // For those messages, we recursively normalize the partial input.\n                    val = new messageType(val);\n                  }\n                  t[localName][k] = val;\n                }\n                break;\n            }\n            break;\n          case \"message\":\n            const mt = member.T;\n            if (member.repeated) {\n              t[localName] = s[localName].map(val => isMessage(val, mt) ? val : new mt(val));\n            } else {\n              const val = s[localName];\n              if (mt.fieldWrapper) {\n                if (\n                // We can't use BytesValue.typeName as that will create a circular import\n                mt.typeName === \"google.protobuf.BytesValue\") {\n                  t[localName] = toU8Arr(val);\n                } else {\n                  t[localName] = val;\n                }\n              } else {\n                t[localName] = isMessage(val, mt) ? val : new mt(val);\n              }\n            }\n            break;\n        }\n      }\n    },\n    // TODO use isFieldSet() here to support future field presence\n    equals(type, a, b) {\n      if (a === b) {\n        return true;\n      }\n      if (!a || !b) {\n        return false;\n      }\n      return type.fields.byMember().every(m => {\n        const va = a[m.localName];\n        const vb = b[m.localName];\n        if (m.repeated) {\n          if (va.length !== vb.length) {\n            return false;\n          }\n          // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- repeated fields are never \"map\"\n          switch (m.kind) {\n            case \"message\":\n              return va.every((a, i) => m.T.equals(a, vb[i]));\n            case \"scalar\":\n              return va.every((a, i) => scalarEquals(m.T, a, vb[i]));\n            case \"enum\":\n              return va.every((a, i) => scalarEquals(ScalarType.INT32, a, vb[i]));\n          }\n          throw new Error(\"repeated cannot contain \".concat(m.kind));\n        }\n        switch (m.kind) {\n          case \"message\":\n            return m.T.equals(va, vb);\n          case \"enum\":\n            return scalarEquals(ScalarType.INT32, va, vb);\n          case \"scalar\":\n            return scalarEquals(m.T, va, vb);\n          case \"oneof\":\n            if (va.case !== vb.case) {\n              return false;\n            }\n            const s = m.findField(va.case);\n            if (s === undefined) {\n              return true;\n            }\n            // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- oneof fields are never \"map\"\n            switch (s.kind) {\n              case \"message\":\n                return s.T.equals(va.value, vb.value);\n              case \"enum\":\n                return scalarEquals(ScalarType.INT32, va.value, vb.value);\n              case \"scalar\":\n                return scalarEquals(s.T, va.value, vb.value);\n            }\n            throw new Error(\"oneof cannot contain \".concat(s.kind));\n          case \"map\":\n            const keys = Object.keys(va).concat(Object.keys(vb));\n            switch (m.V.kind) {\n              case \"message\":\n                const messageType = m.V.T;\n                return keys.every(k => messageType.equals(va[k], vb[k]));\n              case \"enum\":\n                return keys.every(k => scalarEquals(ScalarType.INT32, va[k], vb[k]));\n              case \"scalar\":\n                const scalarType = m.V.T;\n                return keys.every(k => scalarEquals(scalarType, va[k], vb[k]));\n            }\n            break;\n        }\n      });\n    },\n    // TODO use isFieldSet() here to support future field presence\n    clone(message) {\n      const type = message.getType(),\n        target = new type(),\n        any = target;\n      for (const member of type.fields.byMember()) {\n        const source = message[member.localName];\n        let copy;\n        if (member.repeated) {\n          copy = source.map(cloneSingularField);\n        } else if (member.kind == \"map\") {\n          copy = any[member.localName];\n          for (const [key, v] of Object.entries(source)) {\n            copy[key] = cloneSingularField(v);\n          }\n        } else if (member.kind == \"oneof\") {\n          const f = member.findField(source.case);\n          copy = f ? {\n            case: source.case,\n            value: cloneSingularField(source.value)\n          } : {\n            case: undefined\n          };\n        } else {\n          copy = cloneSingularField(source);\n        }\n        any[member.localName] = copy;\n      }\n      for (const uf of type.runtime.bin.listUnknownFields(message)) {\n        type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);\n      }\n      return target;\n    }\n  };\n}\n// clone a single field value - i.e. the element type of repeated fields, the value type of maps\nfunction cloneSingularField(value) {\n  if (value === undefined) {\n    return value;\n  }\n  if (isMessage(value)) {\n    return value.clone();\n  }\n  if (value instanceof Uint8Array) {\n    const c = new Uint8Array(value.byteLength);\n    c.set(value);\n    return c;\n  }\n  return value;\n}\n// converts any ArrayLike<number> to Uint8Array if necessary.\nfunction toU8Arr(input) {\n  return input instanceof Uint8Array ? input : new Uint8Array(input);\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeProtoRuntime(syntax, newFieldList, initFields) {\n  return {\n    syntax,\n    json: makeJsonFormat(),\n    bin: makeBinaryFormat(),\n    util: Object.assign(Object.assign({}, makeUtilCommon()), {\n      newFieldList,\n      initFields\n    }),\n    makeMessageType(typeName, fields, opt) {\n      return makeMessageType(this, typeName, fields, opt);\n    },\n    makeEnum,\n    makeEnumType,\n    getEnumType,\n    makeExtension(typeName, extendee, field) {\n      return makeExtension(this, typeName, extendee, field);\n    }\n  };\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalFieldList {\n  constructor(fields, normalizer) {\n    this._fields = fields;\n    this._normalizer = normalizer;\n  }\n  findJsonName(jsonName) {\n    if (!this.jsonNames) {\n      const t = {};\n      for (const f of this.list()) {\n        t[f.jsonName] = t[f.name] = f;\n      }\n      this.jsonNames = t;\n    }\n    return this.jsonNames[jsonName];\n  }\n  find(fieldNo) {\n    if (!this.numbers) {\n      const t = {};\n      for (const f of this.list()) {\n        t[f.no] = f;\n      }\n      this.numbers = t;\n    }\n    return this.numbers[fieldNo];\n  }\n  list() {\n    if (!this.all) {\n      this.all = this._normalizer(this._fields);\n    }\n    return this.all;\n  }\n  byNumber() {\n    if (!this.numbersAsc) {\n      this.numbersAsc = this.list().concat().sort((a, b) => a.no - b.no);\n    }\n    return this.numbersAsc;\n  }\n  byMember() {\n    if (!this.members) {\n      this.members = [];\n      const a = this.members;\n      let o;\n      for (const f of this.list()) {\n        if (f.oneof) {\n          if (f.oneof !== o) {\n            o = f.oneof;\n            a.push(o);\n          }\n        } else {\n          a.push(f);\n        }\n      }\n    }\n    return this.members;\n  }\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns the name of a protobuf element in generated code.\n *\n * Field names - including oneofs - are converted to lowerCamelCase. For\n * messages, enumerations and services, the package name is stripped from\n * the type name. For nested messages and enumerations, the names are joined\n * with an underscore. For methods, the first character is made lowercase.\n */\n/**\n * Returns the name of a field in generated code.\n */\nfunction localFieldName(protoName, inOneof) {\n  const name = protoCamelCase(protoName);\n  if (inOneof) {\n    // oneof member names are not properties, but values of the `case` property.\n    return name;\n  }\n  return safeObjectProperty(safeMessageProperty(name));\n}\n/**\n * Returns the name of a oneof group in generated code.\n */\nfunction localOneofName(protoName) {\n  return localFieldName(protoName, false);\n}\n/**\n * Returns the JSON name for a protobuf field, exactly like protoc does.\n */\nconst fieldJsonName = protoCamelCase;\n/**\n * Converts snake_case to protoCamelCase according to the convention\n * used by protoc to convert a field name to a JSON name.\n */\nfunction protoCamelCase(snakeCase) {\n  let capNext = false;\n  const b = [];\n  for (let i = 0; i < snakeCase.length; i++) {\n    let c = snakeCase.charAt(i);\n    switch (c) {\n      case \"_\":\n        capNext = true;\n        break;\n      case \"0\":\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        b.push(c);\n        capNext = false;\n        break;\n      default:\n        if (capNext) {\n          capNext = false;\n          c = c.toUpperCase();\n        }\n        b.push(c);\n        break;\n    }\n  }\n  return b.join(\"\");\n}\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */\nconst reservedObjectProperties = new Set([\n// names reserved by JavaScript\n\"constructor\", \"toString\", \"toJSON\", \"valueOf\"]);\n/**\n * Names that cannot be used for object properties because they are reserved\n * by the runtime.\n */\nconst reservedMessageProperties = new Set([\n// names reserved by the runtime\n\"getType\", \"clone\", \"equals\", \"fromBinary\", \"fromJson\", \"fromJsonString\", \"toBinary\", \"toJson\", \"toJsonString\",\n// names reserved by the runtime for the future\n\"toObject\"]);\nconst fallback = name => \"\".concat(name, \"$\");\n/**\n * Will wrap names that are Object prototype properties or names reserved\n * for `Message`s.\n */\nconst safeMessageProperty = name => {\n  if (reservedMessageProperties.has(name)) {\n    return fallback(name);\n  }\n  return name;\n};\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */\nconst safeObjectProperty = name => {\n  if (reservedObjectProperties.has(name)) {\n    return fallback(name);\n  }\n  return name;\n};\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalOneofInfo {\n  constructor(name) {\n    this.kind = \"oneof\";\n    this.repeated = false;\n    this.packed = false;\n    this.opt = false;\n    this.req = false;\n    this.default = undefined;\n    this.fields = [];\n    this.name = name;\n    this.localName = localOneofName(name);\n  }\n  addField(field) {\n    assert(field.oneof === this, \"field \".concat(field.name, \" not one of \").concat(this.name));\n    this.fields.push(field);\n  }\n  findField(localName) {\n    if (!this._lookup) {\n      this._lookup = Object.create(null);\n      for (let i = 0; i < this.fields.length; i++) {\n        this._lookup[this.fields[i].localName] = this.fields[i];\n      }\n    }\n    return this._lookup[localName];\n  }\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Convert a collection of field info to an array of normalized FieldInfo.\n *\n * The argument `packedByDefault` specifies whether fields that do not specify\n * `packed` should be packed (proto3) or unpacked (proto2).\n */\nfunction normalizeFieldInfos(fieldInfos, packedByDefault) {\n  var _a, _b, _c, _d, _e, _f;\n  const r = [];\n  let o;\n  for (const field of typeof fieldInfos == \"function\" ? fieldInfos() : fieldInfos) {\n    const f = field;\n    f.localName = localFieldName(field.name, field.oneof !== undefined);\n    f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);\n    f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;\n    if (field.kind == \"scalar\") {\n      f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;\n    }\n    f.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;\n    f.req = (_e = field.req) !== null && _e !== void 0 ? _e : false;\n    f.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;\n    if (field.packed === undefined) {\n      {\n        f.packed = field.kind == \"enum\" || field.kind == \"scalar\" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;\n      }\n    }\n    // We do not surface options at this time\n    // f.options = field.options ?? emptyReadonlyObject;\n    if (field.oneof !== undefined) {\n      const ooname = typeof field.oneof == \"string\" ? field.oneof : field.oneof.name;\n      if (!o || o.name != ooname) {\n        o = new InternalOneofInfo(ooname);\n      }\n      f.oneof = o;\n      o.addField(f);\n    }\n    r.push(f);\n  }\n  return r;\n}\n\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Provides functionality for messages defined with the proto3 syntax.\n */\nconst proto3 = makeProtoRuntime(\"proto3\", fields => {\n  return new InternalFieldList(fields, source => normalizeFieldInfos(source));\n},\n// TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone\ntarget => {\n  for (const member of target.getType().fields.byMember()) {\n    if (member.opt) {\n      continue;\n    }\n    const name = member.localName,\n      t = target;\n    if (member.repeated) {\n      t[name] = [];\n      continue;\n    }\n    switch (member.kind) {\n      case \"oneof\":\n        t[name] = {\n          case: undefined\n        };\n        break;\n      case \"enum\":\n        t[name] = 0;\n        break;\n      case \"map\":\n        t[name] = {};\n        break;\n      case \"scalar\":\n        t[name] = scalarZeroValue(member.T, member.L);\n        break;\n    }\n  }\n});\n\n// Copyright 2023 LiveKit, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * @generated from enum livekit.TrackType\n */\nconst TrackType = /*@__PURE__*/proto3.makeEnum(\"livekit.TrackType\", [{\n  no: 0,\n  name: \"AUDIO\"\n}, {\n  no: 1,\n  name: \"VIDEO\"\n}, {\n  no: 2,\n  name: \"DATA\"\n}]);\n\n/**\n * @generated from enum livekit.TrackSource\n */\nconst TrackSource = /*@__PURE__*/proto3.makeEnum(\"livekit.TrackSource\", [{\n  no: 0,\n  name: \"UNKNOWN\"\n}, {\n  no: 1,\n  name: \"CAMERA\"\n}, {\n  no: 2,\n  name: \"MICROPHONE\"\n}, {\n  no: 3,\n  name: \"SCREEN_SHARE\"\n}, {\n  no: 4,\n  name: \"SCREEN_SHARE_AUDIO\"\n}]);\n\n// Copyright 2023 LiveKit, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * @generated from enum livekit.StreamState\n */\nconst StreamState = /*@__PURE__*/proto3.makeEnum(\"livekit.StreamState\", [{\n  no: 0,\n  name: \"ACTIVE\"\n}, {\n  no: 1,\n  name: \"PAUSED\"\n}]);\n\n// tiny, simplified version of https://github.com/lancedikson/bowser/blob/master/src/parser-browsers.js\n// reduced to only differentiate Chrome(ium) based browsers / Firefox / Safari\nconst commonVersionIdentifier = /version\\/(\\d+(\\.?_?\\d+)+)/i;\nlet browserDetails;\n/**\n * @internal\n */\nfunction getBrowser(userAgent) {\n  let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (typeof navigator === 'undefined') {\n    return;\n  }\n  const ua = (navigator.userAgent).toLowerCase();\n  if (browserDetails === undefined || force) {\n    const browser = browsersList.find(_ref => {\n      let {\n        test\n      } = _ref;\n      return test.test(ua);\n    });\n    browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);\n  }\n  return browserDetails;\n}\nconst browsersList = [{\n  test: /firefox|iceweasel|fxios/i,\n  describe(ua) {\n    const browser = {\n      name: 'Firefox',\n      version: getMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, ua),\n      os: ua.toLowerCase().includes('fxios') ? 'iOS' : undefined,\n      osVersion: getOSVersion(ua)\n    };\n    return browser;\n  }\n}, {\n  test: /chrom|crios|crmo/i,\n  describe(ua) {\n    const browser = {\n      name: 'Chrome',\n      version: getMatch(/(?:chrome|chromium|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i, ua),\n      os: ua.toLowerCase().includes('crios') ? 'iOS' : undefined,\n      osVersion: getOSVersion(ua)\n    };\n    return browser;\n  }\n}, /* Safari */\n{\n  test: /safari|applewebkit/i,\n  describe(ua) {\n    const browser = {\n      name: 'Safari',\n      version: getMatch(commonVersionIdentifier, ua),\n      os: ua.includes('mobile/') ? 'iOS' : 'macOS',\n      osVersion: getOSVersion(ua)\n    };\n    return browser;\n  }\n}];\nfunction getMatch(exp, ua) {\n  let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  const match = ua.match(exp);\n  return match && match.length >= id && match[id] || '';\n}\nfunction getOSVersion(ua) {\n  return ua.includes('mac os') ? getMatch(/\\(.+?(\\d+_\\d+(:?_\\d+)?)/, ua, 1).replace(/_/g, '.') : undefined;\n}\n\nclass VideoPreset {\n  constructor(widthOrOptions, height, maxBitrate, maxFramerate, priority) {\n    if (typeof widthOrOptions === 'object') {\n      this.width = widthOrOptions.width;\n      this.height = widthOrOptions.height;\n      this.aspectRatio = widthOrOptions.aspectRatio;\n      this.encoding = {\n        maxBitrate: widthOrOptions.maxBitrate,\n        maxFramerate: widthOrOptions.maxFramerate,\n        priority: widthOrOptions.priority\n      };\n    } else if (height !== undefined && maxBitrate !== undefined) {\n      this.width = widthOrOptions;\n      this.height = height;\n      this.aspectRatio = widthOrOptions / height;\n      this.encoding = {\n        maxBitrate,\n        maxFramerate,\n        priority\n      };\n    } else {\n      throw new TypeError('Unsupported options: provide at least width, height and maxBitrate');\n    }\n  }\n  get resolution() {\n    return {\n      width: this.width,\n      height: this.height,\n      frameRate: this.encoding.maxFramerate,\n      aspectRatio: this.aspectRatio\n    };\n  }\n}\nvar AudioPresets;\n(function (AudioPresets) {\n  AudioPresets.telephone = {\n    maxBitrate: 12000\n  };\n  AudioPresets.speech = {\n    maxBitrate: 20000\n  };\n  AudioPresets.music = {\n    maxBitrate: 32000\n  };\n  AudioPresets.musicStereo = {\n    maxBitrate: 48000\n  };\n  AudioPresets.musicHighQuality = {\n    maxBitrate: 64000\n  };\n  AudioPresets.musicHighQualityStereo = {\n    maxBitrate: 96000\n  };\n})(AudioPresets || (AudioPresets = {}));\n/**\n * Sane presets for video resolution/encoding\n */\n({\n  h90: new VideoPreset(160, 90, 90000, 20),\n  h180: new VideoPreset(320, 180, 160000, 20),\n  h216: new VideoPreset(384, 216, 180000, 20),\n  h360: new VideoPreset(640, 360, 450000, 20),\n  h540: new VideoPreset(960, 540, 800000, 25),\n  h720: new VideoPreset(1280, 720, 1700000, 30),\n  h1080: new VideoPreset(1920, 1080, 3000000, 30),\n  h1440: new VideoPreset(2560, 1440, 5000000, 30),\n  h2160: new VideoPreset(3840, 2160, 8000000, 30)\n});\n/**\n * Four by three presets\n */\n({\n  h120: new VideoPreset(160, 120, 70000, 20),\n  h180: new VideoPreset(240, 180, 125000, 20),\n  h240: new VideoPreset(320, 240, 140000, 20),\n  h360: new VideoPreset(480, 360, 330000, 20),\n  h480: new VideoPreset(640, 480, 500000, 20),\n  h540: new VideoPreset(720, 540, 600000, 25),\n  h720: new VideoPreset(960, 720, 1300000, 30),\n  h1080: new VideoPreset(1440, 1080, 2300000, 30),\n  h1440: new VideoPreset(1920, 1440, 3800000, 30)\n});\n({\n  h360fps3: new VideoPreset(640, 360, 200000, 3, 'medium'),\n  h360fps15: new VideoPreset(640, 360, 400000, 15, 'medium'),\n  h720fps5: new VideoPreset(1280, 720, 800000, 5, 'medium'),\n  h720fps15: new VideoPreset(1280, 720, 1500000, 15, 'medium'),\n  h720fps30: new VideoPreset(1280, 720, 2000000, 30, 'medium'),\n  h1080fps15: new VideoPreset(1920, 1080, 2500000, 15, 'medium'),\n  h1080fps30: new VideoPreset(1920, 1080, 5000000, 30, 'medium'),\n  // original resolution, without resizing\n  original: new VideoPreset(0, 0, 7000000, 30, 'medium')\n});\n\nvar events = {exports: {}};\n\nvar hasRequiredEvents;\nfunction requireEvents() {\n  if (hasRequiredEvents) return events.exports;\n  hasRequiredEvents = 1;\n  var R = typeof Reflect === 'object' ? Reflect : null;\n  var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  };\n  var ReflectOwnKeys;\n  if (R && typeof R.ownKeys === 'function') {\n    ReflectOwnKeys = R.ownKeys;\n  } else if (Object.getOwnPropertySymbols) {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n    };\n  } else {\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\n      return Object.getOwnPropertyNames(target);\n    };\n  }\n  function ProcessEmitWarning(warning) {\n    if (console && console.warn) console.warn(warning);\n  }\n  var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n    return value !== value;\n  };\n  function EventEmitter() {\n    EventEmitter.init.call(this);\n  }\n  events.exports = EventEmitter;\n  events.exports.once = once;\n\n  // Backwards-compat with node 0.10.x\n  EventEmitter.EventEmitter = EventEmitter;\n  EventEmitter.prototype._events = undefined;\n  EventEmitter.prototype._eventsCount = 0;\n  EventEmitter.prototype._maxListeners = undefined;\n\n  // By default EventEmitters will print a warning if more than 10 listeners are\n  // added to it. This is a useful default which helps finding memory leaks.\n  var defaultMaxListeners = 10;\n  function checkListener(listener) {\n    if (typeof listener !== 'function') {\n      throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n    }\n  }\n  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function () {\n      return defaultMaxListeners;\n    },\n    set: function (arg) {\n      if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n        throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n      }\n      defaultMaxListeners = arg;\n    }\n  });\n  EventEmitter.init = function () {\n    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    }\n    this._maxListeners = this._maxListeners || undefined;\n  };\n\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n      throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n    }\n    this._maxListeners = n;\n    return this;\n  };\n  function _getMaxListeners(that) {\n    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n    return that._maxListeners;\n  }\n  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n    return _getMaxListeners(this);\n  };\n  EventEmitter.prototype.emit = function emit(type) {\n    var args = [];\n    for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n    var doError = type === 'error';\n    var events = this._events;\n    if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;\n\n    // If there is no 'error' event listener then throw.\n    if (doError) {\n      var er;\n      if (args.length > 0) er = args[0];\n      if (er instanceof Error) {\n        // Note: The comments on the `throw` lines are intentional, they show\n        // up in Node's output if this results in an unhandled exception.\n        throw er; // Unhandled 'error' event\n      }\n      // At least give some kind of context to the user\n      var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n      err.context = er;\n      throw err; // Unhandled 'error' event\n    }\n    var handler = events[type];\n    if (handler === undefined) return false;\n    if (typeof handler === 'function') {\n      ReflectApply(handler, this, args);\n    } else {\n      var len = handler.length;\n      var listeners = arrayClone(handler, len);\n      for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n    }\n    return true;\n  };\n  function _addListener(target, type, listener, prepend) {\n    var m;\n    var events;\n    var existing;\n    checkListener(listener);\n    events = target._events;\n    if (events === undefined) {\n      events = target._events = Object.create(null);\n      target._eventsCount = 0;\n    } else {\n      // To avoid recursion in the case that type === \"newListener\"! Before\n      // adding it to the listeners, first emit \"newListener\".\n      if (events.newListener !== undefined) {\n        target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n        // Re-assign `events` because a newListener handler could have caused the\n        // this._events to be assigned to a new object\n        events = target._events;\n      }\n      existing = events[type];\n    }\n    if (existing === undefined) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      existing = events[type] = listener;\n      ++target._eventsCount;\n    } else {\n      if (typeof existing === 'function') {\n        // Adding the second element, need to change to array.\n        existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n        // If we've already got an array, just append.\n      } else if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n\n      // Check for listener leak\n      m = _getMaxListeners(target);\n      if (m > 0 && existing.length > m && !existing.warned) {\n        existing.warned = true;\n        // No error code for this since it is a Warning\n        // eslint-disable-next-line no-restricted-syntax\n        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        ProcessEmitWarning(w);\n      }\n    }\n    return target;\n  }\n  EventEmitter.prototype.addListener = function addListener(type, listener) {\n    return _addListener(this, type, listener, false);\n  };\n  EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n  EventEmitter.prototype.prependListener = function prependListener(type, listener) {\n    return _addListener(this, type, listener, true);\n  };\n  function onceWrapper() {\n    if (!this.fired) {\n      this.target.removeListener(this.type, this.wrapFn);\n      this.fired = true;\n      if (arguments.length === 0) return this.listener.call(this.target);\n      return this.listener.apply(this.target, arguments);\n    }\n  }\n  function _onceWrap(target, type, listener) {\n    var state = {\n      fired: false,\n      wrapFn: undefined,\n      target: target,\n      type: type,\n      listener: listener\n    };\n    var wrapped = onceWrapper.bind(state);\n    wrapped.listener = listener;\n    state.wrapFn = wrapped;\n    return wrapped;\n  }\n  EventEmitter.prototype.once = function once(type, listener) {\n    checkListener(listener);\n    this.on(type, _onceWrap(this, type, listener));\n    return this;\n  };\n  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n    checkListener(listener);\n    this.prependListener(type, _onceWrap(this, type, listener));\n    return this;\n  };\n\n  // Emits a 'removeListener' event if and only if the listener was removed.\n  EventEmitter.prototype.removeListener = function removeListener(type, listener) {\n    var list, events, position, i, originalListener;\n    checkListener(listener);\n    events = this._events;\n    if (events === undefined) return this;\n    list = events[type];\n    if (list === undefined) return this;\n    if (list === listener || list.listener === listener) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else {\n        delete events[type];\n        if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n      }\n    } else if (typeof list !== 'function') {\n      position = -1;\n      for (i = list.length - 1; i >= 0; i--) {\n        if (list[i] === listener || list[i].listener === listener) {\n          originalListener = list[i].listener;\n          position = i;\n          break;\n        }\n      }\n      if (position < 0) return this;\n      if (position === 0) list.shift();else {\n        spliceOne(list, position);\n      }\n      if (list.length === 1) events[type] = list[0];\n      if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n    }\n    return this;\n  };\n  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n    var listeners, events, i;\n    events = this._events;\n    if (events === undefined) return this;\n\n    // not listening for removeListener, no need to emit\n    if (events.removeListener === undefined) {\n      if (arguments.length === 0) {\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n      } else if (events[type] !== undefined) {\n        if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n      }\n      return this;\n    }\n\n    // emit removeListener for all listeners on all events\n    if (arguments.length === 0) {\n      var keys = Object.keys(events);\n      var key;\n      for (i = 0; i < keys.length; ++i) {\n        key = keys[i];\n        if (key === 'removeListener') continue;\n        this.removeAllListeners(key);\n      }\n      this.removeAllListeners('removeListener');\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n      return this;\n    }\n    listeners = events[type];\n    if (typeof listeners === 'function') {\n      this.removeListener(type, listeners);\n    } else if (listeners !== undefined) {\n      // LIFO order\n      for (i = listeners.length - 1; i >= 0; i--) {\n        this.removeListener(type, listeners[i]);\n      }\n    }\n    return this;\n  };\n  function _listeners(target, type, unwrap) {\n    var events = target._events;\n    if (events === undefined) return [];\n    var evlistener = events[type];\n    if (evlistener === undefined) return [];\n    if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n  }\n  EventEmitter.prototype.listeners = function listeners(type) {\n    return _listeners(this, type, true);\n  };\n  EventEmitter.prototype.rawListeners = function rawListeners(type) {\n    return _listeners(this, type, false);\n  };\n  EventEmitter.listenerCount = function (emitter, type) {\n    if (typeof emitter.listenerCount === 'function') {\n      return emitter.listenerCount(type);\n    } else {\n      return listenerCount.call(emitter, type);\n    }\n  };\n  EventEmitter.prototype.listenerCount = listenerCount;\n  function listenerCount(type) {\n    var events = this._events;\n    if (events !== undefined) {\n      var evlistener = events[type];\n      if (typeof evlistener === 'function') {\n        return 1;\n      } else if (evlistener !== undefined) {\n        return evlistener.length;\n      }\n    }\n    return 0;\n  }\n  EventEmitter.prototype.eventNames = function eventNames() {\n    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n  };\n  function arrayClone(arr, n) {\n    var copy = new Array(n);\n    for (var i = 0; i < n; ++i) copy[i] = arr[i];\n    return copy;\n  }\n  function spliceOne(list, index) {\n    for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n    list.pop();\n  }\n  function unwrapListeners(arr) {\n    var ret = new Array(arr.length);\n    for (var i = 0; i < ret.length; ++i) {\n      ret[i] = arr[i].listener || arr[i];\n    }\n    return ret;\n  }\n  function once(emitter, name) {\n    return new Promise(function (resolve, reject) {\n      function errorListener(err) {\n        emitter.removeListener(name, resolver);\n        reject(err);\n      }\n      function resolver() {\n        if (typeof emitter.removeListener === 'function') {\n          emitter.removeListener('error', errorListener);\n        }\n        resolve([].slice.call(arguments));\n      }\n      eventTargetAgnosticAddListener(emitter, name, resolver, {\n        once: true\n      });\n      if (name !== 'error') {\n        addErrorHandlerIfEventEmitter(emitter, errorListener, {\n          once: true\n        });\n      }\n    });\n  }\n  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n    if (typeof emitter.on === 'function') {\n      eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n    }\n  }\n  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n    if (typeof emitter.on === 'function') {\n      if (flags.once) {\n        emitter.once(name, listener);\n      } else {\n        emitter.on(name, listener);\n      }\n    } else if (typeof emitter.addEventListener === 'function') {\n      // EventTarget does not have `error` event semantics like Node\n      // EventEmitters, we do not listen for `error` events here.\n      emitter.addEventListener(name, function wrapListener(arg) {\n        // IE does not have builtin `{ once: true }` support so we\n        // have to do it manually.\n        if (flags.once) {\n          emitter.removeEventListener(name, wrapListener);\n        }\n        listener(arg);\n      });\n    } else {\n      throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n    }\n  }\n  return events.exports;\n}\n\nvar eventsExports = requireEvents();\n\n/**\n * Events are the primary way LiveKit notifies your application of changes.\n *\n * The following are events emitted by [[Room]], listen to room events like\n *\n * ```typescript\n * room.on(RoomEvent.TrackPublished, (track, publication, participant) => {})\n * ```\n */\nvar RoomEvent;\n(function (RoomEvent) {\n  /**\n   * When the connection to the server has been established\n   */\n  RoomEvent[\"Connected\"] = \"connected\";\n  /**\n   * When the connection to the server has been interrupted and it's attempting\n   * to reconnect.\n   */\n  RoomEvent[\"Reconnecting\"] = \"reconnecting\";\n  /**\n   * When the signal connection to the server has been interrupted. This isn't noticeable to users most of the time.\n   * It will resolve with a `RoomEvent.Reconnected` once the signal connection has been re-established.\n   * If media fails additionally it an additional `RoomEvent.Reconnecting` will be emitted.\n   */\n  RoomEvent[\"SignalReconnecting\"] = \"signalReconnecting\";\n  /**\n   * Fires when a reconnection has been successful.\n   */\n  RoomEvent[\"Reconnected\"] = \"reconnected\";\n  /**\n   * When disconnected from room. This fires when room.disconnect() is called or\n   * when an unrecoverable connection issue had occured.\n   *\n   * DisconnectReason can be used to determine why the participant was disconnected. Notable reasons are\n   * - DUPLICATE_IDENTITY: another client with the same identity has joined the room\n   * - PARTICIPANT_REMOVED: participant was removed by RemoveParticipant API\n   * - ROOM_DELETED: the room has ended via DeleteRoom API\n   *\n   * args: ([[DisconnectReason]])\n   */\n  RoomEvent[\"Disconnected\"] = \"disconnected\";\n  /**\n   * Whenever the connection state of the room changes\n   *\n   * args: ([[ConnectionState]])\n   */\n  RoomEvent[\"ConnectionStateChanged\"] = \"connectionStateChanged\";\n  /**\n   * When input or output devices on the machine have changed.\n   */\n  RoomEvent[\"MediaDevicesChanged\"] = \"mediaDevicesChanged\";\n  /**\n   * When a [[RemoteParticipant]] joins *after* the local\n   * participant. It will not emit events for participants that are already\n   * in the room\n   *\n   * args: ([[RemoteParticipant]])\n   */\n  RoomEvent[\"ParticipantConnected\"] = \"participantConnected\";\n  /**\n   * When a [[RemoteParticipant]] leaves *after* the local\n   * participant has joined.\n   *\n   * args: ([[RemoteParticipant]])\n   */\n  RoomEvent[\"ParticipantDisconnected\"] = \"participantDisconnected\";\n  /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackPublished\"] = \"trackPublished\";\n  /**\n   * The [[LocalParticipant]] has subscribed to a new track. This event will **always**\n   * fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n  /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid, [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n  /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n  /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[Track]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n  /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */\n  RoomEvent[\"TrackMuted\"] = \"trackMuted\";\n  /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */\n  RoomEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n  /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */\n  RoomEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n  /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */\n  RoomEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n  /**\n   * When a local audio track is published the SDK checks whether there is complete silence\n   * on that track and emits the LocalAudioSilenceDetected event in that case.\n   * This allows for applications to show UI informing users that they might have to\n   * reset their audio hardware or check for proper device connectivity.\n   */\n  RoomEvent[\"LocalAudioSilenceDetected\"] = \"localAudioSilenceDetected\";\n  /**\n   * Active speakers changed. List of speakers are ordered by their audio level.\n   * loudest speakers first. This will include the LocalParticipant too.\n   *\n   * Speaker updates are sent only to the publishing participant and their subscribers.\n   *\n   * args: (Array<[[Participant]]>)\n   */\n  RoomEvent[\"ActiveSpeakersChanged\"] = \"activeSpeakersChanged\";\n  /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   *\n   * args: (prevMetadata: string, [[Participant]])\n   *\n   */\n  RoomEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n  /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */\n  RoomEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n  /**\n   * Participant attributes is an app-specific key value state to be pushed to\n   * all users.\n   * When a participant's attributes changed, this event will be emitted with the changed attributes and the participant\n   * args: (changedAttributes: [[Record<string, string]], participant: [[Participant]])\n   */\n  RoomEvent[\"ParticipantAttributesChanged\"] = \"participantAttributesChanged\";\n  /**\n   * Room metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateRoomMetadata is called to change a room's state,\n   * *all*  participants in the room will fire this event.\n   *\n   * args: (string)\n   */\n  RoomEvent[\"RoomMetadataChanged\"] = \"roomMetadataChanged\";\n  /**\n   * Data received from another participant.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, participant: [[Participant]], kind: [[DataPacket_Kind]], topic?: string)\n   */\n  RoomEvent[\"DataReceived\"] = \"dataReceived\";\n  /**\n   * SIP DTMF tones received from another participant.\n   *\n   * args: (participant: [[Participant]], dtmf: [[DataPacket_Kind]])\n   */\n  RoomEvent[\"SipDTMFReceived\"] = \"sipDTMFReceived\";\n  /**\n   * Transcription received from a participant's track.\n   * @beta\n   */\n  RoomEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n  /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]], participant: [[Participant]])\n   */\n  RoomEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n  /**\n   * StreamState indicates if a subscribed (remote) track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]],\n   *        participant: [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n  /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.PermissionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n  /**\n   * One of subscribed tracks have changed its status for the current\n   * participant.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */\n  RoomEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n  /**\n   * LiveKit will attempt to autoplay all audio tracks when you attach them to\n   * audio elements. However, if that fails, we'll notify you via AudioPlaybackStatusChanged.\n   * `Room.canPlaybackAudio` will indicate if audio playback is permitted.\n   */\n  RoomEvent[\"AudioPlaybackStatusChanged\"] = \"audioPlaybackChanged\";\n  /**\n   * LiveKit will attempt to autoplay all video tracks when you attach them to\n   * a video element. However, if that fails, we'll notify you via VideoPlaybackStatusChanged.\n   * Calling `room.startVideo()` in a user gesture event handler will resume the video playback.\n   */\n  RoomEvent[\"VideoPlaybackStatusChanged\"] = \"videoPlaybackChanged\";\n  /**\n   * When we have encountered an error while attempting to create a track.\n   * The errors take place in getUserMedia().\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\n   * [[LocalParticipant.lastCameraError]] and [[LocalParticipant.lastMicrophoneError]]\n   * will indicate if it had an error while creating the audio or video track respectively.\n   *\n   * args: (error: Error)\n   */\n  RoomEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n  /**\n   * A participant's permission has changed.\n   * args: (prevPermissions: [[ParticipantPermission]], participant: [[Participant]])\n   */\n  RoomEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n  /**\n   * Signal connected, can publish tracks.\n   */\n  RoomEvent[\"SignalConnected\"] = \"signalConnected\";\n  /**\n   * Recording of a room has started/stopped. Room.isRecording will be updated too.\n   * args: (isRecording: boolean)\n   */\n  RoomEvent[\"RecordingStatusChanged\"] = \"recordingStatusChanged\";\n  RoomEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n  RoomEvent[\"EncryptionError\"] = \"encryptionError\";\n  /**\n   * Emits whenever the current buffer status of a data channel changes\n   * args: (isLow: boolean, kind: [[DataPacket_Kind]])\n   */\n  RoomEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n  /**\n   * Triggered by a call to room.switchActiveDevice\n   * args: (kind: MediaDeviceKind, deviceId: string)\n   */\n  RoomEvent[\"ActiveDeviceChanged\"] = \"activeDeviceChanged\";\n  RoomEvent[\"ChatMessage\"] = \"chatMessage\";\n  /**\n   * fired when the first remote participant has subscribed to the localParticipant's track\n   */\n  RoomEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n  /**\n   * fired when the client receives connection metrics from other participants\n   */\n  RoomEvent[\"MetricsReceived\"] = \"metricsReceived\";\n})(RoomEvent || (RoomEvent = {}));\nvar ParticipantEvent;\n(function (ParticipantEvent) {\n  /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]])\n   */\n  ParticipantEvent[\"TrackPublished\"] = \"trackPublished\";\n  /**\n   * Successfully subscribed to the [[RemoteParticipant]]'s track.\n   * This event will **always** fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */\n  ParticipantEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n  /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid)\n   */\n  ParticipantEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n  /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]])\n   */\n  ParticipantEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n  /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */\n  ParticipantEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n  /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */\n  ParticipantEvent[\"TrackMuted\"] = \"trackMuted\";\n  /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */\n  ParticipantEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n  /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]])\n   */\n  ParticipantEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n  /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]])\n   */\n  ParticipantEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n  /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   * To access the current metadata, see [[Participant.metadata]].\n   *\n   * args: (prevMetadata: string)\n   *\n   */\n  ParticipantEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n  /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */\n  ParticipantEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n  /**\n   * Data received from this participant as sender.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, kind: [[DataPacket_Kind]])\n   */\n  ParticipantEvent[\"DataReceived\"] = \"dataReceived\";\n  /**\n   * SIP DTMF tones received from this participant as sender.\n   *\n   * args: (dtmf: [[DataPacket_Kind]])\n   */\n  ParticipantEvent[\"SipDTMFReceived\"] = \"sipDTMFReceived\";\n  /**\n   * Transcription received from this participant as data source.\n   * @beta\n   */\n  ParticipantEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n  /**\n   * Has speaking status changed for the current participant\n   *\n   * args: (speaking: boolean)\n   */\n  ParticipantEvent[\"IsSpeakingChanged\"] = \"isSpeakingChanged\";\n  /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]])\n   */\n  ParticipantEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n  /**\n   * StreamState indicates if a subscribed track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]])\n   */\n  ParticipantEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n  /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]])\n   */\n  ParticipantEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n  /**\n   * One of the remote participants publications has changed its subscription status.\n   *\n   */\n  ParticipantEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n  // fired only on LocalParticipant\n  /** @internal */\n  ParticipantEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n  // fired only on LocalParticipant\n  /** @internal */\n  ParticipantEvent[\"AudioStreamAcquired\"] = \"audioStreamAcquired\";\n  /**\n   * A participant's permission has changed.\n   * args: (prevPermissions: [[ParticipantPermission]])\n   */\n  ParticipantEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n  /** @internal */\n  ParticipantEvent[\"PCTrackAdded\"] = \"pcTrackAdded\";\n  /**\n   * Participant attributes is an app-specific key value state to be pushed to\n   * all users.\n   * When a participant's attributes changed, this event will be emitted with the changed attributes\n   * args: (changedAttributes: [[Record<string, string]])\n   */\n  ParticipantEvent[\"AttributesChanged\"] = \"attributesChanged\";\n  /**\n   * fired on local participant only, when the first remote participant has subscribed to the track specified in the payload\n   */\n  ParticipantEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n  /** only emitted on local participant */\n  ParticipantEvent[\"ChatMessage\"] = \"chatMessage\";\n})(ParticipantEvent || (ParticipantEvent = {}));\n/** @internal */\nvar EngineEvent;\n(function (EngineEvent) {\n  EngineEvent[\"TransportsCreated\"] = \"transportsCreated\";\n  EngineEvent[\"Connected\"] = \"connected\";\n  EngineEvent[\"Disconnected\"] = \"disconnected\";\n  EngineEvent[\"Resuming\"] = \"resuming\";\n  EngineEvent[\"Resumed\"] = \"resumed\";\n  EngineEvent[\"Restarting\"] = \"restarting\";\n  EngineEvent[\"Restarted\"] = \"restarted\";\n  EngineEvent[\"SignalResumed\"] = \"signalResumed\";\n  EngineEvent[\"SignalRestarted\"] = \"signalRestarted\";\n  EngineEvent[\"Closing\"] = \"closing\";\n  EngineEvent[\"MediaTrackAdded\"] = \"mediaTrackAdded\";\n  EngineEvent[\"ActiveSpeakersUpdate\"] = \"activeSpeakersUpdate\";\n  EngineEvent[\"DataPacketReceived\"] = \"dataPacketReceived\";\n  EngineEvent[\"RTPVideoMapUpdate\"] = \"rtpVideoMapUpdate\";\n  EngineEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n  EngineEvent[\"ParticipantUpdate\"] = \"participantUpdate\";\n  EngineEvent[\"RoomUpdate\"] = \"roomUpdate\";\n  EngineEvent[\"SpeakersChanged\"] = \"speakersChanged\";\n  EngineEvent[\"StreamStateChanged\"] = \"streamStateChanged\";\n  EngineEvent[\"ConnectionQualityUpdate\"] = \"connectionQualityUpdate\";\n  EngineEvent[\"SubscriptionError\"] = \"subscriptionError\";\n  EngineEvent[\"SubscriptionPermissionUpdate\"] = \"subscriptionPermissionUpdate\";\n  EngineEvent[\"RemoteMute\"] = \"remoteMute\";\n  EngineEvent[\"SubscribedQualityUpdate\"] = \"subscribedQualityUpdate\";\n  EngineEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n  EngineEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n  EngineEvent[\"Offline\"] = \"offline\";\n  EngineEvent[\"SignalRequestResponse\"] = \"signalRequestResponse\";\n})(EngineEvent || (EngineEvent = {}));\nvar TrackEvent;\n(function (TrackEvent) {\n  TrackEvent[\"Message\"] = \"message\";\n  TrackEvent[\"Muted\"] = \"muted\";\n  TrackEvent[\"Unmuted\"] = \"unmuted\";\n  /**\n   * Only fires on LocalTracks\n   */\n  TrackEvent[\"Restarted\"] = \"restarted\";\n  TrackEvent[\"Ended\"] = \"ended\";\n  TrackEvent[\"Subscribed\"] = \"subscribed\";\n  TrackEvent[\"Unsubscribed\"] = \"unsubscribed\";\n  /** @internal */\n  TrackEvent[\"UpdateSettings\"] = \"updateSettings\";\n  /** @internal */\n  TrackEvent[\"UpdateSubscription\"] = \"updateSubscription\";\n  /** @internal */\n  TrackEvent[\"AudioPlaybackStarted\"] = \"audioPlaybackStarted\";\n  /** @internal */\n  TrackEvent[\"AudioPlaybackFailed\"] = \"audioPlaybackFailed\";\n  /**\n   * @internal\n   * Only fires on LocalAudioTrack instances\n   */\n  TrackEvent[\"AudioSilenceDetected\"] = \"audioSilenceDetected\";\n  /** @internal */\n  TrackEvent[\"VisibilityChanged\"] = \"visibilityChanged\";\n  /** @internal */\n  TrackEvent[\"VideoDimensionsChanged\"] = \"videoDimensionsChanged\";\n  /** @internal */\n  TrackEvent[\"VideoPlaybackStarted\"] = \"videoPlaybackStarted\";\n  /** @internal */\n  TrackEvent[\"VideoPlaybackFailed\"] = \"videoPlaybackFailed\";\n  /** @internal */\n  TrackEvent[\"ElementAttached\"] = \"elementAttached\";\n  /** @internal */\n  TrackEvent[\"ElementDetached\"] = \"elementDetached\";\n  /**\n   * @internal\n   * Only fires on LocalTracks\n   */\n  TrackEvent[\"UpstreamPaused\"] = \"upstreamPaused\";\n  /**\n   * @internal\n   * Only fires on LocalTracks\n   */\n  TrackEvent[\"UpstreamResumed\"] = \"upstreamResumed\";\n  /**\n   * @internal\n   * Fires on RemoteTrackPublication\n   */\n  TrackEvent[\"SubscriptionPermissionChanged\"] = \"subscriptionPermissionChanged\";\n  /**\n   * Fires on RemoteTrackPublication\n   */\n  TrackEvent[\"SubscriptionStatusChanged\"] = \"subscriptionStatusChanged\";\n  /**\n   * Fires on RemoteTrackPublication\n   */\n  TrackEvent[\"SubscriptionFailed\"] = \"subscriptionFailed\";\n  /**\n   * @internal\n   */\n  TrackEvent[\"TrackProcessorUpdate\"] = \"trackProcessorUpdate\";\n  /**\n   * @internal\n   */\n  TrackEvent[\"AudioTrackFeatureUpdate\"] = \"audioTrackFeatureUpdate\";\n  /**\n   * @beta\n   */\n  TrackEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n  /**\n   * @experimental\n   */\n  TrackEvent[\"TimeSyncUpdate\"] = \"timeSyncUpdate\";\n})(TrackEvent || (TrackEvent = {}));\n\nconst BACKGROUND_REACTION_DELAY = 5000;\n// keep old audio elements when detached, we would re-use them since on iOS\n// Safari tracks which audio elements have been \"blessed\" by the user.\nconst recycledElements = [];\nvar VideoQuality;\n(function (VideoQuality) {\n  VideoQuality[VideoQuality[\"LOW\"] = 0] = \"LOW\";\n  VideoQuality[VideoQuality[\"MEDIUM\"] = 1] = \"MEDIUM\";\n  VideoQuality[VideoQuality[\"HIGH\"] = 2] = \"HIGH\";\n})(VideoQuality || (VideoQuality = {}));\nclass Track extends eventsExports.EventEmitter {\n  constructor(mediaTrack, kind) {\n    let loggerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _a;\n    super();\n    this.attachedElements = [];\n    this.isMuted = false;\n    /**\n     * indicates current state of stream, it'll indicate `paused` if the track\n     * has been paused by congestion controller\n     */\n    this.streamState = Track.StreamState.Active;\n    this.isInBackground = false;\n    this._currentBitrate = 0;\n    this.log = livekitLogger;\n    this.appVisibilityChangedListener = () => {\n      if (this.backgroundTimeout) {\n        clearTimeout(this.backgroundTimeout);\n      }\n      // delay app visibility update if it goes to hidden\n      // update immediately if it comes back to focus\n      if (document.visibilityState === 'hidden') {\n        this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);\n      } else {\n        this.handleAppVisibilityChanged();\n      }\n    };\n    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Track);\n    this.loggerContextCb = loggerOptions.loggerContextCb;\n    this.setMaxListeners(100);\n    this.kind = kind;\n    this._mediaStreamTrack = mediaTrack;\n    this._mediaStreamID = mediaTrack.id;\n    this.source = Track.Source.Unknown;\n  }\n  get logContext() {\n    var _a;\n    return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n  }\n  /** current receive bits per second */\n  get currentBitrate() {\n    return this._currentBitrate;\n  }\n  get mediaStreamTrack() {\n    return this._mediaStreamTrack;\n  }\n  /**\n   * @internal\n   * used for keep mediaStream's first id, since it's id might change\n   * if we disable/enable a track\n   */\n  get mediaStreamID() {\n    return this._mediaStreamID;\n  }\n  attach(element) {\n    let elementType = 'audio';\n    if (this.kind === Track.Kind.Video) {\n      elementType = 'video';\n    }\n    if (this.attachedElements.length === 0 && this.kind === Track.Kind.Video) {\n      this.addAppVisibilityListener();\n    }\n    if (!element) {\n      if (elementType === 'audio') {\n        recycledElements.forEach(e => {\n          if (e.parentElement === null && !element) {\n            element = e;\n          }\n        });\n        if (element) {\n          // remove it from pool\n          recycledElements.splice(recycledElements.indexOf(element), 1);\n        }\n      }\n      if (!element) {\n        element = document.createElement(elementType);\n      }\n    }\n    if (!this.attachedElements.includes(element)) {\n      this.attachedElements.push(element);\n    }\n    // even if we believe it's already attached to the element, it's possible\n    // the element's srcObject was set to something else out of band.\n    // we'll want to re-attach it in that case\n    attachToElement(this.mediaStreamTrack, element);\n    // handle auto playback failures\n    const allMediaStreamTracks = element.srcObject.getTracks();\n    const hasAudio = allMediaStreamTracks.some(tr => tr.kind === 'audio');\n    // manually play media to detect auto playback status\n    element.play().then(() => {\n      this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);\n    }).catch(e => {\n      if (e.name === 'NotAllowedError') {\n        this.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e);\n      } else if (e.name === 'AbortError') {\n        // commonly triggered by another `play` request, only log for debugging purposes\n        livekitLogger.debug(\"\".concat(hasAudio ? 'audio' : 'video', \" playback aborted, likely due to new play request\"));\n      } else {\n        livekitLogger.warn(\"could not playback \".concat(hasAudio ? 'audio' : 'video'), e);\n      }\n      // If audio playback isn't allowed make sure we still play back the video\n      if (hasAudio && element && allMediaStreamTracks.some(tr => tr.kind === 'video') && e.name === 'NotAllowedError') {\n        element.muted = true;\n        element.play().catch(() => {\n          // catch for Safari, exceeded options at this point to automatically play the media element\n        });\n      }\n    });\n    this.emit(TrackEvent.ElementAttached, element);\n    return element;\n  }\n  detach(element) {\n    try {\n      // detach from a single element\n      if (element) {\n        detachTrack(this.mediaStreamTrack, element);\n        const idx = this.attachedElements.indexOf(element);\n        if (idx >= 0) {\n          this.attachedElements.splice(idx, 1);\n          this.recycleElement(element);\n          this.emit(TrackEvent.ElementDetached, element);\n        }\n        return element;\n      }\n      const detached = [];\n      this.attachedElements.forEach(elm => {\n        detachTrack(this.mediaStreamTrack, elm);\n        detached.push(elm);\n        this.recycleElement(elm);\n        this.emit(TrackEvent.ElementDetached, elm);\n      });\n      // remove all tracks\n      this.attachedElements = [];\n      return detached;\n    } finally {\n      if (this.attachedElements.length === 0) {\n        this.removeAppVisibilityListener();\n      }\n    }\n  }\n  stop() {\n    this.stopMonitor();\n    this._mediaStreamTrack.stop();\n  }\n  enable() {\n    this._mediaStreamTrack.enabled = true;\n  }\n  disable() {\n    this._mediaStreamTrack.enabled = false;\n  }\n  /* @internal */\n  stopMonitor() {\n    if (this.monitorInterval) {\n      clearInterval(this.monitorInterval);\n    }\n    if (this.timeSyncHandle) {\n      cancelAnimationFrame(this.timeSyncHandle);\n    }\n  }\n  /** @internal */\n  updateLoggerOptions(loggerOptions) {\n    if (loggerOptions.loggerName) {\n      this.log = getLogger(loggerOptions.loggerName);\n    }\n    if (loggerOptions.loggerContextCb) {\n      this.loggerContextCb = loggerOptions.loggerContextCb;\n    }\n  }\n  recycleElement(element) {\n    if (element instanceof HTMLAudioElement) {\n      // we only need to re-use a single element\n      let shouldCache = true;\n      element.pause();\n      recycledElements.forEach(e => {\n        if (!e.parentElement) {\n          shouldCache = false;\n        }\n      });\n      if (shouldCache) {\n        recycledElements.push(element);\n      }\n    }\n  }\n  handleAppVisibilityChanged() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.isInBackground = document.visibilityState === 'hidden';\n      if (!this.isInBackground && this.kind === Track.Kind.Video) {\n        setTimeout(() => this.attachedElements.forEach(el => el.play().catch(() => {\n          /** catch clause necessary for Safari */\n        })), 0);\n      }\n    });\n  }\n  addAppVisibilityListener() {\n    if (isWeb()) {\n      this.isInBackground = document.visibilityState === 'hidden';\n      document.addEventListener('visibilitychange', this.appVisibilityChangedListener);\n    } else {\n      this.isInBackground = false;\n    }\n  }\n  removeAppVisibilityListener() {\n    if (isWeb()) {\n      document.removeEventListener('visibilitychange', this.appVisibilityChangedListener);\n    }\n  }\n}\nfunction attachToElement(track, element) {\n  let mediaStream;\n  if (element.srcObject instanceof MediaStream) {\n    mediaStream = element.srcObject;\n  } else {\n    mediaStream = new MediaStream();\n  }\n  // check if track matches existing track\n  let existingTracks;\n  if (track.kind === 'audio') {\n    existingTracks = mediaStream.getAudioTracks();\n  } else {\n    existingTracks = mediaStream.getVideoTracks();\n  }\n  if (!existingTracks.includes(track)) {\n    existingTracks.forEach(et => {\n      mediaStream.removeTrack(et);\n    });\n    mediaStream.addTrack(track);\n  }\n  if (!isSafari() || !(element instanceof HTMLVideoElement)) {\n    // when in low power mode (applies to both macOS and iOS), Safari will show a play/pause overlay\n    // when a video starts that has the `autoplay` attribute is set.\n    // we work around this by _not_ setting the autoplay attribute on safari and instead call `setTimeout(() => el.play(),0)` further down\n    element.autoplay = true;\n  }\n  // In case there are no audio tracks present on the mediastream, we set the element as muted to ensure autoplay works\n  element.muted = mediaStream.getAudioTracks().length === 0;\n  if (element instanceof HTMLVideoElement) {\n    element.playsInline = true;\n  }\n  // avoid flicker\n  if (element.srcObject !== mediaStream) {\n    element.srcObject = mediaStream;\n    if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {\n      // Firefox also has a timing issue where video doesn't actually get attached unless\n      // performed out-of-band\n      // Safari 15 has a bug where in certain layouts, video element renders\n      // black until the page is resized or other changes take place.\n      // Resetting the src triggers it to render.\n      // https://developer.apple.com/forums/thread/690523\n      setTimeout(() => {\n        element.srcObject = mediaStream;\n        // Safari 15 sometimes fails to start a video\n        // when the window is backgrounded before the first frame is drawn\n        // manually calling play here seems to fix that\n        element.play().catch(() => {\n          /** do nothing */\n        });\n      }, 0);\n    }\n  }\n}\n/** @internal */\nfunction detachTrack(track, element) {\n  if (element.srcObject instanceof MediaStream) {\n    const mediaStream = element.srcObject;\n    mediaStream.removeTrack(track);\n    if (mediaStream.getTracks().length > 0) {\n      element.srcObject = mediaStream;\n    } else {\n      element.srcObject = null;\n    }\n  }\n}\n(function (Track) {\n  let Kind;\n  (function (Kind) {\n    Kind[\"Audio\"] = \"audio\";\n    Kind[\"Video\"] = \"video\";\n    Kind[\"Unknown\"] = \"unknown\";\n  })(Kind = Track.Kind || (Track.Kind = {}));\n  let Source;\n  (function (Source) {\n    Source[\"Camera\"] = \"camera\";\n    Source[\"Microphone\"] = \"microphone\";\n    Source[\"ScreenShare\"] = \"screen_share\";\n    Source[\"ScreenShareAudio\"] = \"screen_share_audio\";\n    Source[\"Unknown\"] = \"unknown\";\n  })(Source = Track.Source || (Track.Source = {}));\n  let StreamState$1;\n  (function (StreamState) {\n    StreamState[\"Active\"] = \"active\";\n    StreamState[\"Paused\"] = \"paused\";\n    StreamState[\"Unknown\"] = \"unknown\";\n  })(StreamState$1 = Track.StreamState || (Track.StreamState = {}));\n  /** @internal */\n  function kindToProto(k) {\n    switch (k) {\n      case Kind.Audio:\n        return TrackType.AUDIO;\n      case Kind.Video:\n        return TrackType.VIDEO;\n      default:\n        // FIXME this was UNRECOGNIZED before\n        return TrackType.DATA;\n    }\n  }\n  Track.kindToProto = kindToProto;\n  /** @internal */\n  function kindFromProto(t) {\n    switch (t) {\n      case TrackType.AUDIO:\n        return Kind.Audio;\n      case TrackType.VIDEO:\n        return Kind.Video;\n      default:\n        return Kind.Unknown;\n    }\n  }\n  Track.kindFromProto = kindFromProto;\n  /** @internal */\n  function sourceToProto(s) {\n    switch (s) {\n      case Source.Camera:\n        return TrackSource.CAMERA;\n      case Source.Microphone:\n        return TrackSource.MICROPHONE;\n      case Source.ScreenShare:\n        return TrackSource.SCREEN_SHARE;\n      case Source.ScreenShareAudio:\n        return TrackSource.SCREEN_SHARE_AUDIO;\n      default:\n        return TrackSource.UNKNOWN;\n    }\n  }\n  Track.sourceToProto = sourceToProto;\n  /** @internal */\n  function sourceFromProto(s) {\n    switch (s) {\n      case TrackSource.CAMERA:\n        return Source.Camera;\n      case TrackSource.MICROPHONE:\n        return Source.Microphone;\n      case TrackSource.SCREEN_SHARE:\n        return Source.ScreenShare;\n      case TrackSource.SCREEN_SHARE_AUDIO:\n        return Source.ScreenShareAudio;\n      default:\n        return Source.Unknown;\n    }\n  }\n  Track.sourceFromProto = sourceFromProto;\n  /** @internal */\n  function streamStateFromProto(s) {\n    switch (s) {\n      case StreamState.ACTIVE:\n        return StreamState$1.Active;\n      case StreamState.PAUSED:\n        return StreamState$1.Paused;\n      default:\n        return StreamState$1.Unknown;\n    }\n  }\n  Track.streamStateFromProto = streamStateFromProto;\n})(Track || (Track = {}));\n\nfunction getLogContextFromTrack(track) {\n  if (track instanceof Track) {\n    return {\n      trackID: track.sid,\n      source: track.source,\n      muted: track.isMuted,\n      enabled: track.mediaStreamTrack.enabled,\n      kind: track.kind,\n      streamID: track.mediaStreamID,\n      streamTrackID: track.mediaStreamTrack.id\n    };\n  } else {\n    return {\n      trackID: track.trackSid,\n      enabled: track.isEnabled,\n      muted: track.isMuted,\n      trackInfo: Object.assign({\n        mimeType: track.mimeType,\n        name: track.trackName,\n        encrypted: track.isEncrypted,\n        kind: track.kind,\n        source: track.source\n      }, track.track ? getLogContextFromTrack(track.track) : {})\n    };\n  }\n}\n\nfunction isFireFox() {\n  var _a;\n  return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Firefox';\n}\nfunction isSafari() {\n  var _a;\n  return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Safari';\n}\nfunction isWeb() {\n  return typeof document !== 'undefined';\n}\n/**\n * @internal\n */\nclass Mutex {\n  constructor() {\n    this._locking = Promise.resolve();\n    this._locks = 0;\n  }\n  isLocked() {\n    return this._locks > 0;\n  }\n  lock() {\n    this._locks += 1;\n    let unlockNext;\n    const willLock = new Promise(resolve => unlockNext = () => {\n      this._locks -= 1;\n      resolve();\n    });\n    const willUnlock = this._locking.then(() => unlockNext);\n    this._locking = this._locking.then(() => willLock);\n    return willUnlock;\n  }\n}\n\nvar QueueTaskStatus;\n(function (QueueTaskStatus) {\n  QueueTaskStatus[QueueTaskStatus[\"WAITING\"] = 0] = \"WAITING\";\n  QueueTaskStatus[QueueTaskStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n  QueueTaskStatus[QueueTaskStatus[\"COMPLETED\"] = 2] = \"COMPLETED\";\n})(QueueTaskStatus || (QueueTaskStatus = {}));\nclass AsyncQueue {\n  constructor() {\n    this.pendingTasks = new Map();\n    this.taskMutex = new Mutex();\n    this.nextTaskIndex = 0;\n  }\n  run(task) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const taskInfo = {\n        id: this.nextTaskIndex++,\n        enqueuedAt: Date.now(),\n        status: QueueTaskStatus.WAITING\n      };\n      this.pendingTasks.set(taskInfo.id, taskInfo);\n      const unlock = yield this.taskMutex.lock();\n      try {\n        taskInfo.executedAt = Date.now();\n        taskInfo.status = QueueTaskStatus.RUNNING;\n        return yield task();\n      } finally {\n        taskInfo.status = QueueTaskStatus.COMPLETED;\n        this.pendingTasks.delete(taskInfo.id);\n        unlock();\n      }\n    });\n  }\n  flush() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.run(() => __awaiter(this, void 0, void 0, function* () {}));\n    });\n  }\n  snapshot() {\n    return Array.from(this.pendingTasks.values());\n  }\n}\n\nconst ENCRYPTION_ALGORITHM = 'AES-GCM';\n// How many consecutive frames can fail decrypting before a particular key gets marked as invalid\nconst DECRYPTION_FAILURE_TOLERANCE = 10;\n// We copy the first bytes of the VP8 payload unencrypted.\n// For keyframes this is 10 bytes, for non-keyframes (delta) 3. See\n//   https://tools.ietf.org/html/rfc6386#section-9.1\n// This allows the bridge to continue detecting keyframes (only one byte needed in the JVB)\n// and is also a bit easier for the VP8 decoder (i.e. it generates funny garbage pictures\n// instead of being unable to decode).\n// This is a bit for show and we might want to reduce to 1 unconditionally in the final version.\n//\n// For audio (where frame.type is not set) we do not encrypt the opus TOC byte:\n//   https://tools.ietf.org/html/rfc6716#section-3.1\nconst UNENCRYPTED_BYTES = {\n  key: 10,\n  delta: 3,\n  audio: 1,\n  // frame.type is not set on audio, so this is set manually\n  empty: 0\n};\n/* We use a 12 byte bit IV. This is signalled in plain together with the\n packet. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters */\nconst IV_LENGTH = 12;\nconst SALT = 'LKFrameEncryptionKey';\nconst KEY_PROVIDER_DEFAULTS = {\n  sharedKey: false,\n  ratchetSalt: SALT,\n  ratchetWindowSize: 8,\n  failureTolerance: DECRYPTION_FAILURE_TOLERANCE,\n  keyringSize: 16\n};\nconst MAX_SIF_COUNT = 100;\nconst MAX_SIF_DURATION = 2000;\n\nclass LivekitError extends Error {\n  constructor(code, message) {\n    super(message || 'an error has occured');\n    this.code = code;\n  }\n}\nvar ConnectionErrorReason;\n(function (ConnectionErrorReason) {\n  ConnectionErrorReason[ConnectionErrorReason[\"NotAllowed\"] = 0] = \"NotAllowed\";\n  ConnectionErrorReason[ConnectionErrorReason[\"ServerUnreachable\"] = 1] = \"ServerUnreachable\";\n  ConnectionErrorReason[ConnectionErrorReason[\"InternalError\"] = 2] = \"InternalError\";\n  ConnectionErrorReason[ConnectionErrorReason[\"Cancelled\"] = 3] = \"Cancelled\";\n  ConnectionErrorReason[ConnectionErrorReason[\"LeaveRequest\"] = 4] = \"LeaveRequest\";\n})(ConnectionErrorReason || (ConnectionErrorReason = {}));\nvar MediaDeviceFailure;\n(function (MediaDeviceFailure) {\n  // user rejected permissions\n  MediaDeviceFailure[\"PermissionDenied\"] = \"PermissionDenied\";\n  // device is not available\n  MediaDeviceFailure[\"NotFound\"] = \"NotFound\";\n  // device is in use. On Windows, only a single tab may get access to a device at a time.\n  MediaDeviceFailure[\"DeviceInUse\"] = \"DeviceInUse\";\n  MediaDeviceFailure[\"Other\"] = \"Other\";\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n(function (MediaDeviceFailure) {\n  function getFailure(error) {\n    if (error && 'name' in error) {\n      if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        return MediaDeviceFailure.NotFound;\n      }\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        return MediaDeviceFailure.PermissionDenied;\n      }\n      if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        return MediaDeviceFailure.DeviceInUse;\n      }\n      return MediaDeviceFailure.Other;\n    }\n  }\n  MediaDeviceFailure.getFailure = getFailure;\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n\nvar CryptorErrorReason;\n(function (CryptorErrorReason) {\n  CryptorErrorReason[CryptorErrorReason[\"InvalidKey\"] = 0] = \"InvalidKey\";\n  CryptorErrorReason[CryptorErrorReason[\"MissingKey\"] = 1] = \"MissingKey\";\n  CryptorErrorReason[CryptorErrorReason[\"InternalError\"] = 2] = \"InternalError\";\n})(CryptorErrorReason || (CryptorErrorReason = {}));\nclass CryptorError extends LivekitError {\n  constructor(message) {\n    let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CryptorErrorReason.InternalError;\n    let participantIdentity = arguments.length > 2 ? arguments[2] : undefined;\n    super(40, message);\n    this.reason = reason;\n    this.participantIdentity = participantIdentity;\n  }\n}\n\nvar KeyProviderEvent;\n(function (KeyProviderEvent) {\n  KeyProviderEvent[\"SetKey\"] = \"setKey\";\n  KeyProviderEvent[\"RatchetRequest\"] = \"ratchetRequest\";\n  KeyProviderEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyProviderEvent || (KeyProviderEvent = {}));\nvar KeyHandlerEvent;\n(function (KeyHandlerEvent) {\n  KeyHandlerEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyHandlerEvent || (KeyHandlerEvent = {}));\nvar EncryptionEvent;\n(function (EncryptionEvent) {\n  EncryptionEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n  EncryptionEvent[\"EncryptionError\"] = \"encryptionError\";\n})(EncryptionEvent || (EncryptionEvent = {}));\nvar CryptorEvent;\n(function (CryptorEvent) {\n  CryptorEvent[\"Error\"] = \"cryptorError\";\n})(CryptorEvent || (CryptorEvent = {}));\n\nfunction isVideoFrame(frame) {\n  return 'type' in frame;\n}\nfunction importKey(keyBytes_1) {\n  return __awaiter(this, arguments, void 0, function (keyBytes) {\n    let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      name: ENCRYPTION_ALGORITHM\n    };\n    let usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'encrypt';\n    return function* () {\n      // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\n      return crypto.subtle.importKey('raw', keyBytes, algorithm, false, usage === 'derive' ? ['deriveBits', 'deriveKey'] : ['encrypt', 'decrypt']);\n    }();\n  });\n}\nfunction getAlgoOptions(algorithmName, salt) {\n  const textEncoder = new TextEncoder();\n  const encodedSalt = textEncoder.encode(salt);\n  switch (algorithmName) {\n    case 'HKDF':\n      return {\n        name: 'HKDF',\n        salt: encodedSalt,\n        hash: 'SHA-256',\n        info: new ArrayBuffer(128)\n      };\n    case 'PBKDF2':\n      {\n        return {\n          name: 'PBKDF2',\n          salt: encodedSalt,\n          hash: 'SHA-256',\n          iterations: 100000\n        };\n      }\n    default:\n      throw new Error(\"algorithm \".concat(algorithmName, \" is currently unsupported\"));\n  }\n}\n/**\n * Derives a set of keys from the master key.\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\n */\nfunction deriveKeys(material, salt) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\n    // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\n    const encryptionKey = yield crypto.subtle.deriveKey(algorithmOptions, material, {\n      name: ENCRYPTION_ALGORITHM,\n      length: 128\n    }, false, ['encrypt', 'decrypt']);\n    return {\n      material,\n      encryptionKey\n    };\n  });\n}\n/**\n * Ratchets a key. See\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\n */\nfunction ratchet(material, salt) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\n    return crypto.subtle.deriveBits(algorithmOptions, material, 256);\n  });\n}\nfunction needsRbspUnescaping(frameData) {\n  for (var i = 0; i < frameData.length - 3; i++) {\n    if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;\n  }\n  return false;\n}\nfunction parseRbsp(stream) {\n  const dataOut = [];\n  var length = stream.length;\n  for (var i = 0; i < stream.length;) {\n    // Be careful about over/underflow here. byte_length_ - 3 can underflow, and\n    // i + 3 can overflow, but byte_length_ - i can't, because i < byte_length_\n    // above, and that expression will produce the number of bytes left in\n    // the stream including the byte at i.\n    if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {\n      // Two rbsp bytes.\n      dataOut.push(stream[i++]);\n      dataOut.push(stream[i++]);\n      // Skip the emulation byte.\n      i++;\n    } else {\n      // Single rbsp byte.\n      dataOut.push(stream[i++]);\n    }\n  }\n  return new Uint8Array(dataOut);\n}\nconst kZerosInStartSequence = 2;\nconst kEmulationByte = 3;\nfunction writeRbsp(data_in) {\n  const dataOut = [];\n  var numConsecutiveZeros = 0;\n  for (var i = 0; i < data_in.length; ++i) {\n    var byte = data_in[i];\n    if (byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {\n      // Need to escape.\n      dataOut.push(kEmulationByte);\n      numConsecutiveZeros = 0;\n    }\n    dataOut.push(byte);\n    if (byte == 0) {\n      ++numConsecutiveZeros;\n    } else {\n      numConsecutiveZeros = 0;\n    }\n  }\n  return new Uint8Array(dataOut);\n}\n\nclass SifGuard {\n  constructor() {\n    this.consecutiveSifCount = 0;\n    this.lastSifReceivedAt = 0;\n    this.userFramesSinceSif = 0;\n  }\n  recordSif() {\n    var _a;\n    this.consecutiveSifCount += 1;\n    (_a = this.sifSequenceStartedAt) !== null && _a !== void 0 ? _a : this.sifSequenceStartedAt = Date.now();\n    this.lastSifReceivedAt = Date.now();\n  }\n  recordUserFrame() {\n    if (this.sifSequenceStartedAt === undefined) {\n      return;\n    } else {\n      this.userFramesSinceSif += 1;\n    }\n    if (\n    // reset if we received more user frames than SIFs\n    this.userFramesSinceSif > this.consecutiveSifCount ||\n    // also reset if we got a new user frame and the latest SIF frame hasn't been updated in a while\n    Date.now() - this.lastSifReceivedAt > MAX_SIF_DURATION) {\n      this.reset();\n    }\n  }\n  isSifAllowed() {\n    return this.consecutiveSifCount < MAX_SIF_COUNT && (this.sifSequenceStartedAt === undefined || Date.now() - this.sifSequenceStartedAt < MAX_SIF_DURATION);\n  }\n  reset() {\n    this.userFramesSinceSif = 0;\n    this.consecutiveSifCount = 0;\n    this.sifSequenceStartedAt = undefined;\n  }\n}\n\nconst encryptionEnabledMap = new Map();\nclass BaseFrameCryptor extends eventsExports.EventEmitter {\n  encodeFunction(encodedFrame, controller) {\n    throw Error('not implemented for subclass');\n  }\n  decodeFunction(encodedFrame, controller) {\n    throw Error('not implemented for subclass');\n  }\n}\n/**\n * Cryptor is responsible for en-/decrypting media frames.\n * Each Cryptor instance is responsible for en-/decrypting a single mediaStreamTrack.\n */\nclass FrameCryptor extends BaseFrameCryptor {\n  constructor(opts) {\n    var _a;\n    super();\n    this.sendCounts = new Map();\n    this.keys = opts.keys;\n    this.participantIdentity = opts.participantIdentity;\n    this.rtpMap = new Map();\n    this.keyProviderOptions = opts.keyProviderOptions;\n    this.sifTrailer = (_a = opts.sifTrailer) !== null && _a !== void 0 ? _a : Uint8Array.from([]);\n    this.sifGuard = new SifGuard();\n  }\n  get logContext() {\n    return {\n      participant: this.participantIdentity,\n      mediaTrackId: this.trackId,\n      fallbackCodec: this.videoCodec\n    };\n  }\n  /**\n   * Assign a different participant to the cryptor.\n   * useful for transceiver re-use\n   * @param id\n   * @param keys\n   */\n  setParticipant(id, keys) {\n    workerLogger.debug('setting new participant on cryptor', Object.assign(Object.assign({}, this.logContext), {\n      participant: id\n    }));\n    if (this.participantIdentity) {\n      workerLogger.error('cryptor has already a participant set, participant should have been unset before', Object.assign({}, this.logContext));\n    }\n    this.participantIdentity = id;\n    this.keys = keys;\n    this.sifGuard.reset();\n  }\n  unsetParticipant() {\n    workerLogger.debug('unsetting participant', this.logContext);\n    this.participantIdentity = undefined;\n  }\n  isEnabled() {\n    if (this.participantIdentity) {\n      return encryptionEnabledMap.get(this.participantIdentity);\n    } else {\n      return undefined;\n    }\n  }\n  getParticipantIdentity() {\n    return this.participantIdentity;\n  }\n  getTrackId() {\n    return this.trackId;\n  }\n  /**\n   * Update the video codec used by the mediaStreamTrack\n   * @param codec\n   */\n  setVideoCodec(codec) {\n    this.videoCodec = codec;\n  }\n  /**\n   * rtp payload type map used for figuring out codec of payload type when encoding\n   * @param map\n   */\n  setRtpMap(map) {\n    this.rtpMap = map;\n  }\n  setupTransform(operation, readable, writable, trackId, codec) {\n    if (codec) {\n      workerLogger.info('setting codec on cryptor to', {\n        codec\n      });\n      this.videoCodec = codec;\n    }\n    workerLogger.debug('Setting up frame cryptor transform', Object.assign({\n      operation,\n      passedTrackId: trackId,\n      codec\n    }, this.logContext));\n    const transformFn = operation === 'encode' ? this.encodeFunction : this.decodeFunction;\n    const transformStream = new TransformStream({\n      transform: transformFn.bind(this)\n    });\n    readable.pipeThrough(transformStream).pipeTo(writable).catch(e => {\n      workerLogger.warn(e);\n      this.emit(CryptorEvent.Error, e instanceof CryptorError ? e : new CryptorError(e.message, undefined, this.participantIdentity));\n    });\n    this.trackId = trackId;\n  }\n  setSifTrailer(trailer) {\n    workerLogger.debug('setting SIF trailer', Object.assign(Object.assign({}, this.logContext), {\n      trailer\n    }));\n    this.sifTrailer = trailer;\n  }\n  /**\n   * Function that will be injected in a stream and will encrypt the given encoded frames.\n   *\n   * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n   * @param {TransformStreamDefaultController} controller - TransportStreamController.\n   *\n   * The VP8 payload descriptor described in\n   * https://tools.ietf.org/html/rfc7741#section-4.2\n   * is part of the RTP packet and not part of the frame and is not controllable by us.\n   * This is fine as the SFU keeps having access to it for routing.\n   *\n   * The encrypted frame is formed as follows:\n   * 1) Find unencrypted byte length, depending on the codec, frame type and kind.\n   * 2) Form the GCM IV for the frame as described above.\n   * 3) Encrypt the rest of the frame using AES-GCM.\n   * 4) Allocate space for the encrypted frame.\n   * 5) Copy the unencrypted bytes to the start of the encrypted frame.\n   * 6) Append the ciphertext to the encrypted frame.\n   * 7) Append the IV.\n   * 8) Append a single byte for the key identifier.\n   * 9) Enqueue the encrypted frame for sending.\n   */\n  encodeFunction(encodedFrame, controller) {\n    return __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (!this.isEnabled() ||\n      // skip for encryption for empty dtx frames\n      encodedFrame.data.byteLength === 0) {\n        return controller.enqueue(encodedFrame);\n      }\n      const keySet = this.keys.getKeySet();\n      if (!keySet) {\n        this.emit(CryptorEvent.Error, new CryptorError(\"key set not found for \".concat(this.participantIdentity, \" at index \").concat(this.keys.getCurrentKeyIndex()), CryptorErrorReason.MissingKey, this.participantIdentity));\n        return;\n      }\n      const {\n        encryptionKey\n      } = keySet;\n      const keyIndex = this.keys.getCurrentKeyIndex();\n      if (encryptionKey) {\n        const iv = this.makeIV((_a = encodedFrame.getMetadata().synchronizationSource) !== null && _a !== void 0 ? _a : -1, encodedFrame.timestamp);\n        let frameInfo = this.getUnencryptedBytes(encodedFrame);\n        // Thіs is not encrypted and contains the VP8 payload descriptor or the Opus TOC byte.\n        const frameHeader = new Uint8Array(encodedFrame.data, 0, frameInfo.unencryptedBytes);\n        // Frame trailer contains the R|IV_LENGTH and key index\n        const frameTrailer = new Uint8Array(2);\n        frameTrailer[0] = IV_LENGTH;\n        frameTrailer[1] = keyIndex;\n        // Construct frame trailer. Similar to the frame header described in\n        // https://tools.ietf.org/html/draft-omara-sframe-00#section-4.2\n        // but we put it at the end.\n        //\n        // ---------+-------------------------+-+---------+----\n        // payload  |IV...(length = IV_LENGTH)|R|IV_LENGTH|KID |\n        // ---------+-------------------------+-+---------+----\n        try {\n          const cipherText = yield crypto.subtle.encrypt({\n            name: ENCRYPTION_ALGORITHM,\n            iv,\n            additionalData: new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength)\n          }, encryptionKey, new Uint8Array(encodedFrame.data, frameInfo.unencryptedBytes));\n          let newDataWithoutHeader = new Uint8Array(cipherText.byteLength + iv.byteLength + frameTrailer.byteLength);\n          newDataWithoutHeader.set(new Uint8Array(cipherText)); // add ciphertext.\n          newDataWithoutHeader.set(new Uint8Array(iv), cipherText.byteLength); // append IV.\n          newDataWithoutHeader.set(frameTrailer, cipherText.byteLength + iv.byteLength); // append frame trailer.\n          if (frameInfo.isH264) {\n            newDataWithoutHeader = writeRbsp(newDataWithoutHeader);\n          }\n          var newData = new Uint8Array(frameHeader.byteLength + newDataWithoutHeader.byteLength);\n          newData.set(frameHeader);\n          newData.set(newDataWithoutHeader, frameHeader.byteLength);\n          encodedFrame.data = newData.buffer;\n          return controller.enqueue(encodedFrame);\n        } catch (e) {\n          // TODO: surface this to the app.\n          workerLogger.error(e);\n        }\n      } else {\n        workerLogger.debug('failed to encrypt, emitting error', this.logContext);\n        this.emit(CryptorEvent.Error, new CryptorError(\"encryption key missing for encoding\", CryptorErrorReason.MissingKey, this.participantIdentity));\n      }\n    });\n  }\n  /**\n   * Function that will be injected in a stream and will decrypt the given encoded frames.\n   *\n   * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n   * @param {TransformStreamDefaultController} controller - TransportStreamController.\n   */\n  decodeFunction(encodedFrame, controller) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isEnabled() ||\n      // skip for decryption for empty dtx frames\n      encodedFrame.data.byteLength === 0) {\n        workerLogger.debug('skipping empty frame', this.logContext);\n        this.sifGuard.recordUserFrame();\n        return controller.enqueue(encodedFrame);\n      }\n      if (isFrameServerInjected(encodedFrame.data, this.sifTrailer)) {\n        workerLogger.debug('enqueue SIF', this.logContext);\n        this.sifGuard.recordSif();\n        if (this.sifGuard.isSifAllowed()) {\n          encodedFrame.data = encodedFrame.data.slice(0, encodedFrame.data.byteLength - this.sifTrailer.byteLength);\n          return controller.enqueue(encodedFrame);\n        } else {\n          workerLogger.warn('SIF limit reached, dropping frame');\n          return;\n        }\n      } else {\n        this.sifGuard.recordUserFrame();\n      }\n      const data = new Uint8Array(encodedFrame.data);\n      const keyIndex = data[encodedFrame.data.byteLength - 1];\n      if (this.keys.hasInvalidKeyAtIndex(keyIndex)) {\n        // drop frame\n        return;\n      }\n      if (this.keys.getKeySet(keyIndex)) {\n        try {\n          const decodedFrame = yield this.decryptFrame(encodedFrame, keyIndex);\n          this.keys.decryptionSuccess(keyIndex);\n          if (decodedFrame) {\n            return controller.enqueue(decodedFrame);\n          }\n        } catch (error) {\n          if (error instanceof CryptorError && error.reason === CryptorErrorReason.InvalidKey) {\n            // emit an error if the key handler thinks we have a valid key\n            if (this.keys.hasValidKey) {\n              this.emit(CryptorEvent.Error, error);\n              this.keys.decryptionFailure(keyIndex);\n            }\n          } else {\n            workerLogger.warn('decoding frame failed', {\n              error\n            });\n          }\n        }\n      } else {\n        // emit an error if the key index is out of bounds but the key handler thinks we still have a valid key\n        workerLogger.warn(\"skipping decryption due to missing key at index \".concat(keyIndex));\n        this.emit(CryptorEvent.Error, new CryptorError(\"missing key at index \".concat(keyIndex, \" for participant \").concat(this.participantIdentity), CryptorErrorReason.MissingKey, this.participantIdentity));\n        this.keys.decryptionFailure(keyIndex);\n      }\n    });\n  }\n  /**\n   * Function that will decrypt the given encoded frame. If the decryption fails, it will\n   * ratchet the key for up to RATCHET_WINDOW_SIZE times.\n   */\n  decryptFrame(encodedFrame_1, keyIndex_1) {\n    return __awaiter(this, arguments, void 0, function (encodedFrame, keyIndex) {\n      var _this = this;\n      let initialMaterial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      let ratchetOpts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n        ratchetCount: 0\n      };\n      return function* () {\n        var _a;\n        const keySet = _this.keys.getKeySet(keyIndex);\n        if (!ratchetOpts.encryptionKey && !keySet) {\n          throw new TypeError(\"no encryption key found for decryption of \".concat(_this.participantIdentity));\n        }\n        let frameInfo = _this.getUnencryptedBytes(encodedFrame);\n        // Construct frame trailer. Similar to the frame header described in\n        // https://tools.ietf.org/html/draft-omara-sframe-00#section-4.2\n        // but we put it at the end.\n        //\n        // ---------+-------------------------+-+---------+----\n        // payload  |IV...(length = IV_LENGTH)|R|IV_LENGTH|KID |\n        // ---------+-------------------------+-+---------+----\n        try {\n          const frameHeader = new Uint8Array(encodedFrame.data, 0, frameInfo.unencryptedBytes);\n          var encryptedData = new Uint8Array(encodedFrame.data, frameHeader.length, encodedFrame.data.byteLength - frameHeader.length);\n          if (frameInfo.isH264 && needsRbspUnescaping(encryptedData)) {\n            encryptedData = parseRbsp(encryptedData);\n            const newUint8 = new Uint8Array(frameHeader.byteLength + encryptedData.byteLength);\n            newUint8.set(frameHeader);\n            newUint8.set(encryptedData, frameHeader.byteLength);\n            encodedFrame.data = newUint8.buffer;\n          }\n          const frameTrailer = new Uint8Array(encodedFrame.data, encodedFrame.data.byteLength - 2, 2);\n          const ivLength = frameTrailer[0];\n          const iv = new Uint8Array(encodedFrame.data, encodedFrame.data.byteLength - ivLength - frameTrailer.byteLength, ivLength);\n          const cipherTextStart = frameHeader.byteLength;\n          const cipherTextLength = encodedFrame.data.byteLength - (frameHeader.byteLength + ivLength + frameTrailer.byteLength);\n          const plainText = yield crypto.subtle.decrypt({\n            name: ENCRYPTION_ALGORITHM,\n            iv,\n            additionalData: new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength)\n          }, (_a = ratchetOpts.encryptionKey) !== null && _a !== void 0 ? _a : keySet.encryptionKey, new Uint8Array(encodedFrame.data, cipherTextStart, cipherTextLength));\n          const newData = new ArrayBuffer(frameHeader.byteLength + plainText.byteLength);\n          const newUint8 = new Uint8Array(newData);\n          newUint8.set(new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength));\n          newUint8.set(new Uint8Array(plainText), frameHeader.byteLength);\n          encodedFrame.data = newData;\n          return encodedFrame;\n        } catch (error) {\n          if (_this.keyProviderOptions.ratchetWindowSize > 0) {\n            if (ratchetOpts.ratchetCount < _this.keyProviderOptions.ratchetWindowSize) {\n              workerLogger.debug(\"ratcheting key attempt \".concat(ratchetOpts.ratchetCount, \" of \").concat(_this.keyProviderOptions.ratchetWindowSize, \", for kind \").concat(encodedFrame instanceof RTCEncodedAudioFrame ? 'audio' : 'video'));\n              let ratchetedKeySet;\n              if ((initialMaterial !== null && initialMaterial !== void 0 ? initialMaterial : keySet) === _this.keys.getKeySet(keyIndex)) {\n                // only ratchet if the currently set key is still the same as the one used to decrypt this frame\n                // if not, it might be that a different frame has already ratcheted and we try with that one first\n                const newMaterial = yield _this.keys.ratchetKey(keyIndex, false);\n                ratchetedKeySet = yield deriveKeys(newMaterial, _this.keyProviderOptions.ratchetSalt);\n              }\n              const frame = yield _this.decryptFrame(encodedFrame, keyIndex, initialMaterial || keySet, {\n                ratchetCount: ratchetOpts.ratchetCount + 1,\n                encryptionKey: ratchetedKeySet === null || ratchetedKeySet === void 0 ? void 0 : ratchetedKeySet.encryptionKey\n              });\n              if (frame && ratchetedKeySet) {\n                // before updating the keys, make sure that the keySet used for this frame is still the same as the currently set key\n                // if it's not, a new key might have been set already, which we don't want to override\n                if ((initialMaterial !== null && initialMaterial !== void 0 ? initialMaterial : keySet) === _this.keys.getKeySet(keyIndex)) {\n                  _this.keys.setKeySet(ratchetedKeySet, keyIndex, true);\n                  // decryption was successful, set the new key index to reflect the ratcheted key set\n                  _this.keys.setCurrentKeyIndex(keyIndex);\n                }\n              }\n              return frame;\n            } else {\n              /**\n               * Because we only set a new key once decryption has been successful,\n               * we can be sure that we don't need to reset the key to the initial material at this point\n               * as the key has not been updated on the keyHandler instance\n               */\n              workerLogger.warn('maximum ratchet attempts exceeded');\n              throw new CryptorError(\"valid key missing for participant \".concat(_this.participantIdentity), CryptorErrorReason.InvalidKey, _this.participantIdentity);\n            }\n          } else {\n            throw new CryptorError(\"Decryption failed: \".concat(error.message), CryptorErrorReason.InvalidKey, _this.participantIdentity);\n          }\n        }\n      }();\n    });\n  }\n  /**\n   * Construct the IV used for AES-GCM and sent (in plain) with the packet similar to\n   * https://tools.ietf.org/html/rfc7714#section-8.1\n   * It concatenates\n   * - the 32 bit synchronization source (SSRC) given on the encoded frame,\n   * - the 32 bit rtp timestamp given on the encoded frame,\n   * - a send counter that is specific to the SSRC. Starts at a random number.\n   * The send counter is essentially the pictureId but we currently have to implement this ourselves.\n   * There is no XOR with a salt. Note that this IV leaks the SSRC to the receiver but since this is\n   * randomly generated and SFUs may not rewrite this is considered acceptable.\n   * The SSRC is used to allow demultiplexing multiple streams with the same key, as described in\n   *   https://tools.ietf.org/html/rfc3711#section-4.1.1\n   * The RTP timestamp is 32 bits and advances by the codec clock rate (90khz for video, 48khz for\n   * opus audio) every second. For video it rolls over roughly every 13 hours.\n   * The send counter will advance at the frame rate (30fps for video, 50fps for 20ms opus audio)\n   * every second. It will take a long time to roll over.\n   *\n   * See also https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams\n   */\n  makeIV(synchronizationSource, timestamp) {\n    var _a;\n    const iv = new ArrayBuffer(IV_LENGTH);\n    const ivView = new DataView(iv);\n    // having to keep our own send count (similar to a picture id) is not ideal.\n    if (!this.sendCounts.has(synchronizationSource)) {\n      // Initialize with a random offset, similar to the RTP sequence number.\n      this.sendCounts.set(synchronizationSource, Math.floor(Math.random() * 0xffff));\n    }\n    const sendCount = (_a = this.sendCounts.get(synchronizationSource)) !== null && _a !== void 0 ? _a : 0;\n    ivView.setUint32(0, synchronizationSource);\n    ivView.setUint32(4, timestamp);\n    ivView.setUint32(8, timestamp - sendCount % 0xffff);\n    this.sendCounts.set(synchronizationSource, sendCount + 1);\n    return iv;\n  }\n  getUnencryptedBytes(frame) {\n    var _a;\n    var frameInfo = {\n      unencryptedBytes: 0,\n      isH264: false\n    };\n    if (isVideoFrame(frame)) {\n      let detectedCodec = (_a = this.getVideoCodec(frame)) !== null && _a !== void 0 ? _a : this.videoCodec;\n      if (detectedCodec !== this.detectedCodec) {\n        workerLogger.debug('detected different codec', Object.assign({\n          detectedCodec,\n          oldCodec: this.detectedCodec\n        }, this.logContext));\n        this.detectedCodec = detectedCodec;\n      }\n      if (detectedCodec === 'av1') {\n        throw new Error(\"\".concat(detectedCodec, \" is not yet supported for end to end encryption\"));\n      }\n      if (detectedCodec === 'vp8') {\n        frameInfo.unencryptedBytes = UNENCRYPTED_BYTES[frame.type];\n      } else if (detectedCodec === 'vp9') {\n        frameInfo.unencryptedBytes = 0;\n        return frameInfo;\n      }\n      const data = new Uint8Array(frame.data);\n      try {\n        const naluIndices = findNALUIndices(data);\n        // if the detected codec is undefined we test whether it _looks_ like a h264 frame as a best guess\n        frameInfo.isH264 = detectedCodec === 'h264' || naluIndices.some(naluIndex => [NALUType.SLICE_IDR, NALUType.SLICE_NON_IDR].includes(parseNALUType(data[naluIndex])));\n        if (frameInfo.isH264) {\n          for (const index of naluIndices) {\n            let type = parseNALUType(data[index]);\n            switch (type) {\n              case NALUType.SLICE_IDR:\n              case NALUType.SLICE_NON_IDR:\n                frameInfo.unencryptedBytes = index + 2;\n                return frameInfo;\n              default:\n                break;\n            }\n          }\n          throw new TypeError('Could not find NALU');\n        }\n      } catch (e) {\n        // no op, we just continue and fallback to vp8\n      }\n      frameInfo.unencryptedBytes = UNENCRYPTED_BYTES[frame.type];\n      return frameInfo;\n    } else {\n      frameInfo.unencryptedBytes = UNENCRYPTED_BYTES.audio;\n      return frameInfo;\n    }\n  }\n  /**\n   * inspects frame payloadtype if available and maps it to the codec specified in rtpMap\n   */\n  getVideoCodec(frame) {\n    if (this.rtpMap.size === 0) {\n      return undefined;\n    }\n    const payloadType = frame.getMetadata().payloadType;\n    const codec = payloadType ? this.rtpMap.get(payloadType) : undefined;\n    return codec;\n  }\n}\n/**\n * Slice the NALUs present in the supplied buffer, assuming it is already byte-aligned\n * code adapted from https://github.com/medooze/h264-frame-parser/blob/main/lib/NalUnits.ts to return indices only\n */\nfunction findNALUIndices(stream) {\n  const result = [];\n  let start = 0,\n    pos = 0,\n    searchLength = stream.length - 2;\n  while (pos < searchLength) {\n    // skip until end of current NALU\n    while (pos < searchLength && !(stream[pos] === 0 && stream[pos + 1] === 0 && stream[pos + 2] === 1)) pos++;\n    if (pos >= searchLength) pos = stream.length;\n    // remove trailing zeros from current NALU\n    let end = pos;\n    while (end > start && stream[end - 1] === 0) end--;\n    // save current NALU\n    if (start === 0) {\n      if (end !== start) throw TypeError('byte stream contains leading data');\n    } else {\n      result.push(start);\n    }\n    // begin new NALU\n    start = pos = pos + 3;\n  }\n  return result;\n}\nfunction parseNALUType(startByte) {\n  return startByte & kNaluTypeMask;\n}\nconst kNaluTypeMask = 0x1f;\nvar NALUType;\n(function (NALUType) {\n  /** Coded slice of a non-IDR picture */\n  NALUType[NALUType[\"SLICE_NON_IDR\"] = 1] = \"SLICE_NON_IDR\";\n  /** Coded slice data partition A */\n  NALUType[NALUType[\"SLICE_PARTITION_A\"] = 2] = \"SLICE_PARTITION_A\";\n  /** Coded slice data partition B */\n  NALUType[NALUType[\"SLICE_PARTITION_B\"] = 3] = \"SLICE_PARTITION_B\";\n  /** Coded slice data partition C */\n  NALUType[NALUType[\"SLICE_PARTITION_C\"] = 4] = \"SLICE_PARTITION_C\";\n  /** Coded slice of an IDR picture */\n  NALUType[NALUType[\"SLICE_IDR\"] = 5] = \"SLICE_IDR\";\n  /** Supplemental enhancement information */\n  NALUType[NALUType[\"SEI\"] = 6] = \"SEI\";\n  /** Sequence parameter set */\n  NALUType[NALUType[\"SPS\"] = 7] = \"SPS\";\n  /** Picture parameter set */\n  NALUType[NALUType[\"PPS\"] = 8] = \"PPS\";\n  /** Access unit delimiter */\n  NALUType[NALUType[\"AUD\"] = 9] = \"AUD\";\n  /** End of sequence */\n  NALUType[NALUType[\"END_SEQ\"] = 10] = \"END_SEQ\";\n  /** End of stream */\n  NALUType[NALUType[\"END_STREAM\"] = 11] = \"END_STREAM\";\n  /** Filler data */\n  NALUType[NALUType[\"FILLER_DATA\"] = 12] = \"FILLER_DATA\";\n  /** Sequence parameter set extension */\n  NALUType[NALUType[\"SPS_EXT\"] = 13] = \"SPS_EXT\";\n  /** Prefix NAL unit */\n  NALUType[NALUType[\"PREFIX_NALU\"] = 14] = \"PREFIX_NALU\";\n  /** Subset sequence parameter set */\n  NALUType[NALUType[\"SUBSET_SPS\"] = 15] = \"SUBSET_SPS\";\n  /** Depth parameter set */\n  NALUType[NALUType[\"DPS\"] = 16] = \"DPS\";\n  // 17, 18 reserved\n  /** Coded slice of an auxiliary coded picture without partitioning */\n  NALUType[NALUType[\"SLICE_AUX\"] = 19] = \"SLICE_AUX\";\n  /** Coded slice extension */\n  NALUType[NALUType[\"SLICE_EXT\"] = 20] = \"SLICE_EXT\";\n  /** Coded slice extension for a depth view component or a 3D-AVC texture view component */\n  NALUType[NALUType[\"SLICE_LAYER_EXT\"] = 21] = \"SLICE_LAYER_EXT\";\n  // 22, 23 reserved\n})(NALUType || (NALUType = {}));\n/**\n * we use a magic frame trailer to detect whether a frame is injected\n * by the livekit server and thus to be treated as unencrypted\n * @internal\n */\nfunction isFrameServerInjected(frameData, trailerBytes) {\n  if (trailerBytes.byteLength === 0) {\n    return false;\n  }\n  const frameTrailer = new Uint8Array(frameData.slice(frameData.byteLength - trailerBytes.byteLength));\n  return trailerBytes.every((value, index) => value === frameTrailer[index]);\n}\n\n// TODO ParticipantKeyHandlers currently don't get destroyed on participant disconnect\n// we could do this by having a separate worker message on participant disconnected.\n/**\n * ParticipantKeyHandler is responsible for providing a cryptor instance with the\n * en-/decryption key of a participant. It assumes that all tracks of a specific participant\n * are encrypted with the same key.\n * Additionally it exposes a method to ratchet a key which can be used by the cryptor either automatically\n * if decryption fails or can be triggered manually on both sender and receiver side.\n *\n */\nclass ParticipantKeyHandler extends eventsExports.EventEmitter {\n  /**\n   * true if the current key has not been marked as invalid\n   */\n  get hasValidKey() {\n    return !this.hasInvalidKeyAtIndex(this.currentKeyIndex);\n  }\n  constructor(participantIdentity, keyProviderOptions) {\n    super();\n    this.currentKeyIndex = 0;\n    if (keyProviderOptions.keyringSize < 1 || keyProviderOptions.keyringSize > 256) {\n      throw new TypeError('Keyring size needs to be between 1 and 256');\n    }\n    this.cryptoKeyRing = new Array(keyProviderOptions.keyringSize).fill(undefined);\n    this.decryptionFailureCounts = new Array(keyProviderOptions.keyringSize).fill(0);\n    this.keyProviderOptions = keyProviderOptions;\n    this.ratchetPromiseMap = new Map();\n    this.participantIdentity = participantIdentity;\n  }\n  /**\n   * Returns true if the key at the given index is marked as invalid.\n   *\n   * @param keyIndex the index of the key\n   */\n  hasInvalidKeyAtIndex(keyIndex) {\n    return this.keyProviderOptions.failureTolerance >= 0 && this.decryptionFailureCounts[keyIndex] > this.keyProviderOptions.failureTolerance;\n  }\n  /**\n   * Informs the key handler that a decryption failure occurred for an encryption key.\n   * @internal\n   * @param keyIndex the key index for which the failure occurred. Defaults to the current key index.\n   */\n  decryptionFailure() {\n    let keyIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentKeyIndex;\n    if (this.keyProviderOptions.failureTolerance < 0) {\n      return;\n    }\n    this.decryptionFailureCounts[keyIndex] += 1;\n    if (this.decryptionFailureCounts[keyIndex] > this.keyProviderOptions.failureTolerance) {\n      workerLogger.warn(\"key for \".concat(this.participantIdentity, \" at index \").concat(keyIndex, \" is being marked as invalid\"));\n    }\n  }\n  /**\n   * Informs the key handler that a frame was successfully decrypted using an encryption key.\n   * @internal\n   * @param keyIndex the key index for which the success occurred. Defaults to the current key index.\n   */\n  decryptionSuccess() {\n    let keyIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentKeyIndex;\n    this.resetKeyStatus(keyIndex);\n  }\n  /**\n   * Call this after user initiated ratchet or a new key has been set in order to make sure to mark potentially\n   * invalid keys as valid again\n   *\n   * @param keyIndex the index of the key. Defaults to the current key index.\n   */\n  resetKeyStatus(keyIndex) {\n    if (keyIndex === undefined) {\n      this.decryptionFailureCounts.fill(0);\n    } else {\n      this.decryptionFailureCounts[keyIndex] = 0;\n    }\n  }\n  /**\n   * Ratchets the current key (or the one at keyIndex if provided) and\n   * returns the ratcheted material\n   * if `setKey` is true (default), it will also set the ratcheted key directly on the crypto key ring\n   * @param keyIndex\n   * @param setKey\n   */\n  ratchetKey(keyIndex) {\n    let setKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const currentKeyIndex = keyIndex !== null && keyIndex !== void 0 ? keyIndex : this.getCurrentKeyIndex();\n    const existingPromise = this.ratchetPromiseMap.get(currentKeyIndex);\n    if (typeof existingPromise !== 'undefined') {\n      return existingPromise;\n    }\n    const ratchetPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      try {\n        const keySet = this.getKeySet(currentKeyIndex);\n        if (!keySet) {\n          throw new TypeError(\"Cannot ratchet key without a valid keyset of participant \".concat(this.participantIdentity));\n        }\n        const currentMaterial = keySet.material;\n        const newMaterial = yield importKey(yield ratchet(currentMaterial, this.keyProviderOptions.ratchetSalt), currentMaterial.algorithm.name, 'derive');\n        if (setKey) {\n          yield this.setKeyFromMaterial(newMaterial, currentKeyIndex, true);\n          this.emit(KeyHandlerEvent.KeyRatcheted, newMaterial, this.participantIdentity, currentKeyIndex);\n        }\n        resolve(newMaterial);\n      } catch (e) {\n        reject(e);\n      } finally {\n        this.ratchetPromiseMap.delete(currentKeyIndex);\n      }\n    }));\n    this.ratchetPromiseMap.set(currentKeyIndex, ratchetPromise);\n    return ratchetPromise;\n  }\n  /**\n   * takes in a key material with `deriveBits` and `deriveKey` set as key usages\n   * and derives encryption keys from the material and sets it on the key ring buffer\n   * together with the material\n   * also resets the valid key property and updates the currentKeyIndex\n   */\n  setKey(material_1) {\n    return __awaiter(this, arguments, void 0, function (material) {\n      var _this = this;\n      let keyIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return function* () {\n        yield _this.setKeyFromMaterial(material, keyIndex);\n        _this.resetKeyStatus(keyIndex);\n      }();\n    });\n  }\n  /**\n   * takes in a key material with `deriveBits` and `deriveKey` set as key usages\n   * and derives encryption keys from the material and sets it on the key ring buffers\n   * together with the material\n   * also updates the currentKeyIndex\n   */\n  setKeyFromMaterial(material_1, keyIndex_1) {\n    return __awaiter(this, arguments, void 0, function (material, keyIndex) {\n      var _this2 = this;\n      let emitRatchetEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      return function* () {\n        const keySet = yield deriveKeys(material, _this2.keyProviderOptions.ratchetSalt);\n        const newIndex = keyIndex >= 0 ? keyIndex % _this2.cryptoKeyRing.length : _this2.currentKeyIndex;\n        workerLogger.debug(\"setting new key with index \".concat(keyIndex), {\n          usage: material.usages,\n          algorithm: material.algorithm,\n          ratchetSalt: _this2.keyProviderOptions.ratchetSalt\n        });\n        _this2.setKeySet(keySet, newIndex, emitRatchetEvent);\n        if (newIndex >= 0) _this2.currentKeyIndex = newIndex;\n      }();\n    });\n  }\n  setKeySet(keySet, keyIndex) {\n    let emitRatchetEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    this.cryptoKeyRing[keyIndex % this.cryptoKeyRing.length] = keySet;\n    if (emitRatchetEvent) {\n      this.emit(KeyHandlerEvent.KeyRatcheted, keySet.material, this.participantIdentity, keyIndex);\n    }\n  }\n  setCurrentKeyIndex(index) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.currentKeyIndex = index % this.cryptoKeyRing.length;\n      this.resetKeyStatus(index);\n    });\n  }\n  getCurrentKeyIndex() {\n    return this.currentKeyIndex;\n  }\n  /**\n   * returns currently used KeySet or the one at `keyIndex` if provided\n   * @param keyIndex\n   * @returns\n   */\n  getKeySet(keyIndex) {\n    return this.cryptoKeyRing[keyIndex !== null && keyIndex !== void 0 ? keyIndex : this.currentKeyIndex];\n  }\n}\n\nconst participantCryptors = [];\nconst participantKeys = new Map();\nlet sharedKeyHandler;\nlet messageQueue = new AsyncQueue();\nlet isEncryptionEnabled = false;\nlet useSharedKey = false;\nlet sifTrailer;\nlet keyProviderOptions = KEY_PROVIDER_DEFAULTS;\nlet rtpMap = new Map();\nworkerLogger.setDefaultLevel('info');\nonmessage = ev => {\n  messageQueue.run(() => __awaiter(void 0, void 0, void 0, function* () {\n    const {\n      kind,\n      data\n    } = ev.data;\n    switch (kind) {\n      case 'init':\n        workerLogger.setLevel(data.loglevel);\n        workerLogger.info('worker initialized');\n        keyProviderOptions = data.keyProviderOptions;\n        useSharedKey = !!data.keyProviderOptions.sharedKey;\n        // acknowledge init successful\n        const ackMsg = {\n          kind: 'initAck',\n          data: {\n            enabled: isEncryptionEnabled\n          }\n        };\n        postMessage(ackMsg);\n        break;\n      case 'enable':\n        setEncryptionEnabled(data.enabled, data.participantIdentity);\n        workerLogger.info(\"updated e2ee enabled status for \".concat(data.participantIdentity, \" to \").concat(data.enabled));\n        // acknowledge enable call successful\n        postMessage(ev.data);\n        break;\n      case 'decode':\n        let cryptor = getTrackCryptor(data.participantIdentity, data.trackId);\n        cryptor.setupTransform(kind, data.readableStream, data.writableStream, data.trackId, data.codec);\n        break;\n      case 'encode':\n        let pubCryptor = getTrackCryptor(data.participantIdentity, data.trackId);\n        pubCryptor.setupTransform(kind, data.readableStream, data.writableStream, data.trackId, data.codec);\n        break;\n      case 'setKey':\n        if (useSharedKey) {\n          yield setSharedKey(data.key, data.keyIndex);\n        } else if (data.participantIdentity) {\n          workerLogger.info(\"set participant sender key \".concat(data.participantIdentity, \" index \").concat(data.keyIndex));\n          yield getParticipantKeyHandler(data.participantIdentity).setKey(data.key, data.keyIndex);\n        } else {\n          workerLogger.error('no participant Id was provided and shared key usage is disabled');\n        }\n        break;\n      case 'removeTransform':\n        unsetCryptorParticipant(data.trackId, data.participantIdentity);\n        break;\n      case 'updateCodec':\n        getTrackCryptor(data.participantIdentity, data.trackId).setVideoCodec(data.codec);\n        break;\n      case 'setRTPMap':\n        // this is only used for the local participant\n        rtpMap = data.map;\n        participantCryptors.forEach(cr => {\n          if (cr.getParticipantIdentity() === data.participantIdentity) {\n            cr.setRtpMap(data.map);\n          }\n        });\n        break;\n      case 'ratchetRequest':\n        handleRatchetRequest(data);\n        break;\n      case 'setSifTrailer':\n        handleSifTrailer(data.trailer);\n        break;\n    }\n  }));\n};\nfunction handleRatchetRequest(data) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (useSharedKey) {\n      const keyHandler = getSharedKeyHandler();\n      yield keyHandler.ratchetKey(data.keyIndex);\n      keyHandler.resetKeyStatus();\n    } else if (data.participantIdentity) {\n      const keyHandler = getParticipantKeyHandler(data.participantIdentity);\n      yield keyHandler.ratchetKey(data.keyIndex);\n      keyHandler.resetKeyStatus();\n    } else {\n      workerLogger.error('no participant Id was provided for ratchet request and shared key usage is disabled');\n    }\n  });\n}\nfunction getTrackCryptor(participantIdentity, trackId) {\n  let cryptors = participantCryptors.filter(c => c.getTrackId() === trackId);\n  if (cryptors.length > 1) {\n    const debugInfo = cryptors.map(c => {\n      return {\n        participant: c.getParticipantIdentity()\n      };\n    }).join(',');\n    workerLogger.error(\"Found multiple cryptors for the same trackID \".concat(trackId, \". target participant: \").concat(participantIdentity, \" \"), {\n      participants: debugInfo\n    });\n  }\n  let cryptor = cryptors[0];\n  if (!cryptor) {\n    workerLogger.info('creating new cryptor for', {\n      participantIdentity\n    });\n    if (!keyProviderOptions) {\n      throw Error('Missing keyProvider options');\n    }\n    cryptor = new FrameCryptor({\n      participantIdentity,\n      keys: getParticipantKeyHandler(participantIdentity),\n      keyProviderOptions,\n      sifTrailer\n    });\n    cryptor.setRtpMap(rtpMap);\n    setupCryptorErrorEvents(cryptor);\n    participantCryptors.push(cryptor);\n  } else if (participantIdentity !== cryptor.getParticipantIdentity()) {\n    // assign new participant id to track cryptor and pass in correct key handler\n    cryptor.setParticipant(participantIdentity, getParticipantKeyHandler(participantIdentity));\n  }\n  return cryptor;\n}\nfunction getParticipantKeyHandler(participantIdentity) {\n  if (useSharedKey) {\n    return getSharedKeyHandler();\n  }\n  let keys = participantKeys.get(participantIdentity);\n  if (!keys) {\n    keys = new ParticipantKeyHandler(participantIdentity, keyProviderOptions);\n    keys.on(KeyHandlerEvent.KeyRatcheted, emitRatchetedKeys);\n    participantKeys.set(participantIdentity, keys);\n  }\n  return keys;\n}\nfunction getSharedKeyHandler() {\n  if (!sharedKeyHandler) {\n    workerLogger.debug('creating new shared key handler');\n    sharedKeyHandler = new ParticipantKeyHandler('shared-key', keyProviderOptions);\n  }\n  return sharedKeyHandler;\n}\nfunction unsetCryptorParticipant(trackId, participantIdentity) {\n  const cryptors = participantCryptors.filter(c => c.getParticipantIdentity() === participantIdentity && c.getTrackId() === trackId);\n  if (cryptors.length > 1) {\n    workerLogger.error('Found multiple cryptors for the same participant and trackID combination', {\n      trackId,\n      participantIdentity\n    });\n  }\n  const cryptor = cryptors[0];\n  if (!cryptor) {\n    workerLogger.warn('Could not unset participant on cryptor', {\n      trackId,\n      participantIdentity\n    });\n  } else {\n    cryptor.unsetParticipant();\n  }\n}\nfunction setEncryptionEnabled(enable, participantIdentity) {\n  workerLogger.debug(\"setting encryption enabled for all tracks of \".concat(participantIdentity), {\n    enable\n  });\n  encryptionEnabledMap.set(participantIdentity, enable);\n}\nfunction setSharedKey(key, index) {\n  return __awaiter(this, void 0, void 0, function* () {\n    workerLogger.info('set shared key', {\n      index\n    });\n    yield getSharedKeyHandler().setKey(key, index);\n  });\n}\nfunction setupCryptorErrorEvents(cryptor) {\n  cryptor.on(CryptorEvent.Error, error => {\n    const msg = {\n      kind: 'error',\n      data: {\n        error: new Error(\"\".concat(CryptorErrorReason[error.reason], \": \").concat(error.message))\n      }\n    };\n    postMessage(msg);\n  });\n}\nfunction emitRatchetedKeys(material, participantIdentity, keyIndex) {\n  const msg = {\n    kind: \"ratchetKey\",\n    data: {\n      participantIdentity,\n      keyIndex,\n      material\n    }\n  };\n  postMessage(msg);\n}\nfunction handleSifTrailer(trailer) {\n  sifTrailer = trailer;\n  participantCryptors.forEach(c => {\n    c.setSifTrailer(trailer);\n  });\n}\n// Operations using RTCRtpScriptTransform.\n// @ts-ignore\nif (self.RTCTransformEvent) {\n  workerLogger.debug('setup transform event');\n  // @ts-ignore\n  self.onrtctransform = event => {\n    // @ts-ignore .transformer property is part of RTCTransformEvent\n    const transformer = event.transformer;\n    workerLogger.debug('transformer', transformer);\n    // @ts-ignore monkey patching non standard flag\n    transformer.handled = true;\n    const {\n      kind,\n      participantIdentity,\n      trackId,\n      codec\n    } = transformer.options;\n    const cryptor = getTrackCryptor(participantIdentity, trackId);\n    workerLogger.debug('transform', {\n      codec\n    });\n    cryptor.setupTransform(kind, transformer.readable, transformer.writable, trackId, codec);\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjUuOS9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9saXZla2l0LWNsaWVudC5lMmVlLndvcmtlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBTUMsQ0FBVUEsVUFBQUEsSUFBSSxFQUFFQyxVQUFVLEVBQUU7O01BSWxCLElBQWtDQyxNQUFNLENBQUNDLE9BQU8sRUFBRTtBQUNyREQsUUFBQUEsTUFBQSxDQUFBQyxPQUFBLEdBQWlCRixVQUFVLEVBQUU7QUFDckMsT0FBSyxNQUFNO0FBQ0hELFFBQUFBLElBQUksQ0FBQ0ksR0FBRyxHQUFHSCxVQUFVLEVBQUU7QUFDMUI7S0FDSixFQUFDSSxRQUFJLEVBQUUsWUFBWTs7QUFHcEI7QUFDSSxVQUFJQyxJQUFJLEdBQUcsWUFBVyxFQUFFO01BQ3hCLElBQUlDLGFBQWEsR0FBRyxXQUFXO01BQy9CLElBQUlDLElBQUksR0FBSSxPQUFPQyxNQUFNLEtBQUtGLGFBQWEsSUFBTSxPQUFPRSxNQUFNLENBQUNDLFNBQVMsS0FBS0gsYUFBYyxJQUN2RixpQkFBaUIsQ0FBQ0ksSUFBSSxDQUFDRixNQUFNLENBQUNDLFNBQVMsQ0FBQ0UsU0FBUyxDQUNwRDtBQUVELFVBQUlDLFVBQVUsR0FBRyxDQUNiLE9BQU8sRUFDUCxPQUFPLEVBQ1AsTUFBTSxFQUNOLE1BQU0sRUFDTixPQUFPLENBQ1Y7TUFFRCxJQUFJQyxjQUFjLEdBQUcsRUFBRTtNQUN2QixJQUFJQyxhQUFhLEdBQUcsSUFBSTs7QUFFNUI7QUFDSSxlQUFTQyxVQUFVQSxDQUFDQyxHQUFHLEVBQUVDLFVBQVUsRUFBRTtBQUNqQyxZQUFJQyxNQUFNLEdBQUdGLEdBQUcsQ0FBQ0MsVUFBVSxDQUFDO0FBQzVCLFlBQUksT0FBT0MsTUFBTSxDQUFDQyxJQUFJLEtBQUssVUFBVSxFQUFF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Q0FBQyxDQUFDLEdBQUcsT0FBTztFQUM3Q0EsVUFBVSxDQUFDQSxVQUFVLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsUUFBUTtBQUMvQztBQUNBO0VBQ0FBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLE9BQU87RUFDN0NBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFNBQVM7RUFDakRBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFNBQVM7RUFDakRBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU07RUFDM0NBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDQUEsVUFBVSxDQUFDQSxVQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsT0FBTztFQUM5Q0EsVUFBVSxDQUFDQSxVQUFVLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsUUFBUTtBQUNoRDtFQUNBQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxVQUFVO0VBQ3BEQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxVQUFVO0VBQ3BEQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRO0VBQ2hEQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxRQUFRO0FBQ3BELENBQUMsRUFBRUEsVUFBVSxLQUFLQSxVQUFVLEdBQUcsRUFBRSxDQUFDLENBQUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBSUMsUUFBUTtBQUNuQixDQUFDLFVBQVVBLFFBQVEsRUFBRTtBQUNqQjtBQUNKO0FBQ0E7RUFDSUEsUUFBUSxDQUFDQSxRQUFRLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsUUFBUTtBQUMzQztBQUNKO0FBQ0E7QUFDQTtBQUNBO0VBQ0lBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFFBQVE7QUFDL0MsQ0FBQyxFQUFFQSxRQUFRLEtBQUtBLFFBQVEsR0FBRyxFQUFFLENBQUMsQ0FBQzs7QUM3RS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ08sU0FBU0MsWUFBWUEsQ0FBQ3pILElBQUksRUFBRXlDLENBQUMsRUFBRUMsQ0FBQyxFQUFFO0VBQ3JDLElBQUlELENBQUMsS0FBS0MsQ0FBQyxFQUFFO0FBQ1Q7QUFDQSxXQUFPLElBQUk7QUFDZjtBQUNBO0FBQ0EsTUFBSTFDLElBQUksSUFBSXVILFVBQVUsQ0FBQ0csS0FBSyxFQUFFO0lBQzFCLElBQUksRUFBRWpGLENBQUMsWUFBWWtGLFVBQVUsQ0FBQyxJQUFJLEVBQUVqRixDQUFDLFlBQVlpRixVQUFVLENBQUMsRUFBRTtBQUMxRCxhQUFPLEtBQUs7QUFDaEI7QUFDQSxRQUFJbEYsQ0FBQyxDQUFDekosTUFBTSxLQUFLMEosQ0FBQyxDQUFDMUosTUFBTSxFQUFFO0FBQ3ZCLGFBQU8sS0FBSztBQUNoQjtBQUNBLFNBQUssSUFBSUQsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHMEosQ0FBQyxDQUFDekosTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRTtNQUMvQixJQUFJMEosQ0FBQyxDQUFDMUosQ0FBQyxDQUFDLEtBQUsySixDQUFDLENBQUMzSixDQUFDLENBQUMsRUFBRTtBQUNmLGVBQU8sS0FBSztBQUNoQjtBQUNKO0FBQ0EsV0FBTyxJQUFJO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsVUFBUWlILElBQUk7SUFDUixLQUFLdUgsVUFBVSxDQUFDSyxNQUFNO0lBQ3RCLEtBQUtMLFVBQVUsQ0FBQ00sT0FBTztJQUN2QixLQUFLTixVQUFVLENBQUNPLEtBQUs7SUFDckIsS0FBS1AsVUFBVSxDQUFDUSxRQUFRO0lBQ3hCLEtBQUtSLFVBQVUsQ0FBQ1MsTUFBTTtBQUNsQjtNQUNBLE9BQU92RixDQUFDLElBQUlDLENBQUM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBTyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU3VGLGVBQWVBLENBQUNqSSxJQUFJLEVBQUVrSSxRQUFRLEVBQUU7QUFDNUMsVUFBUWxJLElBQUk7SUFDUixLQUFLdUgsVUFBVSxDQUFDWSxJQUFJO0FBQ2hCLGFBQU8sS0FBSztJQUNoQixLQUFLWixVQUFVLENBQUNLLE1BQU07SUFDdEIsS0FBS0wsVUFBVSxDQUFDTSxPQUFPO0lBQ3ZCLEtBQUtOLFVBQVUsQ0FBQ08sS0FBSztJQUNyQixLQUFLUCxVQUFVLENBQUNRLFFBQVE7SUFDeEIsS0FBS1IsVUFBVSxDQUFDUyxNQUFNO0FBQ2xCO01BQ0EsT0FBUUUsUUFBUSxJQUFJLENBQUMsR0FBR1osVUFBVSxDQUFDWCxJQUFJLEdBQUcsR0FBRztJQUNqRCxLQUFLWSxVQUFVLENBQUNhLE1BQU07SUFDdEIsS0FBS2IsVUFBVSxDQUFDYyxLQUFLO0FBQ2pCLGFBQU8sR0FBRztJQUNkLEtBQUtkLFVBQVUsQ0FBQ0csS0FBSztBQUNqQixhQUFPLElBQUlDLFVBQVUsQ0FBQyxDQUFDLENBQUM7SUFDNUIsS0FBS0osVUFBVSxDQUFDZSxNQUFNO0FBQ2xCLGFBQU8sRUFBRTtBQUNiO0FBQ0k7QUFDQTtBQUNBLGFBQU8sQ0FBQztBQUNoQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTQyxpQkFBaUJBLENBQUN2SSxJQUFJLEVBQUVsQixLQUFLLEVBQUU7QUFDM0MsVUFBUWtCLElBQUk7SUFDUixLQUFLdUgsVUFBVSxDQUFDWSxJQUFJO01BQ2hCLE9BQU9ySixLQUFLLEtBQUssS0FBSztJQUMxQixLQUFLeUksVUFBVSxDQUFDZSxNQUFNO01BQ2xCLE9BQU94SixLQUFLLEtBQUssRUFBRTtJQUN2QixLQUFLeUksVUFBVSxDQUFDRyxLQUFLO0FBQ2pCLGFBQU81SSxLQUFLLFlBQVk2SSxVQUFVLElBQUksQ0FBQzdJLEtBQUssQ0FBQ3dCLFVBQVU7QUFDM0Q7TUFDSSxPQUFPeEIsS0FBSyxJQUFJLENBQUM7QUFBRTtBQUMzQjtBQUNKOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLElBQUkwSixRQUFRO0FBQ25CLENBQUMsVUFBVUEsUUFBUSxFQUFFO0FBQ2pCO0FBQ0o7QUFDQTtFQUNJQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxRQUFRO0FBQzNDO0FBQ0o7QUFDQTtBQUNBO0VBQ0lBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLE9BQU87QUFDekM7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUEsUUFBUSxDQUFDQSxRQUFRLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxpQkFBaUI7QUFDN0Q7QUFDSjtBQUNBO0FBQ0E7RUFDSUEsUUFBUSxDQUFDQSxRQUFRLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsWUFBWTtBQUNuRDtBQUNKO0FBQ0E7RUFDSUEsUUFBUSxDQUFDQSxRQUFRLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsVUFBVTtBQUMvQztBQUNKO0FBQ0E7QUFDQTtFQUNJQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxPQUFPO0FBQzdDLENBQUMsRUFBRUEsUUFBUSxLQUFLQSxRQUFRLEdBQUcsRUFBRSxDQUFDLENBQUM7QUFDeEIsTUFBTUMsWUFBWSxDQUFDO0VBQ3RCMUcsV0FBV0EsQ0FBQzJHLFdBQVcsRUFBRTtBQUNyQjtBQUNSO0FBQ0E7SUFDUSxJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFO0FBQ2YsUUFBSSxDQUFDRCxXQUFXLEdBQUdBLFdBQVcsS0FBSyxJQUFJLElBQUlBLFdBQVcsS0FBSyxLQUFLLENBQUMsR0FBR0EsV0FBVyxHQUFHLElBQUlFLFdBQVcsRUFBRTtJQUNuRyxJQUFJLENBQUNDLE1BQU0sR0FBRyxFQUFFO0lBQ2hCLElBQUksQ0FBQzlGLEdBQUcsR0FBRyxFQUFFO0FBQ2pCO0FBQ0E7QUFDSjtBQUNBO0FBQ0l6QixFQUFBQSxNQUFNQSxHQUFHO0FBQ0wsUUFBSSxDQUFDdUgsTUFBTSxDQUFDNUosSUFBSSxDQUFDLElBQUkwSSxVQUFVLENBQUMsSUFBSSxDQUFDNUUsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMzQyxJQUFJK0YsR0FBRyxHQUFHLENBQUM7SUFDWCxLQUFLLElBQUkvUCxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUcsSUFBSSxDQUFDOFAsTUFBTSxDQUFDN1AsTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFDdkMrUCxHQUFHLElBQUksSUFBSSxDQUFDRCxNQUFNLENBQUM5UCxDQUFDLENBQUMsQ0FBQ0MsTUFBTTtBQUNoQyxRQUFJOEcsS0FBSyxHQUFHLElBQUk2SCxVQUFVLENBQUNtQixHQUFHLENBQUM7SUFDL0IsSUFBSUMsTUFBTSxHQUFHLENBQUM7QUFDZCxTQUFLLElBQUloUSxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUcsSUFBSSxDQUFDOFAsTUFBTSxDQUFDN1AsTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRTtNQUN6QytHLEtBQUssQ0FBQ2tKLEdBQUcsQ0FBQyxJQUFJLENBQUNILE1BQU0sQ0FBQzlQLENBQUMsQ0FBQyxFQUFFZ1EsTUFBTSxDQUFDO01BQ2pDQSxNQUFNLElBQUksSUFBSSxDQUFDRixNQUFNLENBQUM5UCxDQUFDLENBQUMsQ0FBQ0MsTUFBTTtBQUNuQztJQUNBLElBQUksQ0FBQzZQLE1BQU0sR0FBRyxFQUFFO0FBQ2hCLFdBQU8vSSxLQUFLO0FBQ2hCO0FBQ0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0ltSixFQUFBQSxJQUFJQSxHQUFHO0FBQ0gsUUFBSSxDQUFDTixLQUFLLENBQUMxSixJQUFJLENBQUM7TUFBRTRKLE1BQU0sRUFBRSxJQUFJLENBQUNBLE1BQU07TUFBRTlGLEdBQUcsRUFBRSxJQUFJLENBQUNBLEdBQUFBO0FBQUksS0FBQyxDQUFDO0lBQ3ZELElBQUksQ0FBQzhGLE1BQU0sR0FBRyxFQUFFO0lBQ2hCLElBQUksQ0FBQzlGLEdBQUcsR0FBRyxFQUFFO0FBQ2IsV0FBTyxJQUFJO0FBQ2Y7QUFDQTtBQUNKO0FBQ0E7QUFDQTtBQUNJbUcsRUFBQUEsSUFBSUEsR0FBRztBQUNIO0FBQ0EsUUFBSUMsS0FBSyxHQUFHLElBQUksQ0FBQzdILE1BQU0sRUFBRTtBQUN6QjtJQUNBLElBQUk4SCxJQUFJLEdBQUcsSUFBSSxDQUFDVCxLQUFLLENBQUNVLEdBQUcsRUFBRTtJQUMzQixJQUFJLENBQUNELElBQUksRUFDTCxNQUFNLElBQUlwTSxLQUFLLENBQUMsaUNBQWlDLENBQUM7QUFDdEQsUUFBSSxDQUFDNkwsTUFBTSxHQUFHTyxJQUFJLENBQUNQLE1BQU07QUFDekIsUUFBSSxDQUFDOUYsR0FBRyxHQUFHcUcsSUFBSSxDQUFDckcsR0FBRztBQUNuQjtBQUNBLFFBQUksQ0FBQ3VHLE1BQU0sQ0FBQ0gsS0FBSyxDQUFDN0ksVUFBVSxDQUFDO0FBQzdCLFdBQU8sSUFBSSxDQUFDaUosR0FBRyxDQUFDSixLQUFLLENBQUM7QUFDMUI7QUFDQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJSyxFQUFBQSxHQUFHQSxDQUFDQyxPQUFPLEVBQUV6SixJQUFJLEVBQUU7QUFDZixXQUFPLElBQUksQ0FBQ3NKLE1BQU0sQ0FBQyxDQUFFRyxPQUFPLElBQUksQ0FBQyxHQUFJekosSUFBSSxNQUFNLENBQUMsQ0FBQztBQUNyRDtBQUNBO0FBQ0o7QUFDQTtFQUNJdUosR0FBR0EsQ0FBQ0osS0FBSyxFQUFFO0FBQ1AsUUFBSSxJQUFJLENBQUNwRyxHQUFHLENBQUMvSixNQUFNLEVBQUU7QUFDakIsVUFBSSxDQUFDNlAsTUFBTSxDQUFDNUosSUFBSSxDQUFDLElBQUkwSSxVQUFVLENBQUMsSUFBSSxDQUFDNUUsR0FBRyxDQUFDLENBQUM7TUFDMUMsSUFBSSxDQUFDQSxHQUFHLEdBQUcsRUFBRTtBQUNqQjtBQUNBLFFBQUksQ0FBQzhGLE1BQU0sQ0FBQzVKLElBQUksQ0FBQ2tLLEtBQUssQ0FBQztBQUN2QixXQUFPLElBQUk7QUFDZjtBQUNBO0FBQ0o7QUFDQTtFQUNJRyxNQUFNQSxDQUFDeEssS0FBSyxFQUFFO0lBQ1ZwQixZQUFZLENBQUNvQixLQUFLLENBQUM7QUFDbkI7SUFDQSxPQUFPQSxLQUFLLEdBQUcsSUFBSSxFQUFFO01BQ2pCLElBQUksQ0FBQ2lFLEdBQUcsQ0FBQzlELElBQUksQ0FBRUgsS0FBSyxHQUFHLElBQUksR0FBSSxJQUFJLENBQUM7TUFDcENBLEtBQUssR0FBR0EsS0FBSyxLQUFLLENBQUM7QUFDdkI7QUFDQSxRQUFJLENBQUNpRSxHQUFHLENBQUM5RCxJQUFJLENBQUNILEtBQUssQ0FBQztBQUNwQixXQUFPLElBQUk7QUFDZjtBQUNBO0FBQ0o7QUFDQTtFQUNJNEssS0FBS0EsQ0FBQzVLLEtBQUssRUFBRTtJQUNUeEIsV0FBVyxDQUFDd0IsS0FBSyxDQUFDO0FBQ2xCeUcsSUFBQUEsYUFBYSxDQUFDekcsS0FBSyxFQUFFLElBQUksQ0FBQ2lFLEdBQUcsQ0FBQztBQUM5QixXQUFPLElBQUk7QUFDZjtBQUNBO0FBQ0o7QUFDQTtFQUNJNEcsSUFBSUEsQ0FBQzdLLEtBQUssRUFBRTtJQUNSLElBQUksQ0FBQ2lFLEdBQUcsQ0FBQzlELElBQUksQ0FBQ0gsS0FBSyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDNUIsV0FBTyxJQUFJO0FBQ2Y7QUFDQTtBQUNKO0FBQ0E7RUFDSWdCLEtBQUtBLENBQUNoQixLQUFLLEVBQUU7SUFDVCxJQUFJLENBQUN3SyxNQUFNLENBQUN4SyxLQUFLLENBQUN3QixVQUFVLENBQUMsQ0FBQztBQUM5QixXQUFPLElBQUksQ0FBQ2lKLEdBQUcsQ0FBQ3pLLEtBQUssQ0FBQztBQUMxQjtBQUNBO0FBQ0o7QUFDQTtFQUNJOEssTUFBTUEsQ0FBQzlLLEtBQUssRUFBRTtJQUNWLElBQUlxSyxLQUFLLEdBQUcsSUFBSSxDQUFDVCxXQUFXLENBQUNtQixNQUFNLENBQUMvSyxLQUFLLENBQUM7SUFDMUMsSUFBSSxDQUFDd0ssTUFBTSxDQUFDSCxLQUFLLENBQUM3SSxVQUFVLENBQUMsQ0FBQztBQUM5QixXQUFPLElBQUksQ0FBQ2lKLEdBQUcsQ0FBQ0osS0FBSyxDQUFDO0FBQzFCO0FBQ0E7QUFDSjtBQUNBO0VBQ0lXLEtBQUtBLENBQUNoTCxLQUFLLEVBQUU7SUFDVG5CLGFBQWEsQ0FBQ21CLEtBQUssQ0FBQztBQUNwQixRQUFJcUssS0FBSyxHQUFHLElBQUl4QixVQUFVLENBQUMsQ0FBQyxDQUFDO0FBQzdCLFFBQUkvQixRQUFRLENBQUN1RCxLQUFLLENBQUNZLE1BQU0sQ0FBQyxDQUFDQyxVQUFVLENBQUMsQ0FBQyxFQUFFbEwsS0FBSyxFQUFFLElBQUksQ0FBQztBQUNyRCxXQUFPLElBQUksQ0FBQ3lLLEdBQUcsQ0FBQ0osS0FBSyxDQUFDO0FBQzFCO0FBQ0E7QUFDSjtBQUNBO0VBQ0ljLE1BQU1BLENBQUNuTCxLQUFLLEVBQUU7QUFDVixRQUFJcUssS0FBSyxHQUFHLElBQUl4QixVQUFVLENBQUMsQ0FBQyxDQUFDO0FBQzdCLFFBQUkvQixRQUFRLENBQUN1RCxLQUFLLENBQUNZLE1BQU0sQ0FBQyxDQUFDRyxVQUFVLENBQUMsQ0FBQyxFQUFFcEwsS0FBSyxFQUFFLElBQUksQ0FBQztBQUNyRCxXQUFPLElBQUksQ0FBQ3lLLEdBQUcsQ0FBQ0osS0FBSyxDQUFDO0FBQzFCO0FBQ0E7QUFDSjtBQUNBO0VBQ0lnQixPQUFPQSxDQUFDckwsS0FBSyxFQUFFO0lBQ1hwQixZQUFZLENBQUNvQixLQUFLLENBQUM7QUFDbkIsUUFBSXFLLEtBQUssR0FBRyxJQUFJeEIsVUFBVSxDQUFDLENBQUMsQ0FBQztBQUM3QixRQUFJL0IsUUFBUSxDQUFDdUQsS0FBSyxDQUFDWSxNQUFNLENBQUMsQ0FBQ0ssU0FBUyxDQUFDLENBQUMsRUFBRXRMLEtBQUssRUFBRSxJQUFJLENBQUM7QUFDcEQsV0FBTyxJQUFJLENBQUN5SyxHQUFHLENBQUNKLEtBQUssQ0FBQztBQUMxQjtBQUNBO0FBQ0o7QUFDQTtFQUNJa0IsUUFBUUEsQ0FBQ3ZMLEtBQUssRUFBRTtJQUNaeEIsV0FBVyxDQUFDd0IsS0FBSyxDQUFDO0FBQ2xCLFFBQUlxSyxLQUFLLEdBQUcsSUFBSXhCLFVBQVUsQ0FBQyxDQUFDLENBQUM7QUFDN0IsUUFBSS9CLFFBQVEsQ0FBQ3VELEtBQUssQ0FBQ1ksTUFBTSxDQUFDLENBQUM3QyxRQUFRLENBQUMsQ0FBQyxFQUFFcEksS0FBSyxFQUFFLElBQUksQ0FBQztBQUNuRCxXQUFPLElBQUksQ0FBQ3lLLEdBQUcsQ0FBQ0osS0FBSyxDQUFDO0FBQzFCO0FBQ0E7QUFDSjtBQUNBO0VBQ0ltQixNQUFNQSxDQUFDeEwsS0FBSyxFQUFFO0lBQ1Z4QixXQUFXLENBQUN3QixLQUFLLENBQUM7QUFDbEI7SUFDQUEsS0FBSyxHQUFHLENBQUVBLEtBQUssSUFBSSxDQUFDLEdBQUtBLEtBQUssSUFBSSxFQUFHLE1BQU0sQ0FBQztBQUM1Q3lHLElBQUFBLGFBQWEsQ0FBQ3pHLEtBQUssRUFBRSxJQUFJLENBQUNpRSxHQUFHLENBQUM7QUFDOUIsV0FBTyxJQUFJO0FBQ2Y7QUFDQTtBQUNKO0FBQ0E7RUFDSXdILFFBQVFBLENBQUN6TCxLQUFLLEVBQUU7QUFDWixRQUFJcUssS0FBSyxHQUFHLElBQUl4QixVQUFVLENBQUMsQ0FBQyxDQUFDO0FBQUU2QyxNQUFBQSxJQUFJLEdBQUcsSUFBSTVFLFFBQVEsQ0FBQ3VELEtBQUssQ0FBQ1ksTUFBTSxDQUFDO0FBQUVVLE1BQUFBLEVBQUUsR0FBR25ELFVBQVUsQ0FBQ1AsR0FBRyxDQUFDakksS0FBSyxDQUFDO0lBQzVGMEwsSUFBSSxDQUFDdEQsUUFBUSxDQUFDLENBQUMsRUFBRXVELEVBQUUsQ0FBQ3JILEVBQUUsRUFBRSxJQUFJLENBQUM7SUFDN0JvSCxJQUFJLENBQUN0RCxRQUFRLENBQUMsQ0FBQyxFQUFFdUQsRUFBRSxDQUFDcEgsRUFBRSxFQUFFLElBQUksQ0FBQztBQUM3QixXQUFPLElBQUksQ0FBQ2tHLEdBQUcsQ0FBQ0osS0FBSyxDQUFDO0FBQzFCO0FBQ0E7QUFDSjtBQUNBO0VBQ0l1QixPQUFPQSxDQUFDNUwsS0FBSyxFQUFFO0FBQ1gsUUFBSXFLLEtBQUssR0FBRyxJQUFJeEIsVUFBVSxDQUFDLENBQUMsQ0FBQztBQUFFNkMsTUFBQUEsSUFBSSxHQUFHLElBQUk1RSxRQUFRLENBQUN1RCxLQUFLLENBQUNZLE1BQU0sQ0FBQztBQUFFVSxNQUFBQSxFQUFFLEdBQUduRCxVQUFVLENBQUNMLElBQUksQ0FBQ25JLEtBQUssQ0FBQztJQUM3RjBMLElBQUksQ0FBQ3RELFFBQVEsQ0FBQyxDQUFDLEVBQUV1RCxFQUFFLENBQUNySCxFQUFFLEVBQUUsSUFBSSxDQUFDO0lBQzdCb0gsSUFBSSxDQUFDdEQsUUFBUSxDQUFDLENBQUMsRUFBRXVELEVBQUUsQ0FBQ3BILEVBQUUsRUFBRSxJQUFJLENBQUM7QUFDN0IsV0FBTyxJQUFJLENBQUNrRyxHQUFHLENBQUNKLEtBQUssQ0FBQztBQUMxQjtBQUNBO0FBQ0o7QUFDQTtFQUNJd0IsS0FBS0EsQ0FBQzdMLEtBQUssRUFBRTtBQUNULFFBQUkyTCxFQUFFLEdBQUduRCxVQUFVLENBQUNQLEdBQUcsQ0FBQ2pJLEtBQUssQ0FBQztBQUM5QnFFLElBQUFBLGFBQWEsQ0FBQ3NILEVBQUUsQ0FBQ3JILEVBQUUsRUFBRXFILEVBQUUsQ0FBQ3BILEVBQUUsRUFBRSxJQUFJLENBQUNOLEdBQUcsQ0FBQztBQUNyQyxXQUFPLElBQUk7QUFDZjtBQUNBO0FBQ0o7QUFDQTtFQUNJNkgsTUFBTUEsQ0FBQzlMLEtBQUssRUFBRTtBQUNWLFFBQUkyTCxFQUFFLEdBQUduRCxVQUFVLENBQUNQLEdBQUcsQ0FBQ2pJLEtBQUssQ0FBQztBQUM5QjtBQUNBK0wsTUFBQUEsSUFBSSxHQUFHSixFQUFFLENBQUNwSCxFQUFFLElBQUksRUFBRTtBQUFFRCxNQUFBQSxFQUFFLEdBQUlxSCxFQUFFLENBQUNySCxFQUFFLElBQUksQ0FBQyxHQUFJeUgsSUFBSTtBQUFFeEgsTUFBQUEsRUFBRSxHQUFHLENBQUVvSCxFQUFFLENBQUNwSCxFQUFFLElBQUksQ0FBQyxHQUFLb0gsRUFBRSxDQUFDckgsRUFBRSxLQUFLLEVBQUcsSUFBSXlILElBQUk7SUFDekYxSCxhQUFhLENBQUNDLEVBQUUsRUFBRUMsRUFBRSxFQUFFLElBQUksQ0FBQ04sR0FBRyxDQUFDO0FBQy9CLFdBQU8sSUFBSTtBQUNmO0FBQ0E7QUFDSjtBQUNBO0VBQ0krSCxNQUFNQSxDQUFDaE0sS0FBSyxFQUFFO0FBQ1YsUUFBSTJMLEVBQUUsR0FBR25ELFVBQVUsQ0FBQ0wsSUFBSSxDQUFDbkksS0FBSyxDQUFDO0FBQy9CcUUsSUFBQUEsYUFBYSxDQUFDc0gsRUFBRSxDQUFDckgsRUFBRSxFQUFFcUgsRUFBRSxDQUFDcEgsRUFBRSxFQUFFLElBQUksQ0FBQ04sR0FBRyxDQUFDO0FBQ3JDLFdBQU8sSUFBSTtBQUNmO0FBQ0o7QUFDTyxNQUFNZ0ksWUFBWSxDQUFDO0FBQ3RCaEosRUFBQUEsV0FBV0EsQ0FBQ2dCLEdBQUcsRUFBRWlJLFdBQVcsRUFBRTtBQUMxQixRQUFJLENBQUNDLFFBQVEsR0FBR3RJLFlBQVksQ0FBQztBQUM3QjtBQUNSO0FBQ0E7QUFDUSxRQUFJLENBQUMyRyxNQUFNLEdBQUc5RCxZQUFZLENBQUM7SUFDM0IsSUFBSSxDQUFDekMsR0FBRyxHQUFHQSxHQUFHO0FBQ2QsUUFBSSxDQUFDK0YsR0FBRyxHQUFHL0YsR0FBRyxDQUFDL0osTUFBTTtJQUNyQixJQUFJLENBQUNnSyxHQUFHLEdBQUcsQ0FBQztBQUNaLFFBQUksQ0FBQ3dILElBQUksR0FBRyxJQUFJNUUsUUFBUSxDQUFDN0MsR0FBRyxDQUFDZ0gsTUFBTSxFQUFFaEgsR0FBRyxDQUFDbUksVUFBVSxFQUFFbkksR0FBRyxDQUFDekMsVUFBVSxDQUFDO0FBQ3BFLFFBQUksQ0FBQzBLLFdBQVcsR0FBR0EsV0FBVyxLQUFLLElBQUksSUFBSUEsV0FBVyxLQUFLLEtBQUssQ0FBQyxHQUFHQSxXQUFXLEdBQUcsSUFBSUcsV0FBVyxFQUFFO0FBQ3ZHO0FBQ0E7QUFDSjtBQUNBO0FBQ0kzQixFQUFBQSxHQUFHQSxHQUFHO0FBQ0YsUUFBSUEsR0FBRyxHQUFHLElBQUksQ0FBQ0YsTUFBTSxFQUFFO01BQUVHLE9BQU8sR0FBR0QsR0FBRyxLQUFLLENBQUM7TUFBRTRCLFFBQVEsR0FBRzVCLEdBQUcsR0FBRyxDQUFDO0lBQ2hFLElBQUlDLE9BQU8sSUFBSSxDQUFDLElBQUkyQixRQUFRLEdBQUcsQ0FBQyxJQUFJQSxRQUFRLEdBQUcsQ0FBQyxFQUM1QyxNQUFNLElBQUlwTyxLQUFLLENBQUMsd0JBQXdCLEdBQUd5TSxPQUFPLEdBQUcsYUFBYSxHQUFHMkIsUUFBUSxDQUFDO0FBQ2xGLFdBQU8sQ0FBQzNCLE9BQU8sRUFBRTJCLFFBQVEsQ0FBQztBQUM5QjtBQUNBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJQyxFQUFBQSxJQUFJQSxDQUFDRCxRQUFRLEVBQUUzQixPQUFPLEVBQUU7QUFDcEIsUUFBSTZCLEtBQUssR0FBRyxJQUFJLENBQUN0SSxHQUFHO0FBQ3BCLFlBQVFvSSxRQUFRO01BQ1osS0FBSzVDLFFBQVEsQ0FBQytDLE1BQU07UUFDaEIsT0FBTyxJQUFJLENBQUN4SSxHQUFHLENBQUMsSUFBSSxDQUFDQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLElBQUksRUFBRTtBQUNoQztBQUFBO0FBRUo7QUFDSjtBQUNBO01BQ0EsS0FBS3dGLFFBQVEsQ0FBQ2dELEtBQUs7UUFDZixJQUFJLENBQUN4SSxHQUFHLElBQUksQ0FBQztBQUNqQjtBQUNBO01BQ0EsS0FBS3dGLFFBQVEsQ0FBQ2lELEtBQUs7UUFDZixJQUFJLENBQUN6SSxHQUFHLElBQUksQ0FBQztBQUNiO01BQ0osS0FBS3dGLFFBQVEsQ0FBQ2tELGVBQWU7QUFDekIsWUFBSTVDLEdBQUcsR0FBRyxJQUFJLENBQUNRLE1BQU0sRUFBRTtRQUN2QixJQUFJLENBQUN0RyxHQUFHLElBQUk4RixHQUFHO0FBQ2Y7TUFDSixLQUFLTixRQUFRLENBQUNtRCxVQUFVO1FBQ3BCLFNBQVM7VUFDTCxNQUFNLENBQUNDLEVBQUUsRUFBRUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDckMsR0FBRyxFQUFFO0FBQzNCLGNBQUlxQyxFQUFFLEtBQUtyRCxRQUFRLENBQUNzRCxRQUFRLEVBQUU7QUFDMUIsZ0JBQUlyQyxPQUFPLEtBQUs5USxTQUFTLElBQUlpVCxFQUFFLEtBQUtuQyxPQUFPLEVBQUU7QUFDekMsb0JBQU0sSUFBSXpNLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQztBQUM1QztBQUNBO0FBQ0o7QUFDQSxjQUFJLENBQUNxTyxJQUFJLENBQUNRLEVBQUUsRUFBRUQsRUFBRSxDQUFDO0FBQ3JCO0FBQ0E7QUFDSjtBQUNJLGNBQU0sSUFBSTVPLEtBQUssQ0FBQyxzQkFBc0IsR0FBR29PLFFBQVEsQ0FBQztBQUMxRDtJQUNBLElBQUksQ0FBQ25JLFlBQVksRUFBRTtJQUNuQixPQUFPLElBQUksQ0FBQ0YsR0FBRyxDQUFDZ0osUUFBUSxDQUFDVCxLQUFLLEVBQUUsSUFBSSxDQUFDdEksR0FBRyxDQUFDO0FBQzdDO0FBQ0E7QUFDSjtBQUNBO0FBQ0lDLEVBQUFBLFlBQVlBLEdBQUc7QUFDWCxRQUFJLElBQUksQ0FBQ0QsR0FBRyxHQUFHLElBQUksQ0FBQzhGLEdBQUcsRUFDbkIsTUFBTSxJQUFJa0QsVUFBVSxDQUFDLGVBQWUsQ0FBQztBQUM3QztBQUNBO0FBQ0o7QUFDQTtBQUNJdEMsRUFBQUEsS0FBS0EsR0FBRztBQUNKLFdBQU8sSUFBSSxDQUFDSixNQUFNLEVBQUUsR0FBRyxDQUFDO0FBQzVCO0FBQ0E7QUFDSjtBQUNBO0FBQ0lnQixFQUFBQSxNQUFNQSxHQUFHO0FBQ0wsUUFBSTJCLEdBQUcsR0FBRyxJQUFJLENBQUMzQyxNQUFNLEVBQUU7QUFDdkI7SUFDQSxPQUFRMkMsR0FBRyxLQUFLLENBQUMsR0FBSSxFQUFFQSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ25DO0FBQ0E7QUFDSjtBQUNBO0FBQ0l0QixFQUFBQSxLQUFLQSxHQUFHO0lBQ0osT0FBT3JELFVBQVUsQ0FBQzFELEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQ3FILFFBQVEsRUFBRSxDQUFDO0FBQzdDO0FBQ0E7QUFDSjtBQUNBO0FBQ0lILEVBQUFBLE1BQU1BLEdBQUc7SUFDTCxPQUFPeEQsVUFBVSxDQUFDSCxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM4RCxRQUFRLEVBQUUsQ0FBQztBQUM5QztBQUNBO0FBQ0o7QUFDQTtBQUNJTCxFQUFBQSxNQUFNQSxHQUFHO0lBQ0wsSUFBSSxDQUFDeEgsRUFBRSxFQUFFQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUM0SCxRQUFRLEVBQUU7QUFDOUI7QUFDQSxRQUFJaUIsQ0FBQyxHQUFHLEVBQUU5SSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ2pCQSxJQUFBQSxFQUFFLEdBQUcsQ0FBRUEsRUFBRSxLQUFLLENBQUMsR0FBSyxDQUFDQyxFQUFFLEdBQUcsQ0FBQyxLQUFLLEVBQUcsSUFBSTZJLENBQUM7QUFDeEM3SSxJQUFBQSxFQUFFLEdBQUlBLEVBQUUsS0FBSyxDQUFDLEdBQUk2SSxDQUFDO0FBQ25CLFdBQU81RSxVQUFVLENBQUMxRCxHQUFHLENBQUNSLEVBQUUsRUFBRUMsRUFBRSxDQUFDO0FBQ2pDO0FBQ0E7QUFDSjtBQUNBO0FBQ0lzRyxFQUFBQSxJQUFJQSxHQUFHO0lBQ0gsSUFBSSxDQUFDdkcsRUFBRSxFQUFFQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUM0SCxRQUFRLEVBQUU7QUFDOUIsV0FBTzdILEVBQUUsS0FBSyxDQUFDLElBQUlDLEVBQUUsS0FBSyxDQUFDO0FBQy9CO0FBQ0E7QUFDSjtBQUNBO0FBQ0k4RyxFQUFBQSxPQUFPQSxHQUFHO0FBQ04sV0FBTyxJQUFJLENBQUNLLElBQUksQ0FBQzJCLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQ25KLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQztBQUN6RDtBQUNBO0FBQ0o7QUFDQTtBQUNJcUgsRUFBQUEsUUFBUUEsR0FBRztBQUNQLFdBQU8sSUFBSSxDQUFDRyxJQUFJLENBQUN4RCxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUNoRSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUM7QUFDeEQ7QUFDQTtBQUNKO0FBQ0E7QUFDSTBILEVBQUFBLE9BQU9BLEdBQUc7QUFDTixXQUFPcEQsVUFBVSxDQUFDSCxJQUFJLENBQUMsSUFBSSxDQUFDa0QsUUFBUSxFQUFFLEVBQUUsSUFBSSxDQUFDQSxRQUFRLEVBQUUsQ0FBQztBQUM1RDtBQUNBO0FBQ0o7QUFDQTtBQUNJRSxFQUFBQSxRQUFRQSxHQUFHO0FBQ1AsV0FBT2pELFVBQVUsQ0FBQzFELEdBQUcsQ0FBQyxJQUFJLENBQUN5RyxRQUFRLEVBQUUsRUFBRSxJQUFJLENBQUNBLFFBQVEsRUFBRSxDQUFDO0FBQzNEO0FBQ0E7QUFDSjtBQUNBO0FBQ0lQLEVBQUFBLEtBQUtBLEdBQUc7QUFDSixXQUFPLElBQUksQ0FBQ1UsSUFBSSxDQUFDNEIsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDcEosR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDO0FBQzFEO0FBQ0E7QUFDSjtBQUNBO0FBQ0lpSCxFQUFBQSxNQUFNQSxHQUFHO0FBQ0wsV0FBTyxJQUFJLENBQUNPLElBQUksQ0FBQzZCLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQ3JKLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQztBQUMxRDtBQUNBO0FBQ0o7QUFDQTtBQUNJbEQsRUFBQUEsS0FBS0EsR0FBRztBQUNKLFFBQUlnSixHQUFHLEdBQUcsSUFBSSxDQUFDUSxNQUFNLEVBQUU7TUFBRWdDLEtBQUssR0FBRyxJQUFJLENBQUN0SSxHQUFHO0lBQ3pDLElBQUksQ0FBQ0EsR0FBRyxJQUFJOEYsR0FBRztJQUNmLElBQUksQ0FBQzdGLFlBQVksRUFBRTtJQUNuQixPQUFPLElBQUksQ0FBQ0YsR0FBRyxDQUFDZ0osUUFBUSxDQUFDVCxLQUFLLEVBQUVBLEtBQUssR0FBR3hDLEdBQUcsQ0FBQztBQUNoRDtBQUNBO0FBQ0o7QUFDQTtBQUNJYyxFQUFBQSxNQUFNQSxHQUFHO0lBQ0wsT0FBTyxJQUFJLENBQUNvQixXQUFXLENBQUNzQixNQUFNLENBQUMsSUFBSSxDQUFDeE0sS0FBSyxFQUFFLENBQUM7QUFDaEQ7QUFDSjs7QUN0YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDTyxTQUFTeU0sYUFBYUEsQ0FBQzdNLE9BQU8sRUFBRXZCLFFBQVEsRUFBRXFPLFFBQVEsRUFBRUMsS0FBSyxFQUFFO0FBQzlELE1BQUlDLEVBQUU7RUFDTixPQUFPO0lBQ0h2TyxRQUFRO0lBQ1JxTyxRQUFRO0lBQ1IsSUFBSUMsS0FBS0EsR0FBRztNQUNSLElBQUksQ0FBQ0MsRUFBRSxFQUFFO1FBQ0wsTUFBTTNULENBQUMsR0FBSSxPQUFPMFQsS0FBSyxJQUFJLFVBQVUsR0FBR0EsS0FBSyxFQUFFLEdBQUdBLEtBQU07QUFDeEQxVCxRQUFBQSxDQUFDLENBQUNHLElBQUksR0FBR2lGLFFBQVEsQ0FBQ3dPLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQ3RELEdBQUcsRUFBRTtBQUNsQ3RRLFFBQUFBLENBQUMsQ0FBQzZULFFBQVEsT0FBQTlMLE1BQUEsQ0FBTzNDLFFBQVEsRUFBRztBQUM1QnVPLFFBQUFBLEVBQUUsR0FBR2hOLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDNkMsWUFBWSxDQUFDLENBQUN6SixDQUFDLENBQUMsQ0FBQyxDQUFDOFQsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2pEO0FBQ0EsYUFBT0gsRUFBRTtLQUNaO0FBQ0RoTixJQUFBQSxPQUFBQTtHQUNIO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNvTix3QkFBd0JBLENBQUNDLFNBQVMsRUFBRTtBQUNoRCxRQUFNdk8sU0FBUyxHQUFHdU8sU0FBUyxDQUFDTixLQUFLLENBQUNqTyxTQUFTO0FBQzNDLFFBQU13TyxTQUFTLEdBQUd4USxNQUFNLENBQUNtQyxNQUFNLENBQUMsSUFBSSxDQUFDO0FBQ3JDcU8sRUFBQUEsU0FBUyxDQUFDeE8sU0FBUyxDQUFDLEdBQUd5TyxrQkFBa0IsQ0FBQ0YsU0FBUyxDQUFDO0VBQ3BELE9BQU8sQ0FBQ0MsU0FBUyxFQUFFLE1BQU1BLFNBQVMsQ0FBQ3hPLFNBQVMsQ0FBQyxDQUFDO0FBQ2xEO0FBQ0EsU0FBU3lPLGtCQUFrQkEsQ0FBQ0MsR0FBRyxFQUFFO0FBQzdCLFFBQU1ULEtBQUssR0FBR1MsR0FBRyxDQUFDVCxLQUFLO0VBQ3ZCLElBQUlBLEtBQUssQ0FBQ1UsUUFBUSxFQUFFO0FBQ2hCLFdBQU8sRUFBRTtBQUNiO0FBQ0EsTUFBSVYsS0FBSyxDQUFDVyxPQUFPLEtBQUt6VSxTQUFTLEVBQUU7SUFDN0IsT0FBTzhULEtBQUssQ0FBQ1csT0FBTztBQUN4QjtFQUNBLFFBQVFYLEtBQUssQ0FBQ1ksSUFBSTtBQUNkLFNBQUssTUFBTTtNQUNQLE9BQU9aLEtBQUssQ0FBQ2EsQ0FBQyxDQUFDN1EsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDOEIsRUFBRTtBQUMvQixTQUFLLFFBQVE7TUFDVCxPQUFPMEosZUFBZSxDQUFDd0UsS0FBSyxDQUFDYSxDQUFDLEVBQUViLEtBQUssQ0FBQ2MsQ0FBQyxDQUFDO0FBQzVDLFNBQUssU0FBUztBQUNWO0FBQ0EsWUFBTUQsQ0FBQyxHQUFHYixLQUFLLENBQUNhLENBQUM7QUFBRXhPLFFBQUFBLEtBQUssR0FBRyxJQUFJd08sQ0FBQyxFQUFFO0FBQ2xDLGFBQU9BLENBQUMsQ0FBQ0UsWUFBWSxHQUFHRixDQUFDLENBQUNFLFlBQVksQ0FBQ0MsV0FBVyxDQUFDM08sS0FBSyxDQUFDLEdBQUdBLEtBQUs7QUFDckUsU0FBSyxLQUFLO0FBQ04sWUFBTSw2Q0FBNkM7QUFDM0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVM0TyxtQkFBbUJBLENBQUNDLGFBQWEsRUFBRWxCLEtBQUssRUFBRTtBQUN0RCxNQUFJLENBQUNBLEtBQUssQ0FBQ1UsUUFBUSxLQUFLVixLQUFLLENBQUNZLElBQUksSUFBSSxNQUFNLElBQUlaLEtBQUssQ0FBQ1ksSUFBSSxJQUFJLFFBQVEsQ0FBQyxFQUFFO0FBQ3JFO0FBQ0EsU0FBSyxJQUFJdFUsQ0FBQyxHQUFHNFUsYUFBYSxDQUFDM1UsTUFBTSxHQUFHLENBQUMsRUFBRUQsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFQSxDQUFDLEVBQUU7TUFDaEQsSUFBSTRVLGFBQWEsQ0FBQzVVLENBQUMsQ0FBQyxDQUFDd0YsRUFBRSxJQUFJa08sS0FBSyxDQUFDbE8sRUFBRSxFQUFFO0FBQ2pDLGVBQU8sQ0FBQ29QLGFBQWEsQ0FBQzVVLENBQUMsQ0FBQyxDQUFDO0FBQzdCO0FBQ0o7QUFDQSxXQUFPLEVBQUU7QUFDYjtBQUNBLFNBQU80VSxhQUFhLENBQUNDLE1BQU0sQ0FBRUMsRUFBRSxJQUFLQSxFQUFFLENBQUN0UCxFQUFFLEtBQUtrTyxLQUFLLENBQUNsTyxFQUFFLENBQUM7QUFDM0Q7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUl1UCxRQUFRLEdBQUcsa0VBQWtFLENBQUNuQixLQUFLLENBQUMsRUFBRSxDQUFDO0FBQzNGO0FBQ0EsSUFBSW9CLFFBQVEsR0FBRyxFQUFFO0FBQ2pCLEtBQUssSUFBSWhWLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBRytVLFFBQVEsQ0FBQzlVLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEVBQ3BDZ1YsUUFBUSxDQUFDRCxRQUFRLENBQUMvVSxDQUFDLENBQUMsQ0FBQ2lWLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHalYsQ0FBQztBQUMzQztBQUNBZ1YsUUFBUSxDQUFDLEdBQUcsQ0FBQ0MsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUdGLFFBQVEsQ0FBQ2hULE9BQU8sQ0FBQyxHQUFHLENBQUM7QUFDbkRpVCxRQUFRLENBQUMsR0FBRyxDQUFDQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBR0YsUUFBUSxDQUFDaFQsT0FBTyxDQUFDLEdBQUcsQ0FBQztBQUM1QyxNQUFNbVQsV0FBVyxHQUFHO0FBQ3ZCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSXJLLEdBQUdBLENBQUNzSyxTQUFTLEVBQUU7QUFDWDtJQUNBLElBQUlDLEVBQUUsR0FBSUQsU0FBUyxDQUFDbFYsTUFBTSxHQUFHLENBQUMsR0FBSSxDQUFDO0FBQ25DLFFBQUlrVixTQUFTLENBQUNBLFNBQVMsQ0FBQ2xWLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEVBQ3RDbVYsRUFBRSxJQUFJLENBQUMsQ0FBQyxLQUNQLElBQUlELFNBQVMsQ0FBQ0EsU0FBUyxDQUFDbFYsTUFBTSxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsRUFDM0NtVixFQUFFLElBQUksQ0FBQztBQUNYLFFBQUlyTyxLQUFLLEdBQUcsSUFBSTZILFVBQVUsQ0FBQ3dHLEVBQUUsQ0FBQztBQUFFQyxNQUFBQSxPQUFPLEdBQUcsQ0FBQztBQUFFO0FBQzdDQyxNQUFBQSxRQUFRLEdBQUcsQ0FBQztBQUFFO01BQ2QzTCxDQUFDO0FBQUU7TUFDSDRMLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDTixTQUFLLElBQUl2VixDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdtVixTQUFTLENBQUNsVixNQUFNLEVBQUVELENBQUMsRUFBRSxFQUFFO01BQ3ZDMkosQ0FBQyxHQUFHcUwsUUFBUSxDQUFDRyxTQUFTLENBQUNGLFVBQVUsQ0FBQ2pWLENBQUMsQ0FBQyxDQUFDO01BQ3JDLElBQUkySixDQUFDLEtBQUsvSixTQUFTLEVBQUU7UUFDakIsUUFBUXVWLFNBQVMsQ0FBQ25WLENBQUMsQ0FBQztBQUNoQjtBQUNBLGVBQUssR0FBRztBQUNKc1YsWUFBQUEsUUFBUSxHQUFHLENBQUM7QUFBRTtBQUNsQjtBQUNBLGVBQUssSUFBSTtBQUNULGVBQUssSUFBSTtBQUNULGVBQUssSUFBSTtBQUNULGVBQUssR0FBRztBQUNKO0FBQVU7QUFDZDtZQUNJLE1BQU1yUixLQUFLLENBQUMsd0JBQXdCLENBQUM7QUFDN0M7QUFDSjtBQUNBLGNBQVFxUixRQUFRO0FBQ1osYUFBSyxDQUFDO0FBQ0ZDLFVBQUFBLENBQUMsR0FBRzVMLENBQUM7QUFDTDJMLFVBQUFBLFFBQVEsR0FBRyxDQUFDO0FBQ1o7QUFDSixhQUFLLENBQUM7QUFDRnZPLFVBQUFBLEtBQUssQ0FBQ3NPLE9BQU8sRUFBRSxDQUFDLEdBQUlFLENBQUMsSUFBSSxDQUFDLEdBQUssQ0FBQzVMLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBRTtBQUM3QzRMLFVBQUFBLENBQUMsR0FBRzVMLENBQUM7QUFDTDJMLFVBQUFBLFFBQVEsR0FBRyxDQUFDO0FBQ1o7QUFDSixhQUFLLENBQUM7QUFDRnZPLFVBQUFBLEtBQUssQ0FBQ3NPLE9BQU8sRUFBRSxDQUFDLEdBQUksQ0FBQ0UsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLEdBQUssQ0FBQzVMLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBRTtBQUNwRDRMLFVBQUFBLENBQUMsR0FBRzVMLENBQUM7QUFDTDJMLFVBQUFBLFFBQVEsR0FBRyxDQUFDO0FBQ1o7QUFDSixhQUFLLENBQUM7QUFDRnZPLFVBQUFBLEtBQUssQ0FBQ3NPLE9BQU8sRUFBRSxDQUFDLEdBQUksQ0FBQ0UsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUk1TCxDQUFDO0FBQ3JDMkwsVUFBQUEsUUFBUSxHQUFHLENBQUM7QUFDWjtBQUNSO0FBQ0o7SUFDQSxJQUFJQSxRQUFRLElBQUksQ0FBQyxFQUNiLE1BQU1yUixLQUFLLENBQUMsd0JBQXdCLENBQUM7QUFDekMsV0FBTzhDLEtBQUssQ0FBQ2lNLFFBQVEsQ0FBQyxDQUFDLEVBQUVxQyxPQUFPLENBQUM7R0FDcEM7QUFDRDtBQUNKO0FBQ0E7RUFDSXJILEdBQUdBLENBQUNqSCxLQUFLLEVBQUU7SUFDUCxJQUFJeU8sTUFBTSxHQUFHLEVBQUU7QUFBRUYsTUFBQUEsUUFBUSxHQUFHLENBQUM7QUFBRTtNQUMvQjNMLENBQUM7QUFBRTtNQUNINEwsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNOLFNBQUssSUFBSXZWLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBRytHLEtBQUssQ0FBQzlHLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEVBQUU7QUFDbkMySixNQUFBQSxDQUFDLEdBQUc1QyxLQUFLLENBQUMvRyxDQUFDLENBQUM7QUFDWixjQUFRc1YsUUFBUTtBQUNaLGFBQUssQ0FBQztBQUNGRSxVQUFBQSxNQUFNLElBQUlULFFBQVEsQ0FBQ3BMLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDMUI0TCxVQUFBQSxDQUFDLEdBQUcsQ0FBQzVMLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQztBQUNoQjJMLFVBQUFBLFFBQVEsR0FBRyxDQUFDO0FBQ1o7QUFDSixhQUFLLENBQUM7VUFDRkUsTUFBTSxJQUFJVCxRQUFRLENBQUNRLENBQUMsR0FBSTVMLENBQUMsSUFBSSxDQUFFLENBQUM7QUFDaEM0TCxVQUFBQSxDQUFDLEdBQUcsQ0FBQzVMLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQztBQUNqQjJMLFVBQUFBLFFBQVEsR0FBRyxDQUFDO0FBQ1o7QUFDSixhQUFLLENBQUM7VUFDRkUsTUFBTSxJQUFJVCxRQUFRLENBQUNRLENBQUMsR0FBSTVMLENBQUMsSUFBSSxDQUFFLENBQUM7QUFDaEM2TCxVQUFBQSxNQUFNLElBQUlULFFBQVEsQ0FBQ3BMLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDMUIyTCxVQUFBQSxRQUFRLEdBQUcsQ0FBQztBQUNaO0FBQ1I7QUFDSjtBQUNBO0FBQ0EsUUFBSUEsUUFBUSxFQUFFO0FBQ1ZFLE1BQUFBLE1BQU0sSUFBSVQsUUFBUSxDQUFDUSxDQUFDLENBQUM7QUFDckJDLE1BQUFBLE1BQU0sSUFBSSxHQUFHO0FBQ2IsVUFBSUYsUUFBUSxJQUFJLENBQUMsRUFDYkUsTUFBTSxJQUFJLEdBQUc7QUFDckI7QUFDQSxXQUFPQSxNQUFNO0FBQ2pCO0FBQ0osQ0FBQzs7QUM1SEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0MsWUFBWUEsQ0FBQ3pOLE9BQU8sRUFBRWdNLFNBQVMsRUFBRWhOLE9BQU8sRUFBRTtBQUN0RDBPLEVBQUFBLGNBQWMsQ0FBQzFCLFNBQVMsRUFBRWhNLE9BQU8sQ0FBQztFQUNsQyxNQUFNM0MsR0FBRyxHQUFHMk8sU0FBUyxDQUFDck4sT0FBTyxDQUFDUSxHQUFHLENBQUNDLGVBQWUsQ0FBQ0osT0FBTyxDQUFDO0VBQzFELE1BQU0yTyxHQUFHLEdBQUdoQixtQkFBbUIsQ0FBQzNNLE9BQU8sQ0FBQ3RCLE9BQU8sRUFBRSxDQUFDQyxPQUFPLENBQUNRLEdBQUcsQ0FBQ3lPLGlCQUFpQixDQUFDNU4sT0FBTyxDQUFDLEVBQUVnTSxTQUFTLENBQUNOLEtBQUssQ0FBQztFQUMxRyxNQUFNLENBQUNPLFNBQVMsRUFBRTRCLEdBQUcsQ0FBQyxHQUFHOUIsd0JBQXdCLENBQUNDLFNBQVMsQ0FBQztBQUM1RCxPQUFLLE1BQU1jLEVBQUUsSUFBSWEsR0FBRyxFQUFFO0lBQ2xCM0IsU0FBUyxDQUFDck4sT0FBTyxDQUFDUSxHQUFHLENBQUMyTyxTQUFTLENBQUM3QixTQUFTLEVBQUU1TyxHQUFHLENBQUNpQyxhQUFhLENBQUN3TixFQUFFLENBQUN6TCxJQUFJLENBQUMsRUFBRTJLLFNBQVMsQ0FBQ04sS0FBSyxFQUFFb0IsRUFBRSxDQUFDekMsUUFBUSxFQUFFaE4sR0FBRyxDQUFDO0FBQzdHO0VBQ0EsT0FBT3dRLEdBQUcsRUFBRTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNFLFlBQVlBLENBQUMvTixPQUFPLEVBQUVnTSxTQUFTLEVBQUVqTyxLQUFLLEVBQUVpQixPQUFPLEVBQUU7QUFDN0QwTyxFQUFBQSxjQUFjLENBQUMxQixTQUFTLEVBQUVoTSxPQUFPLENBQUM7RUFDbEMsTUFBTWdPLE9BQU8sR0FBR2hDLFNBQVMsQ0FBQ3JOLE9BQU8sQ0FBQ1EsR0FBRyxDQUFDQyxlQUFlLENBQUNKLE9BQU8sQ0FBQztFQUM5RCxNQUFNaVAsUUFBUSxHQUFHakMsU0FBUyxDQUFDck4sT0FBTyxDQUFDUSxHQUFHLENBQUNnQixnQkFBZ0IsQ0FBQ25CLE9BQU8sQ0FBQztBQUNoRSxNQUFJa1AsWUFBWSxDQUFDbE8sT0FBTyxFQUFFZ00sU0FBUyxDQUFDLEVBQUU7QUFDbEMsVUFBTTJCLEdBQUcsR0FBRzNOLE9BQU8sQ0FDZHRCLE9BQU8sRUFBRSxDQUNUQyxPQUFPLENBQUNRLEdBQUcsQ0FBQ3lPLGlCQUFpQixDQUFDNU4sT0FBTyxDQUFDLENBQ3RDNk0sTUFBTSxDQUFFQyxFQUFFLElBQUtBLEVBQUUsQ0FBQ3RQLEVBQUUsSUFBSXdPLFNBQVMsQ0FBQ04sS0FBSyxDQUFDbE8sRUFBRSxDQUFDO0FBQ2hEd0MsSUFBQUEsT0FBTyxDQUFDdEIsT0FBTyxFQUFFLENBQUNDLE9BQU8sQ0FBQ1EsR0FBRyxDQUFDZ1Asb0JBQW9CLENBQUNuTyxPQUFPLENBQUM7QUFDM0QsU0FBSyxNQUFNOE0sRUFBRSxJQUFJYSxHQUFHLEVBQUU7TUFDbEIzTixPQUFPLENBQ0Z0QixPQUFPLEVBQUUsQ0FDVEMsT0FBTyxDQUFDUSxHQUFHLENBQUNpUCxjQUFjLENBQUNwTyxPQUFPLEVBQUU4TSxFQUFFLENBQUN0UCxFQUFFLEVBQUVzUCxFQUFFLENBQUN6QyxRQUFRLEVBQUV5QyxFQUFFLENBQUN6TCxJQUFJLENBQUM7QUFDekU7QUFDSjtBQUNBLFFBQU1qQixNQUFNLEdBQUc2TixRQUFRLENBQUM1TixhQUFhLEVBQUU7QUFDdkMsTUFBSWdPLENBQUMsR0FBR3JDLFNBQVMsQ0FBQ04sS0FBSztBQUN2QjtBQUNBO0VBQ0EsSUFBSSxDQUFDMkMsQ0FBQyxDQUFDaFIsR0FBRyxJQUFJLENBQUNnUixDQUFDLENBQUNqQyxRQUFRLEtBQUtpQyxDQUFDLENBQUMvQixJQUFJLElBQUksTUFBTSxJQUFJK0IsQ0FBQyxDQUFDL0IsSUFBSSxJQUFJLFFBQVEsQ0FBQyxFQUFFO0FBQ25FK0IsSUFBQUEsQ0FBQyxHQUFHNVMsTUFBTSxDQUFDNkMsTUFBTSxDQUFDN0MsTUFBTSxDQUFDNkMsTUFBTSxDQUFDLEVBQUUsRUFBRTBOLFNBQVMsQ0FBQ04sS0FBSyxDQUFDLEVBQUU7QUFBRXJPLE1BQUFBLEdBQUcsRUFBRTtBQUFLLEtBQUMsQ0FBQztBQUN4RTtBQUNBMk8sRUFBQUEsU0FBUyxDQUFDck4sT0FBTyxDQUFDUSxHQUFHLENBQUNtUCxVQUFVLENBQUNELENBQUMsRUFBRXRRLEtBQUssRUFBRXFDLE1BQU0sRUFBRTZOLFFBQVEsQ0FBQztFQUM1RCxNQUFNTSxNQUFNLEdBQUdQLE9BQU8sQ0FBQzFPLGFBQWEsQ0FBQ2MsTUFBTSxDQUFDRyxNQUFNLEVBQUUsQ0FBQztBQUNyRCxTQUFPZ08sTUFBTSxDQUFDdE0sR0FBRyxHQUFHc00sTUFBTSxDQUFDeEcsR0FBRyxFQUFFO0lBQzVCLE1BQU0sQ0FBQ3ZLLEVBQUUsRUFBRTZNLFFBQVEsQ0FBQyxHQUFHa0UsTUFBTSxDQUFDOUYsR0FBRyxFQUFFO0lBQ25DLE1BQU1wSCxJQUFJLEdBQUdrTixNQUFNLENBQUNqRSxJQUFJLENBQUNELFFBQVEsRUFBRTdNLEVBQUUsQ0FBQztBQUN0Q3dDLElBQUFBLE9BQU8sQ0FBQ3RCLE9BQU8sRUFBRSxDQUFDQyxPQUFPLENBQUNRLEdBQUcsQ0FBQ2lQLGNBQWMsQ0FBQ3BPLE9BQU8sRUFBRXhDLEVBQUUsRUFBRTZNLFFBQVEsRUFBRWhKLElBQUksQ0FBQztBQUM3RTtBQUNKO0FBbUJBO0FBQ0E7QUFDQTtBQUNPLFNBQVM2TSxZQUFZQSxDQUFDbE8sT0FBTyxFQUFFZ00sU0FBUyxFQUFFO0FBQzdDLFFBQU13QyxXQUFXLEdBQUd4TyxPQUFPLENBQUN0QixPQUFPLEVBQUU7QUFDckMsU0FBUXNOLFNBQVMsQ0FBQ1AsUUFBUSxDQUFDck8sUUFBUSxLQUFLb1IsV0FBVyxDQUFDcFIsUUFBUSxJQUN4RCxDQUFDLENBQUNvUixXQUFXLENBQUM3UCxPQUFPLENBQUNRLEdBQUcsQ0FDcEJ5TyxpQkFBaUIsQ0FBQzVOLE9BQU8sQ0FBQyxDQUMxQnlPLElBQUksQ0FBRTNCLEVBQUUsSUFBS0EsRUFBRSxDQUFDdFAsRUFBRSxJQUFJd08sU0FBUyxDQUFDTixLQUFLLENBQUNsTyxFQUFFLENBQUM7QUFDdEQ7QUFDQSxTQUFTa1EsY0FBY0EsQ0FBQzFCLFNBQVMsRUFBRWhNLE9BQU8sRUFBRTtBQUN4Q2xFLEVBQUFBLE1BQU0sQ0FBQ2tRLFNBQVMsQ0FBQ1AsUUFBUSxDQUFDck8sUUFBUSxJQUFJNEMsT0FBTyxDQUFDdEIsT0FBTyxFQUFFLENBQUN0QixRQUFRLEVBQUEyQyxZQUFBQSxDQUFBQSxNQUFBLENBQWVpTSxTQUFTLENBQUM1TyxRQUFRLEVBQUEyQyxrQ0FBQUEsQ0FBQUEsQ0FBQUEsTUFBQSxDQUFtQ2lNLFNBQVMsQ0FBQ1AsUUFBUSxDQUFDck8sUUFBUSxDQUFFLENBQUM7QUFDdEs7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ08sU0FBU3NSLFVBQVVBLENBQUNoRCxLQUFLLEVBQUVpRCxNQUFNLEVBQUU7QUFDdEMsUUFBTWxSLFNBQVMsR0FBR2lPLEtBQUssQ0FBQ2pPLFNBQVM7RUFDakMsSUFBSWlPLEtBQUssQ0FBQ1UsUUFBUSxFQUFFO0FBQ2hCLFdBQU91QyxNQUFNLENBQUNsUixTQUFTLENBQUMsQ0FBQ3hGLE1BQU0sR0FBRyxDQUFDO0FBQ3ZDO0VBQ0EsSUFBSXlULEtBQUssQ0FBQ2tELEtBQUssRUFBRTtBQUNiLFdBQU9ELE1BQU0sQ0FBQ2pELEtBQUssQ0FBQ2tELEtBQUssQ0FBQ25SLFNBQVMsQ0FBQyxDQUFDb1IsSUFBSSxLQUFLcFIsU0FBUyxDQUFDO0FBQzVEO0VBQ0EsUUFBUWlPLEtBQUssQ0FBQ1ksSUFBSTtBQUNkLFNBQUssTUFBTTtBQUNYLFNBQUssUUFBUTtBQUNULFVBQUlaLEtBQUssQ0FBQ3JPLEdBQUcsSUFBSXFPLEtBQUssQ0FBQ29ELEdBQUcsRUFBRTtBQUN4QjtBQUNBLGVBQU9ILE1BQU0sQ0FBQ2xSLFNBQVMsQ0FBQyxLQUFLN0YsU0FBUztBQUMxQztBQUNBO0FBQ0EsVUFBSThULEtBQUssQ0FBQ1ksSUFBSSxJQUFJLE1BQU0sRUFBRTtBQUN0QixlQUFPcUMsTUFBTSxDQUFDbFIsU0FBUyxDQUFDLEtBQUtpTyxLQUFLLENBQUNhLENBQUMsQ0FBQzdRLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQzhCLEVBQUU7QUFDckQ7TUFDQSxPQUFPLENBQUNnSyxpQkFBaUIsQ0FBQ2tFLEtBQUssQ0FBQ2EsQ0FBQyxFQUFFb0MsTUFBTSxDQUFDbFIsU0FBUyxDQUFDLENBQUM7QUFDekQsU0FBSyxTQUFTO0FBQ1YsYUFBT2tSLE1BQU0sQ0FBQ2xSLFNBQVMsQ0FBQyxLQUFLN0YsU0FBUztBQUMxQyxTQUFLLEtBQUs7QUFDTixhQUFPNkQsTUFBTSxDQUFDc1QsSUFBSSxDQUFDSixNQUFNLENBQUNsUixTQUFTLENBQUMsQ0FBQyxDQUFDeEYsTUFBTSxHQUFHLENBQUM7QUFBRTtBQUMxRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBUytXLFVBQVVBLENBQUN0RCxLQUFLLEVBQUVpRCxNQUFNLEVBQUU7QUFDdEMsUUFBTWxSLFNBQVMsR0FBR2lPLEtBQUssQ0FBQ2pPLFNBQVM7RUFDakMsTUFBTXdSLGdCQUFnQixHQUFHLENBQUN2RCxLQUFLLENBQUNyTyxHQUFHLElBQUksQ0FBQ3FPLEtBQUssQ0FBQ29ELEdBQUc7RUFDakQsSUFBSXBELEtBQUssQ0FBQ1UsUUFBUSxFQUFFO0FBQ2hCdUMsSUFBQUEsTUFBTSxDQUFDbFIsU0FBUyxDQUFDLEdBQUcsRUFBRTtBQUMxQixHQUFDLE1BQ0ksSUFBSWlPLEtBQUssQ0FBQ2tELEtBQUssRUFBRTtBQUNsQkQsSUFBQUEsTUFBTSxDQUFDakQsS0FBSyxDQUFDa0QsS0FBSyxDQUFDblIsU0FBUyxDQUFDLEdBQUc7QUFBRW9SLE1BQUFBLElBQUksRUFBRWpYLFNBQUFBO0tBQVc7QUFDdkQsR0FBQyxNQUNJO0lBQ0QsUUFBUThULEtBQUssQ0FBQ1ksSUFBSTtBQUNkLFdBQUssS0FBSztBQUNOcUMsUUFBQUEsTUFBTSxDQUFDbFIsU0FBUyxDQUFDLEdBQUcsRUFBRTtBQUN0QjtBQUNKLFdBQUssTUFBTTtBQUNQa1IsUUFBQUEsTUFBTSxDQUFDbFIsU0FBUyxDQUFDLEdBQUd3UixnQkFBZ0IsR0FBR3ZELEtBQUssQ0FBQ2EsQ0FBQyxDQUFDN1EsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDOEIsRUFBRSxHQUFHNUYsU0FBUztBQUN2RTtBQUNKLFdBQUssUUFBUTtBQUNUK1csUUFBQUEsTUFBTSxDQUFDbFIsU0FBUyxDQUFDLEdBQUd3UixnQkFBZ0IsR0FDOUIvSCxlQUFlLENBQUN3RSxLQUFLLENBQUNhLENBQUMsRUFBRWIsS0FBSyxDQUFDYyxDQUFDLENBQUMsR0FDakM1VSxTQUFTO0FBQ2Y7QUFDSixXQUFLLFNBQVM7QUFDVitXLFFBQUFBLE1BQU0sQ0FBQ2xSLFNBQVMsQ0FBQyxHQUFHN0YsU0FBUztBQUM3QjtBQUNSO0FBQ0o7QUFDSjs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTc1gsU0FBU0EsQ0FBQzFTLEdBQUcsRUFBRXlDLElBQUksRUFBRTtFQUNqQyxJQUFJekMsR0FBRyxLQUFLLElBQUksSUFBSSxPQUFPQSxHQUFHLElBQUksUUFBUSxFQUFFO0FBQ3hDLFdBQU8sS0FBSztBQUNoQjtFQUNBLElBQUksQ0FBQ2YsTUFBTSxDQUFDMFQsbUJBQW1CLENBQUM1USxPQUFPLENBQUNwSCxTQUFTLENBQUMsQ0FBQ2lZLEtBQUssQ0FBRUMsQ0FBQyxJQUFLQSxDQUFDLElBQUk3UyxHQUFHLElBQUksT0FBT0EsR0FBRyxDQUFDNlMsQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLEVBQUU7QUFDdEcsV0FBTyxLQUFLO0FBQ2hCO0FBQ0EsUUFBTUMsVUFBVSxHQUFHOVMsR0FBRyxDQUFDa0MsT0FBTyxFQUFFO0VBQ2hDLElBQUk0USxVQUFVLEtBQUssSUFBSSxJQUNuQixPQUFPQSxVQUFVLElBQUksVUFBVSxJQUMvQixFQUFFLFVBQVUsSUFBSUEsVUFBVSxDQUFDLElBQzNCLE9BQU9BLFVBQVUsQ0FBQ2xTLFFBQVEsSUFBSSxRQUFRLEVBQUU7QUFDeEMsV0FBTyxLQUFLO0FBQ2hCO0FBQ0EsU0FBTzZCLElBQUksS0FBS3JILFNBQVMsR0FBRyxJQUFJLEdBQUcwWCxVQUFVLENBQUNsUyxRQUFRLElBQUk2QixJQUFJLENBQUM3QixRQUFRO0FBQzNFOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU21TLFNBQVNBLENBQUN0USxJQUFJLEVBQUVsQixLQUFLLEVBQUU7RUFDbkMsSUFBSW1SLFNBQVMsQ0FBQ25SLEtBQUssQ0FBQyxJQUFJLENBQUNrQixJQUFJLENBQUN3TixZQUFZLEVBQUU7QUFDeEMsV0FBTzFPLEtBQUs7QUFDaEI7QUFDQSxTQUFPa0IsSUFBSSxDQUFDd04sWUFBWSxDQUFDOEMsU0FBUyxDQUFDeFIsS0FBSyxDQUFDO0FBQzdDO0NBaUIrQjtFQUMzQiw2QkFBNkIsRUFBRXlJLFVBQVUsQ0FBQ2EsTUFBTTtFQUNoRCw0QkFBNEIsRUFBRWIsVUFBVSxDQUFDYyxLQUFLO0VBQzlDLDRCQUE0QixFQUFFZCxVQUFVLENBQUNPLEtBQUs7RUFDOUMsNkJBQTZCLEVBQUVQLFVBQVUsQ0FBQ0ssTUFBTTtFQUNoRCw0QkFBNEIsRUFBRUwsVUFBVSxDQUFDZ0osS0FBSztFQUM5Qyw2QkFBNkIsRUFBRWhKLFVBQVUsQ0FBQ2lKLE1BQU07RUFDaEQsMkJBQTJCLEVBQUVqSixVQUFVLENBQUNZLElBQUk7RUFDNUMsNkJBQTZCLEVBQUVaLFVBQVUsQ0FBQ2UsTUFBTTtFQUNoRCw0QkFBNEIsRUFBRWYsVUFBVSxDQUFDRyxLQUFBQTtBQUM3Qzs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFhQTtBQUNBO0FBQ0EsTUFBTStJLGdCQUFnQixHQUFHO0FBQ3JCQyxFQUFBQSxtQkFBbUIsRUFBRTtBQUN6QixDQUFDO0FBQ0Q7QUFDQSxNQUFNQyxpQkFBaUIsR0FBRztBQUN0QjlPLEVBQUFBLGlCQUFpQixFQUFFLEtBQUs7QUFDeEIrTyxFQUFBQSxhQUFhLEVBQUUsS0FBSztBQUNwQkMsRUFBQUEsaUJBQWlCLEVBQUUsS0FBSztBQUN4QmxQLEVBQUFBLFlBQVksRUFBRTtBQUNsQixDQUFDO0FBQ0QsU0FBU3hCLGlCQUFlQSxDQUFDSixPQUFPLEVBQUU7QUFDOUIsU0FBT0EsT0FBTyxHQUFHdkQsTUFBTSxDQUFDNkMsTUFBTSxDQUFDN0MsTUFBTSxDQUFDNkMsTUFBTSxDQUFDLEVBQUUsRUFBRW9SLGdCQUFnQixDQUFDLEVBQUUxUSxPQUFPLENBQUMsR0FBRzBRLGdCQUFnQjtBQUNuRztBQUNBLFNBQVN2UCxrQkFBZ0JBLENBQUNuQixPQUFPLEVBQUU7QUFDL0IsU0FBT0EsT0FBTyxHQUFHdkQsTUFBTSxDQUFDNkMsTUFBTSxDQUFDN0MsTUFBTSxDQUFDNkMsTUFBTSxDQUFDLEVBQUUsRUFBRXNSLGlCQUFpQixDQUFDLEVBQUU1USxPQUFPLENBQUMsR0FBRzRRLGlCQUFpQjtBQUNyRztBQUNBLE1BQU1HLFNBQVMsR0FBR2hULE1BQU0sRUFBRTtBQUMxQixNQUFNaVQsdUJBQXVCLEdBQUdqVCxNQUFNLEVBQUU7QUFDakMsU0FBU2tULGNBQWNBLEdBQUc7RUFDN0IsT0FBTztxQkFDSDdRLGlCQUFlO3NCQUNmZSxrQkFBZ0I7SUFDaEJkLFdBQVdBLENBQUNKLElBQUksRUFBRVMsSUFBSSxFQUFFVixPQUFPLEVBQUVnQixPQUFPLEVBQUU7QUFDdEMsVUFBSU4sSUFBSSxJQUFJLElBQUksSUFBSXdRLEtBQUssQ0FBQ0MsT0FBTyxDQUFDelEsSUFBSSxDQUFDLElBQUksT0FBT0EsSUFBSSxJQUFJLFFBQVEsRUFBRTtBQUNoRSxjQUFNLElBQUl6RCxLQUFLLDBCQUFBOEQsTUFBQSxDQUEwQmQsSUFBSSxDQUFDN0IsUUFBUSxFQUFBMkMsY0FBQUEsQ0FBQUEsQ0FBQUEsTUFBQSxDQUFlcVEsY0FBYyxDQUFDMVEsSUFBSSxDQUFDLENBQUUsQ0FBQztBQUNoRztBQUNBTSxNQUFBQSxPQUFPLEdBQUdBLE9BQU8sS0FBSyxJQUFJLElBQUlBLE9BQU8sS0FBSyxLQUFLLENBQUMsR0FBR0EsT0FBTyxHQUFHLElBQUlmLElBQUksRUFBRTtBQUN2RSxZQUFNb1IsU0FBUyxHQUFHLElBQUlDLEdBQUcsRUFBRTtBQUMzQixZQUFNQyxRQUFRLEdBQUd2UixPQUFPLENBQUN3UixZQUFZO0FBQ3JDLFdBQUssTUFBTSxDQUFDQyxPQUFPLEVBQUVoUixTQUFTLENBQUMsSUFBSWhFLE1BQU0sQ0FBQ2lWLE9BQU8sQ0FBQ2hSLElBQUksQ0FBQyxFQUFFO1FBQ3JELE1BQU1nTSxLQUFLLEdBQUd6TSxJQUFJLENBQUNpQyxNQUFNLENBQUN5UCxZQUFZLENBQUNGLE9BQU8sQ0FBQztBQUMvQyxZQUFJL0UsS0FBSyxFQUFFO1VBQ1AsSUFBSUEsS0FBSyxDQUFDa0QsS0FBSyxFQUFFO1lBQ2IsSUFBSW5QLFNBQVMsS0FBSyxJQUFJLElBQUlpTSxLQUFLLENBQUNZLElBQUksSUFBSSxRQUFRLEVBQUU7QUFDOUM7QUFDQTtBQUNKO1lBQ0EsTUFBTXNFLElBQUksR0FBR1AsU0FBUyxDQUFDeEMsR0FBRyxDQUFDbkMsS0FBSyxDQUFDa0QsS0FBSyxDQUFDO1lBQ3ZDLElBQUlnQyxJQUFJLEtBQUtoWixTQUFTLEVBQUU7Y0FDcEIsTUFBTSxJQUFJcUUsS0FBSywwQkFBQThELE1BQUEsQ0FBMEJkLElBQUksQ0FBQzdCLFFBQVEsRUFBQTJDLHdDQUFBQSxDQUFBQSxDQUFBQSxNQUFBLENBQXdDMkwsS0FBSyxDQUFDa0QsS0FBSyxDQUFDelcsSUFBSSxvQkFBQTRILE1BQUEsQ0FBZTZRLElBQUksWUFBQTdRLE1BQUEsQ0FBTzBRLE9BQU8sT0FBRyxDQUFDO0FBQ3ZKO1lBQ0FKLFNBQVMsQ0FBQ3BJLEdBQUcsQ0FBQ3lELEtBQUssQ0FBQ2tELEtBQUssRUFBRTZCLE9BQU8sQ0FBQztBQUN2QztVQUNBM0MsV0FBUyxDQUFDOU4sT0FBTyxFQUFFUCxTQUFTLEVBQUVpTSxLQUFLLEVBQUUxTSxPQUFPLEVBQUVDLElBQUksQ0FBQztBQUN2RCxTQUFDLE1BQ0k7VUFDRCxJQUFJNFIsS0FBSyxHQUFHLEtBQUs7QUFDakIsY0FBSSxDQUFDTixRQUFRLEtBQUssSUFBSSxJQUFJQSxRQUFRLEtBQUssS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUdBLFFBQVEsQ0FBQ08sYUFBYSxLQUMzRUwsT0FBTyxDQUFDTSxVQUFVLENBQUMsR0FBRyxDQUFDLElBQ3ZCTixPQUFPLENBQUNPLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUN2QixrQkFBTTdFLEdBQUcsR0FBR29FLFFBQVEsQ0FBQ08sYUFBYSxDQUFDTCxPQUFPLENBQUN0UCxTQUFTLENBQUMsQ0FBQyxFQUFFc1AsT0FBTyxDQUFDeFksTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzVFLElBQUlrVSxHQUFHLElBQUlBLEdBQUcsQ0FBQ1YsUUFBUSxDQUFDck8sUUFBUSxJQUFJNkIsSUFBSSxDQUFDN0IsUUFBUSxFQUFFO0FBQy9DeVQsY0FBQUEsS0FBSyxHQUFHLElBQUk7Y0FDWixNQUFNLENBQUM1RSxTQUFTLEVBQUU0QixHQUFHLENBQUMsR0FBRzlCLHdCQUF3QixDQUFDSSxHQUFHLENBQUM7QUFDdEQyQixjQUFBQSxXQUFTLENBQUM3QixTQUFTLEVBQUV4TSxTQUFTLEVBQUUwTSxHQUFHLENBQUNULEtBQUssRUFBRTFNLE9BQU8sRUFBRW1OLEdBQUcsQ0FBQztBQUN4RDtBQUNBO0FBQ0E7Y0FDQTRCLFlBQVksQ0FBQy9OLE9BQU8sRUFBRW1NLEdBQUcsRUFBRTBCLEdBQUcsRUFBRSxFQUFFN08sT0FBTyxDQUFDO0FBQzlDO0FBQ0o7QUFDQSxjQUFJLENBQUM2UixLQUFLLElBQUksQ0FBQzdSLE9BQU8sQ0FBQzJRLG1CQUFtQixFQUFFO0FBQ3hDLGtCQUFNLElBQUkxVCxLQUFLLENBQUE4RCx3QkFBQUEsQ0FBQUEsTUFBQSxDQUEwQmQsSUFBSSxDQUFDN0IsUUFBUSxFQUFBMkMsb0JBQUFBLENBQUFBLENBQUFBLE1BQUEsQ0FBb0IwUSxPQUFPLGtCQUFjLENBQUM7QUFDcEc7QUFDSjtBQUNKO0FBQ0EsYUFBT3pRLE9BQU87S0FDakI7QUFDRE0sSUFBQUEsWUFBWUEsQ0FBQ04sT0FBTyxFQUFFaEIsT0FBTyxFQUFFO0FBQzNCLFlBQU1DLElBQUksR0FBR2UsT0FBTyxDQUFDdEIsT0FBTyxFQUFFO01BQzlCLE1BQU1nQixJQUFJLEdBQUcsRUFBRTtBQUNmLFVBQUlnTSxLQUFLO01BQ1QsSUFBSTtRQUNBLEtBQUtBLEtBQUssSUFBSXpNLElBQUksQ0FBQ2lDLE1BQU0sQ0FBQytQLFFBQVEsRUFBRSxFQUFFO0FBQ2xDLGNBQUksQ0FBQ3ZDLFVBQVUsQ0FBQ2hELEtBQUssRUFBRTFMLE9BQU8sQ0FBQyxFQUFFO0FBQzdCO1lBQ0EsSUFBSTBMLEtBQUssQ0FBQ29ELEdBQUcsRUFBRTtBQUNYO0FBQ0o7QUFDQSxnQkFBSSxDQUFDOVAsT0FBTyxDQUFDOEIsaUJBQWlCLEVBQUU7QUFDNUI7QUFDSjtBQUNBLGdCQUFJLENBQUNvUSx3QkFBd0IsQ0FBQ3hGLEtBQUssQ0FBQyxFQUFFO0FBQ2xDO0FBQ0o7QUFDSjtVQUNBLE1BQU0zTixLQUFLLEdBQUcyTixLQUFLLENBQUNrRCxLQUFLLEdBQ25CNU8sT0FBTyxDQUFDMEwsS0FBSyxDQUFDa0QsS0FBSyxDQUFDblIsU0FBUyxDQUFDLENBQUNNLEtBQUssR0FDcENpQyxPQUFPLENBQUMwTCxLQUFLLENBQUNqTyxTQUFTLENBQUM7VUFDOUIsTUFBTWdDLFNBQVMsR0FBRzZPLFlBQVUsQ0FBQzVDLEtBQUssRUFBRTNOLEtBQUssRUFBRWlCLE9BQU8sQ0FBQztVQUNuRCxJQUFJUyxTQUFTLEtBQUs3SCxTQUFTLEVBQUU7QUFDekI4SCxZQUFBQSxJQUFJLENBQUNWLE9BQU8sQ0FBQzhRLGlCQUFpQixHQUFHcEUsS0FBSyxDQUFDdlQsSUFBSSxHQUFHdVQsS0FBSyxDQUFDRyxRQUFRLENBQUMsR0FDekRwTSxTQUFTO0FBQ2pCO0FBQ0o7QUFDQSxjQUFNOFEsUUFBUSxHQUFHdlIsT0FBTyxDQUFDd1IsWUFBWTtBQUNyQyxZQUFJRCxRQUFRLEtBQUssSUFBSSxJQUFJQSxRQUFRLEtBQUssS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUdBLFFBQVEsQ0FBQ1ksZ0JBQWdCLEVBQUU7QUFDL0UsZUFBSyxNQUFNckUsRUFBRSxJQUFJN04sSUFBSSxDQUFDTixPQUFPLENBQUNRLEdBQUcsQ0FBQ3lPLGlCQUFpQixDQUFDNU4sT0FBTyxDQUFDLEVBQUU7QUFDMUQsa0JBQU1tTSxHQUFHLEdBQUdvRSxRQUFRLENBQUNZLGdCQUFnQixDQUFDbFMsSUFBSSxDQUFDN0IsUUFBUSxFQUFFMFAsRUFBRSxDQUFDdFAsRUFBRSxDQUFDO1lBQzNELElBQUkyTyxHQUFHLElBQUkrQixZQUFZLENBQUNsTyxPQUFPLEVBQUVtTSxHQUFHLENBQUMsRUFBRTtBQUNuQztBQUNBO2NBQ0EsTUFBTXBPLEtBQUssR0FBRzBQLFlBQVksQ0FBQ3pOLE9BQU8sRUFBRW1NLEdBQUcsRUFBRW5OLE9BQU8sQ0FBQztjQUNqRCxNQUFNUyxTQUFTLEdBQUc2TyxZQUFVLENBQUNuQyxHQUFHLENBQUNULEtBQUssRUFBRTNOLEtBQUssRUFBRWlCLE9BQU8sQ0FBQztjQUN2RCxJQUFJUyxTQUFTLEtBQUs3SCxTQUFTLEVBQUU7Z0JBQ3pCOEgsSUFBSSxDQUFDeU0sR0FBRyxDQUFDVCxLQUFLLENBQUNHLFFBQVEsQ0FBQyxHQUFHcE0sU0FBUztBQUN4QztBQUNKO0FBQ0o7QUFDSjtPQUNILENBQ0QsT0FBT3BJLENBQUMsRUFBRTtRQUNOLE1BQU1nWSxDQUFDLEdBQUczRCxLQUFLLDBCQUFBM0wsTUFBQSxDQUNjZCxJQUFJLENBQUM3QixRQUFRLE9BQUEyQyxNQUFBLENBQUkyTCxLQUFLLENBQUN2VCxJQUFJLHlDQUFBNEgsTUFBQSxDQUN6QmQsSUFBSSxDQUFDN0IsUUFBUSxFQUFVO0FBQ3RELGNBQU1nVSxDQUFDLEdBQUcvWixDQUFDLFlBQVk0RSxLQUFLLEdBQUc1RSxDQUFDLENBQUMySSxPQUFPLEdBQUdDLE1BQU0sQ0FBQzVJLENBQUMsQ0FBQztBQUNwRCxjQUFNLElBQUk0RSxLQUFLLENBQUNvVCxDQUFDLElBQUkrQixDQUFDLENBQUNuWixNQUFNLEdBQUcsQ0FBQyxRQUFBOEgsTUFBQSxDQUFRcVIsQ0FBQyxDQUFLLEtBQUUsQ0FBQyxDQUFDO0FBQ3ZEO0FBQ0EsYUFBTzFSLElBQUk7S0FDZDtBQUNEMlIsSUFBQUEsVUFBVUEsQ0FBQ3BTLElBQUksRUFBRVMsSUFBSSxFQUFFeUgsUUFBUSxFQUFFO0FBQzdCO0FBQ0E7QUFDQTtNQUNBLE9BQU9rSyxZQUFVLENBQUNwUyxJQUFJLEVBQUVTLElBQUksRUFBRXlILFFBQVEsS0FBSyxJQUFJLElBQUlBLFFBQVEsS0FBSyxLQUFLLENBQUMsR0FBR0EsUUFBUSxHQUFHVixRQUFRLENBQUM2SyxNQUFNLEVBQUUsSUFBSSxDQUFDO0tBQzdHO0FBQ0RDLElBQUFBLFdBQVdBLENBQUN0UyxJQUFJLEVBQUVsQixLQUFLLEVBQUUrQyxpQkFBaUIsRUFBRTtBQUN4QztBQUNBO0FBQ0E7TUFDQSxJQUFJL0MsS0FBSyxLQUFLbkcsU0FBUyxFQUFFO0FBQ3JCLGVBQU9BLFNBQVM7QUFDcEI7TUFDQSxJQUFJa0osaUJBQWlCLElBQUkwRyxpQkFBaUIsQ0FBQ3ZJLElBQUksRUFBRWxCLEtBQUssQ0FBQyxFQUFFO0FBQ3JELGVBQU93VCxhQUFXLENBQUN0UyxJQUFJLEVBQUVsQixLQUFLLENBQUM7QUFDbkM7QUFDQSxhQUFPbkcsU0FBUztLQUNuQjtBQUNEUSxJQUFBQSxLQUFLLEVBQUVnWSxjQUFBQTtHQUNWO0FBQ0w7QUFDQSxTQUFTQSxjQUFjQSxDQUFDMVEsSUFBSSxFQUFFO0VBQzFCLElBQUlBLElBQUksS0FBSyxJQUFJLEVBQUU7QUFDZixXQUFPLE1BQU07QUFDakI7QUFDQSxVQUFRLE9BQU9BLElBQUk7QUFDZixTQUFLLFFBQVE7TUFDVCxPQUFPd1EsS0FBSyxDQUFDQyxPQUFPLENBQUN6USxJQUFJLENBQUMsR0FBRyxPQUFPLEdBQUcsUUFBUTtBQUNuRCxTQUFLLFFBQVE7TUFDVCxPQUFPQSxJQUFJLENBQUN6SCxNQUFNLEdBQUcsR0FBRyxHQUFHLFFBQVEsUUFBQThILE1BQUEsQ0FBT0wsSUFBSSxDQUFDa00sS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDekQsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFHO0FBQzVFO01BQ0ksT0FBT2xJLE1BQU0sQ0FBQ1AsSUFBSSxDQUFDO0FBQzNCO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsU0FBU29PLFdBQVNBLENBQUNhLE1BQU0sRUFBRWxQLFNBQVMsRUFBRWlNLEtBQUssRUFBRTFNLE9BQU8sRUFBRXdTLFVBQVUsRUFBRTtBQUM5RCxNQUFJL1QsU0FBUyxHQUFHaU8sS0FBSyxDQUFDak8sU0FBUztFQUMvQixJQUFJaU8sS0FBSyxDQUFDVSxRQUFRLEVBQUU7QUFDaEJ0USxJQUFBQSxNQUFNLENBQUM0UCxLQUFLLENBQUNZLElBQUksSUFBSSxLQUFLLENBQUM7SUFDM0IsSUFBSTdNLFNBQVMsS0FBSyxJQUFJLEVBQUU7QUFDcEI7QUFDSjtBQUNBLFFBQUksQ0FBQ3lRLEtBQUssQ0FBQ0MsT0FBTyxDQUFDMVEsU0FBUyxDQUFDLEVBQUU7TUFDM0IsTUFBTSxJQUFJeEQsS0FBSyxDQUFBOEQsc0JBQUFBLENBQUFBLE1BQUEsQ0FBd0J5UixVQUFVLENBQUNwVSxRQUFRLE9BQUEyQyxNQUFBLENBQUkyTCxLQUFLLENBQUN2VCxJQUFJLGtCQUFBNEgsTUFBQSxDQUFlcVEsY0FBYyxDQUFDM1EsU0FBUyxDQUFDLENBQUUsQ0FBQztBQUN2SDtBQUNBLFVBQU1nUyxXQUFXLEdBQUc5QyxNQUFNLENBQUNsUixTQUFTLENBQUM7QUFDckMsU0FBSyxNQUFNaVUsUUFBUSxJQUFJalMsU0FBUyxFQUFFO01BQzlCLElBQUlpUyxRQUFRLEtBQUssSUFBSSxFQUFFO1FBQ25CLE1BQU0sSUFBSXpWLEtBQUssQ0FBQThELHNCQUFBQSxDQUFBQSxNQUFBLENBQXdCeVIsVUFBVSxDQUFDcFUsUUFBUSxPQUFBMkMsTUFBQSxDQUFJMkwsS0FBSyxDQUFDdlQsSUFBSSxrQkFBQTRILE1BQUEsQ0FBZXFRLGNBQWMsQ0FBQ3NCLFFBQVEsQ0FBQyxDQUFFLENBQUM7QUFDdEg7TUFDQSxRQUFRaEcsS0FBSyxDQUFDWSxJQUFJO0FBQ2QsYUFBSyxTQUFTO0FBQ1ZtRixVQUFBQSxXQUFXLENBQUN2VCxJQUFJLENBQUN3TixLQUFLLENBQUNhLENBQUMsQ0FBQy9NLFFBQVEsQ0FBQ2tTLFFBQVEsRUFBRTFTLE9BQU8sQ0FBQyxDQUFDO0FBQ3JEO0FBQ0osYUFBSyxNQUFNO0FBQ1AsZ0JBQU0yUyxTQUFTLEdBQUdDLFFBQVEsQ0FBQ2xHLEtBQUssQ0FBQ2EsQ0FBQyxFQUFFbUYsUUFBUSxFQUFFMVMsT0FBTyxDQUFDMlEsbUJBQW1CLEVBQUUsSUFBSSxDQUFDO1VBQ2hGLElBQUlnQyxTQUFTLEtBQUszQix1QkFBdUIsRUFBRTtBQUN2Q3lCLFlBQUFBLFdBQVcsQ0FBQ3ZULElBQUksQ0FBQ3lULFNBQVMsQ0FBQztBQUMvQjtBQUNBO0FBQ0osYUFBSyxRQUFRO1VBQ1QsSUFBSTtBQUNBRixZQUFBQSxXQUFXLENBQUN2VCxJQUFJLENBQUNtVCxZQUFVLENBQUMzRixLQUFLLENBQUNhLENBQUMsRUFBRW1GLFFBQVEsRUFBRWhHLEtBQUssQ0FBQ2MsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1dBQ2pFLENBQ0QsT0FBT25WLENBQUMsRUFBRTtZQUNOLElBQUlnWSxDQUFDLDBCQUFBdFAsTUFBQSxDQUEwQnlSLFVBQVUsQ0FBQ3BVLFFBQVEsT0FBQTJDLE1BQUEsQ0FBSTJMLEtBQUssQ0FBQ3ZULElBQUksa0JBQUE0SCxNQUFBLENBQWVxUSxjQUFjLENBQUNzQixRQUFRLENBQUMsQ0FBRTtZQUN6RyxJQUFJcmEsQ0FBQyxZQUFZNEUsS0FBSyxJQUFJNUUsQ0FBQyxDQUFDMkksT0FBTyxDQUFDL0gsTUFBTSxHQUFHLENBQUMsRUFBRTtBQUM1Q29YLGNBQUFBLENBQUMsU0FBQXRQLE1BQUEsQ0FBUzFJLENBQUMsQ0FBQzJJLE9BQU8sQ0FBRTtBQUN6QjtBQUNBLGtCQUFNLElBQUkvRCxLQUFLLENBQUNvVCxDQUFDLENBQUM7QUFDdEI7QUFDQTtBQUNSO0FBQ0o7QUFDSixHQUFDLE1BQ0ksSUFBSTNELEtBQUssQ0FBQ1ksSUFBSSxJQUFJLEtBQUssRUFBRTtJQUMxQixJQUFJN00sU0FBUyxLQUFLLElBQUksRUFBRTtBQUNwQjtBQUNKO0lBQ0EsSUFBSSxPQUFPQSxTQUFTLElBQUksUUFBUSxJQUFJeVEsS0FBSyxDQUFDQyxPQUFPLENBQUMxUSxTQUFTLENBQUMsRUFBRTtNQUMxRCxNQUFNLElBQUl4RCxLQUFLLENBQUE4RCxzQkFBQUEsQ0FBQUEsTUFBQSxDQUF3QnlSLFVBQVUsQ0FBQ3BVLFFBQVEsT0FBQTJDLE1BQUEsQ0FBSTJMLEtBQUssQ0FBQ3ZULElBQUksa0JBQUE0SCxNQUFBLENBQWVxUSxjQUFjLENBQUMzUSxTQUFTLENBQUMsQ0FBRSxDQUFDO0FBQ3ZIO0FBQ0EsVUFBTW9TLFNBQVMsR0FBR2xELE1BQU0sQ0FBQ2xSLFNBQVMsQ0FBQztBQUNuQyxTQUFLLE1BQU0sQ0FBQ3FVLFVBQVUsRUFBRUMsWUFBWSxDQUFDLElBQUl0VyxNQUFNLENBQUNpVixPQUFPLENBQUNqUixTQUFTLENBQUMsRUFBRTtNQUNoRSxJQUFJc1MsWUFBWSxLQUFLLElBQUksRUFBRTtBQUN2QixjQUFNLElBQUk5VixLQUFLLENBQUE4RCxzQkFBQUEsQ0FBQUEsTUFBQSxDQUF3QnlSLFVBQVUsQ0FBQ3BVLFFBQVEsT0FBQTJDLE1BQUEsQ0FBSTJMLEtBQUssQ0FBQ3ZULElBQUksK0JBQTRCLENBQUM7QUFDekc7QUFDQSxVQUFJNlosR0FBRztNQUNQLElBQUk7UUFDQUEsR0FBRyxHQUFHQyxVQUFVLENBQUN2RyxLQUFLLENBQUN3RyxDQUFDLEVBQUVKLFVBQVUsQ0FBQztPQUN4QyxDQUNELE9BQU96YSxDQUFDLEVBQUU7UUFDTixJQUFJZ1ksQ0FBQyxzQ0FBQXRQLE1BQUEsQ0FBc0N5UixVQUFVLENBQUNwVSxRQUFRLE9BQUEyQyxNQUFBLENBQUkyTCxLQUFLLENBQUN2VCxJQUFJLGtCQUFBNEgsTUFBQSxDQUFlcVEsY0FBYyxDQUFDM1EsU0FBUyxDQUFDLENBQUU7UUFDdEgsSUFBSXBJLENBQUMsWUFBWTRFLEtBQUssSUFBSTVFLENBQUMsQ0FBQzJJLE9BQU8sQ0FBQy9ILE1BQU0sR0FBRyxDQUFDLEVBQUU7QUFDNUNvWCxVQUFBQSxDQUFDLFNBQUF0UCxNQUFBLENBQVMxSSxDQUFDLENBQUMySSxPQUFPLENBQUU7QUFDekI7QUFDQSxjQUFNLElBQUkvRCxLQUFLLENBQUNvVCxDQUFDLENBQUM7QUFDdEI7QUFDQSxjQUFRM0QsS0FBSyxDQUFDeUcsQ0FBQyxDQUFDN0YsSUFBSTtBQUNoQixhQUFLLFNBQVM7QUFDVnVGLFVBQUFBLFNBQVMsQ0FBQ0csR0FBRyxDQUFDLEdBQUd0RyxLQUFLLENBQUN5RyxDQUFDLENBQUM1RixDQUFDLENBQUMvTSxRQUFRLENBQUN1UyxZQUFZLEVBQUUvUyxPQUFPLENBQUM7QUFDMUQ7QUFDSixhQUFLLE1BQU07QUFDUCxnQkFBTTJTLFNBQVMsR0FBR0MsUUFBUSxDQUFDbEcsS0FBSyxDQUFDeUcsQ0FBQyxDQUFDNUYsQ0FBQyxFQUFFd0YsWUFBWSxFQUFFL1MsT0FBTyxDQUFDMlEsbUJBQW1CLEVBQUUsSUFBSSxDQUFDO1VBQ3RGLElBQUlnQyxTQUFTLEtBQUszQix1QkFBdUIsRUFBRTtBQUN2QzZCLFlBQUFBLFNBQVMsQ0FBQ0csR0FBRyxDQUFDLEdBQUdMLFNBQVM7QUFDOUI7QUFDQTtBQUNKLGFBQUssUUFBUTtVQUNULElBQUk7QUFDQUUsWUFBQUEsU0FBUyxDQUFDRyxHQUFHLENBQUMsR0FBR1gsWUFBVSxDQUFDM0YsS0FBSyxDQUFDeUcsQ0FBQyxDQUFDNUYsQ0FBQyxFQUFFd0YsWUFBWSxFQUFFdEwsUUFBUSxDQUFDNkssTUFBTSxFQUFFLElBQUksQ0FBQztXQUM5RSxDQUNELE9BQU9qYSxDQUFDLEVBQUU7WUFDTixJQUFJZ1ksQ0FBQyx3Q0FBQXRQLE1BQUEsQ0FBd0N5UixVQUFVLENBQUNwVSxRQUFRLE9BQUEyQyxNQUFBLENBQUkyTCxLQUFLLENBQUN2VCxJQUFJLGtCQUFBNEgsTUFBQSxDQUFlcVEsY0FBYyxDQUFDM1EsU0FBUyxDQUFDLENBQUU7WUFDeEgsSUFBSXBJLENBQUMsWUFBWTRFLEtBQUssSUFBSTVFLENBQUMsQ0FBQzJJLE9BQU8sQ0FBQy9ILE1BQU0sR0FBRyxDQUFDLEVBQUU7QUFDNUNvWCxjQUFBQSxDQUFDLFNBQUF0UCxNQUFBLENBQVMxSSxDQUFDLENBQUMySSxPQUFPLENBQUU7QUFDekI7QUFDQSxrQkFBTSxJQUFJL0QsS0FBSyxDQUFDb1QsQ0FBQyxDQUFDO0FBQ3RCO0FBQ0E7QUFDUjtBQUNKO0FBQ0osR0FBQyxNQUNJO0lBQ0QsSUFBSTNELEtBQUssQ0FBQ2tELEtBQUssRUFBRTtNQUNiRCxNQUFNLEdBQUdBLE1BQU0sQ0FBQ2pELEtBQUssQ0FBQ2tELEtBQUssQ0FBQ25SLFNBQVMsQ0FBQyxHQUFHO0FBQUVvUixRQUFBQSxJQUFJLEVBQUVwUixTQUFBQTtPQUFXO0FBQzVEQSxNQUFBQSxTQUFTLEdBQUcsT0FBTztBQUN2QjtJQUNBLFFBQVFpTyxLQUFLLENBQUNZLElBQUk7QUFDZCxXQUFLLFNBQVM7QUFDVixjQUFNa0MsV0FBVyxHQUFHOUMsS0FBSyxDQUFDYSxDQUFDO1FBQzNCLElBQUk5TSxTQUFTLEtBQUssSUFBSSxJQUNsQitPLFdBQVcsQ0FBQ3BSLFFBQVEsSUFBSSx1QkFBdUIsRUFBRTtBQUNqRDtBQUNKO0FBQ0EsWUFBSWdWLFlBQVksR0FBR3pELE1BQU0sQ0FBQ2xSLFNBQVMsQ0FBQztBQUNwQyxZQUFJeVIsU0FBUyxDQUFDa0QsWUFBWSxDQUFDLEVBQUU7QUFDekJBLFVBQUFBLFlBQVksQ0FBQzVTLFFBQVEsQ0FBQ0MsU0FBUyxFQUFFVCxPQUFPLENBQUM7QUFDN0MsU0FBQyxNQUNJO0FBQ0QyUCxVQUFBQSxNQUFNLENBQUNsUixTQUFTLENBQUMsR0FBRzJVLFlBQVksR0FBRzVELFdBQVcsQ0FBQ2hQLFFBQVEsQ0FBQ0MsU0FBUyxFQUFFVCxPQUFPLENBQUM7VUFDM0UsSUFBSXdQLFdBQVcsQ0FBQy9CLFlBQVksSUFBSSxDQUFDZixLQUFLLENBQUNrRCxLQUFLLEVBQUU7WUFDMUNELE1BQU0sQ0FBQ2xSLFNBQVMsQ0FBQyxHQUNiK1EsV0FBVyxDQUFDL0IsWUFBWSxDQUFDQyxXQUFXLENBQUMwRixZQUFZLENBQUM7QUFDMUQ7QUFDSjtBQUNBO0FBQ0osV0FBSyxNQUFNO0FBQ1AsY0FBTVQsU0FBUyxHQUFHQyxRQUFRLENBQUNsRyxLQUFLLENBQUNhLENBQUMsRUFBRTlNLFNBQVMsRUFBRVQsT0FBTyxDQUFDMlEsbUJBQW1CLEVBQUUsS0FBSyxDQUFDO0FBQ2xGLGdCQUFRZ0MsU0FBUztBQUNiLGVBQUs1QixTQUFTO0FBQ1ZmLFlBQUFBLFVBQVUsQ0FBQ3RELEtBQUssRUFBRWlELE1BQU0sQ0FBQztBQUN6QjtBQUNKLGVBQUtxQix1QkFBdUI7QUFDeEI7QUFDSjtBQUNJckIsWUFBQUEsTUFBTSxDQUFDbFIsU0FBUyxDQUFDLEdBQUdrVSxTQUFTO0FBQzdCO0FBQ1I7QUFDQTtBQUNKLFdBQUssUUFBUTtRQUNULElBQUk7QUFDQSxnQkFBTVUsV0FBVyxHQUFHaEIsWUFBVSxDQUFDM0YsS0FBSyxDQUFDYSxDQUFDLEVBQUU5TSxTQUFTLEVBQUVpTSxLQUFLLENBQUNjLENBQUMsRUFBRSxLQUFLLENBQUM7QUFDbEUsa0JBQVE2RixXQUFXO0FBQ2YsaUJBQUt0QyxTQUFTO0FBQ1ZmLGNBQUFBLFVBQVUsQ0FBQ3RELEtBQUssRUFBRWlELE1BQU0sQ0FBQztBQUN6QjtBQUNKO0FBQ0lBLGNBQUFBLE1BQU0sQ0FBQ2xSLFNBQVMsQ0FBQyxHQUFHNFUsV0FBVztBQUMvQjtBQUNSO1NBQ0gsQ0FDRCxPQUFPaGIsQ0FBQyxFQUFFO1VBQ04sSUFBSWdZLENBQUMsMEJBQUF0UCxNQUFBLENBQTBCeVIsVUFBVSxDQUFDcFUsUUFBUSxPQUFBMkMsTUFBQSxDQUFJMkwsS0FBSyxDQUFDdlQsSUFBSSxrQkFBQTRILE1BQUEsQ0FBZXFRLGNBQWMsQ0FBQzNRLFNBQVMsQ0FBQyxDQUFFO1VBQzFHLElBQUlwSSxDQUFDLFlBQVk0RSxLQUFLLElBQUk1RSxDQUFDLENBQUMySSxPQUFPLENBQUMvSCxNQUFNLEdBQUcsQ0FBQyxFQUFFO0FBQzVDb1gsWUFBQUEsQ0FBQyxTQUFBdFAsTUFBQSxDQUFTMUksQ0FBQyxDQUFDMkksT0FBTyxDQUFFO0FBQ3pCO0FBQ0EsZ0JBQU0sSUFBSS9ELEtBQUssQ0FBQ29ULENBQUMsQ0FBQztBQUN0QjtBQUNBO0FBQ1I7QUFDSjtBQUNKO0FBQ0EsU0FBUzRDLFVBQVVBLENBQUNoVCxJQUFJLEVBQUVTLElBQUksRUFBRTtBQUM1QixNQUFJVCxJQUFJLEtBQUt1SCxVQUFVLENBQUNZLElBQUksRUFBRTtBQUMxQjtBQUNBLFlBQVExSCxJQUFJO0FBQ1IsV0FBSyxNQUFNO0FBQ1BBLFFBQUFBLElBQUksR0FBRyxJQUFJO0FBQ1g7QUFDSixXQUFLLE9BQU87QUFDUkEsUUFBQUEsSUFBSSxHQUFHLEtBQUs7QUFDWjtBQUNSO0FBQ0o7QUFDQSxTQUFPMlIsWUFBVSxDQUFDcFMsSUFBSSxFQUFFUyxJQUFJLEVBQUUrRyxRQUFRLENBQUM2SyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUNsTixRQUFRLEVBQUU7QUFDbkU7QUFDQSxTQUFTaU4sWUFBVUEsQ0FBQ3BTLElBQUksRUFBRVMsSUFBSSxFQUFFeUgsUUFBUSxFQUFFbUwsZUFBZSxFQUFFO0VBQ3ZELElBQUk1UyxJQUFJLEtBQUssSUFBSSxFQUFFO0FBQ2YsUUFBSTRTLGVBQWUsRUFBRTtBQUNqQixhQUFPcEwsZUFBZSxDQUFDakksSUFBSSxFQUFFa0ksUUFBUSxDQUFDO0FBQzFDO0FBQ0EsV0FBTzRJLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUTlRLElBQUk7QUFDUjtBQUNBO0lBQ0EsS0FBS3VILFVBQVUsQ0FBQ2EsTUFBTTtJQUN0QixLQUFLYixVQUFVLENBQUNjLEtBQUs7QUFDakIsVUFBSTVILElBQUksS0FBSyxLQUFLLEVBQ2QsT0FBT2pELE1BQU0sQ0FBQzhWLEdBQUc7QUFDckIsVUFBSTdTLElBQUksS0FBSyxVQUFVLEVBQ25CLE9BQU9qRCxNQUFNLENBQUMrVixpQkFBaUI7QUFDbkMsVUFBSTlTLElBQUksS0FBSyxXQUFXLEVBQ3BCLE9BQU9qRCxNQUFNLENBQUNnVyxpQkFBaUI7TUFDbkMsSUFBSS9TLElBQUksS0FBSyxFQUFFLEVBQUU7QUFDYjtBQUNBO0FBQ0o7QUFDQSxVQUFJLE9BQU9BLElBQUksSUFBSSxRQUFRLElBQUlBLElBQUksQ0FBQ2dULElBQUksRUFBRSxDQUFDemEsTUFBTSxLQUFLeUgsSUFBSSxDQUFDekgsTUFBTSxFQUFFO0FBQy9EO0FBQ0E7QUFDSjtNQUNBLElBQUksT0FBT3lILElBQUksSUFBSSxRQUFRLElBQUksT0FBT0EsSUFBSSxJQUFJLFFBQVEsRUFBRTtBQUNwRDtBQUNKO0FBQ0EsWUFBTXFKLEtBQUssR0FBR3RNLE1BQU0sQ0FBQ2lELElBQUksQ0FBQztBQUMxQixVQUFJakQsTUFBTSxDQUFDa1csS0FBSyxDQUFDNUosS0FBSyxDQUFDLEVBQUU7QUFDckI7QUFDQTtBQUNKO0FBQ0EsVUFBSSxDQUFDdE0sTUFBTSxDQUFDSSxRQUFRLENBQUNrTSxLQUFLLENBQUMsRUFBRTtBQUN6QjtBQUNBO0FBQ0o7TUFDQSxJQUFJOUosSUFBSSxJQUFJdUgsVUFBVSxDQUFDYyxLQUFLLEVBQ3hCMUssYUFBYSxDQUFDbU0sS0FBSyxDQUFDO0FBQ3hCLGFBQU9BLEtBQUs7QUFDaEI7SUFDQSxLQUFLdkMsVUFBVSxDQUFDZ0osS0FBSztJQUNyQixLQUFLaEosVUFBVSxDQUFDb00sT0FBTztJQUN2QixLQUFLcE0sVUFBVSxDQUFDcU0sUUFBUTtJQUN4QixLQUFLck0sVUFBVSxDQUFDc00sTUFBTTtJQUN0QixLQUFLdE0sVUFBVSxDQUFDaUosTUFBTTtBQUNsQixVQUFJOUcsS0FBSztNQUNULElBQUksT0FBT2pKLElBQUksSUFBSSxRQUFRLEVBQ3ZCaUosS0FBSyxHQUFHakosSUFBSSxDQUFDLEtBQ1osSUFBSSxPQUFPQSxJQUFJLElBQUksUUFBUSxJQUFJQSxJQUFJLENBQUN6SCxNQUFNLEdBQUcsQ0FBQyxFQUFFO0FBQ2pELFlBQUl5SCxJQUFJLENBQUNnVCxJQUFJLEVBQUUsQ0FBQ3phLE1BQU0sS0FBS3lILElBQUksQ0FBQ3pILE1BQU0sRUFDbEMwUSxLQUFLLEdBQUdsTSxNQUFNLENBQUNpRCxJQUFJLENBQUM7QUFDNUI7TUFDQSxJQUFJaUosS0FBSyxLQUFLL1EsU0FBUyxFQUNuQjtNQUNKLElBQUlxSCxJQUFJLElBQUl1SCxVQUFVLENBQUNpSixNQUFNLElBQUl4USxJQUFJLElBQUl1SCxVQUFVLENBQUNvTSxPQUFPLEVBQ3ZEalcsWUFBWSxDQUFDZ00sS0FBSyxDQUFDLENBQUMsS0FFcEJwTSxXQUFXLENBQUNvTSxLQUFLLENBQUM7QUFDdEIsYUFBT0EsS0FBSztBQUNoQjtJQUNBLEtBQUtuQyxVQUFVLENBQUNPLEtBQUs7SUFDckIsS0FBS1AsVUFBVSxDQUFDUSxRQUFRO0lBQ3hCLEtBQUtSLFVBQVUsQ0FBQ1MsTUFBTTtNQUNsQixJQUFJLE9BQU92SCxJQUFJLElBQUksUUFBUSxJQUFJLE9BQU9BLElBQUksSUFBSSxRQUFRLEVBQ2xEO0FBQ0osWUFBTXFULElBQUksR0FBR3hNLFVBQVUsQ0FBQ3pHLEtBQUssQ0FBQ0osSUFBSSxDQUFDO0FBQ25DO01BQ0EsT0FBT3lILFFBQVEsR0FBRzRMLElBQUksQ0FBQzNPLFFBQVEsRUFBRSxHQUFHMk8sSUFBSTtJQUM1QyxLQUFLdk0sVUFBVSxDQUFDTSxPQUFPO0lBQ3ZCLEtBQUtOLFVBQVUsQ0FBQ0ssTUFBTTtNQUNsQixJQUFJLE9BQU9uSCxJQUFJLElBQUksUUFBUSxJQUFJLE9BQU9BLElBQUksSUFBSSxRQUFRLEVBQ2xEO0FBQ0osWUFBTXNULEtBQUssR0FBR3pNLFVBQVUsQ0FBQ1IsTUFBTSxDQUFDckcsSUFBSSxDQUFDO0FBQ3JDO01BQ0EsT0FBT3lILFFBQVEsR0FBRzZMLEtBQUssQ0FBQzVPLFFBQVEsRUFBRSxHQUFHNE8sS0FBSztBQUM5QztJQUNBLEtBQUt4TSxVQUFVLENBQUNZLElBQUk7QUFDaEIsVUFBSSxPQUFPMUgsSUFBSSxLQUFLLFNBQVMsRUFDekI7QUFDSixhQUFPQSxJQUFJO0FBQ2Y7SUFDQSxLQUFLOEcsVUFBVSxDQUFDZSxNQUFNO0FBQ2xCLFVBQUksT0FBTzdILElBQUksS0FBSyxRQUFRLEVBQUU7QUFDMUI7QUFDSjtBQUNBO0FBQ0E7TUFDQSxJQUFJO1FBQ0FoRyxrQkFBa0IsQ0FBQ2dHLElBQUksQ0FBQztPQUMzQixDQUNELE9BQU9ySSxDQUFDLEVBQUU7QUFDTixjQUFNLElBQUk0RSxLQUFLLENBQUMsY0FBYyxDQUFDO0FBQ25DO0FBQ0EsYUFBT3lELElBQUk7QUFDZjtBQUNBO0lBQ0EsS0FBSzhHLFVBQVUsQ0FBQ0csS0FBSztNQUNqQixJQUFJakgsSUFBSSxLQUFLLEVBQUUsRUFDWCxPQUFPLElBQUlrSCxVQUFVLENBQUMsQ0FBQyxDQUFDO0FBQzVCLFVBQUksT0FBT2xILElBQUksS0FBSyxRQUFRLEVBQ3hCO0FBQ0osYUFBT3dOLFdBQVcsQ0FBQ3JLLEdBQUcsQ0FBQ25ELElBQUksQ0FBQztBQUNwQztFQUNBLE1BQU0sSUFBSXpELEtBQUssRUFBRTtBQUNyQjtBQUNBLFNBQVMyVixRQUFRQSxDQUFDM1MsSUFBSSxFQUFFUyxJQUFJLEVBQUVpUSxtQkFBbUIsRUFBRTJDLGVBQWUsRUFBRTtFQUNoRSxJQUFJNVMsSUFBSSxLQUFLLElBQUksRUFBRTtBQUNmLFFBQUlULElBQUksQ0FBQzdCLFFBQVEsSUFBSSwyQkFBMkIsRUFBRTtNQUM5QyxPQUFPLENBQUMsQ0FBQztBQUNiO0lBQ0EsT0FBT2tWLGVBQWUsR0FBR3JULElBQUksQ0FBQ3ZELE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQzhCLEVBQUUsR0FBR3VTLFNBQVM7QUFDMUQ7QUFDQTtBQUNBLFVBQVEsT0FBT3JRLElBQUk7QUFDZixTQUFLLFFBQVE7QUFDVCxVQUFJakQsTUFBTSxDQUFDQyxTQUFTLENBQUNnRCxJQUFJLENBQUMsRUFBRTtBQUN4QixlQUFPQSxJQUFJO0FBQ2Y7QUFDQTtBQUNKLFNBQUssUUFBUTtBQUNULFlBQU0zQixLQUFLLEdBQUdrQixJQUFJLENBQUNkLFFBQVEsQ0FBQ3VCLElBQUksQ0FBQztNQUNqQyxJQUFJM0IsS0FBSyxLQUFLbkcsU0FBUyxFQUFFO1FBQ3JCLE9BQU9tRyxLQUFLLENBQUNQLEVBQUU7QUFDbkI7QUFDQSxVQUFJbVMsbUJBQW1CLEVBQUU7QUFDckIsZUFBT0ssdUJBQXVCO0FBQ2xDO0FBQ0E7QUFDUjtBQUNBLFFBQU0sSUFBSS9ULEtBQUssdUJBQUE4RCxNQUFBLENBQXVCZCxJQUFJLENBQUM3QixRQUFRLEVBQUEyQyxjQUFBQSxDQUFBQSxDQUFBQSxNQUFBLENBQWVxUSxjQUFjLENBQUMxUSxJQUFJLENBQUMsQ0FBRSxDQUFDO0FBQzdGO0FBQ0E7QUFDQSxTQUFTd1Isd0JBQXdCQSxDQUFDeEYsS0FBSyxFQUFFO0VBQ3JDLElBQUlBLEtBQUssQ0FBQ1UsUUFBUSxJQUFJVixLQUFLLENBQUNZLElBQUksSUFBSSxLQUFLLEVBQUU7QUFDdkM7QUFDQSxXQUFPLElBQUk7QUFDZjtFQUNBLElBQUlaLEtBQUssQ0FBQ2tELEtBQUssRUFBRTtBQUNiO0FBQ0EsV0FBTyxLQUFLO0FBQ2hCO0FBQ0EsTUFBSWxELEtBQUssQ0FBQ1ksSUFBSSxJQUFJLFNBQVMsRUFBRTtBQUN6QjtBQUNBLFdBQU8sS0FBSztBQUNoQjtBQUNBO0FBQ0EsTUFBSVosS0FBSyxDQUFDck8sR0FBRyxJQUFJcU8sS0FBSyxDQUFDb0QsR0FBRyxFQUFFO0FBQ3hCO0FBQ0EsV0FBTyxLQUFLO0FBQ2hCO0FBQ0EsU0FBTyxJQUFJO0FBQ2Y7QUFDQSxTQUFTUixZQUFVQSxDQUFDNUMsS0FBSyxFQUFFM04sS0FBSyxFQUFFaUIsT0FBTyxFQUFFO0FBQ3ZDLE1BQUkwTSxLQUFLLENBQUNZLElBQUksSUFBSSxLQUFLLEVBQUU7SUFDckJ4USxNQUFNLENBQUMsT0FBT2lDLEtBQUssSUFBSSxRQUFRLElBQUlBLEtBQUssSUFBSSxJQUFJLENBQUM7SUFDakQsTUFBTWtWLE9BQU8sR0FBRyxFQUFFO0FBQ2xCLFVBQU12QyxPQUFPLEdBQUdqVixNQUFNLENBQUNpVixPQUFPLENBQUMzUyxLQUFLLENBQUM7QUFDckMsWUFBUTJOLEtBQUssQ0FBQ3lHLENBQUMsQ0FBQzdGLElBQUk7QUFDaEIsV0FBSyxRQUFRO1FBQ1QsS0FBSyxNQUFNLENBQUM0RyxRQUFRLEVBQUVDLFVBQVUsQ0FBQyxJQUFJekMsT0FBTyxFQUFFO0FBQzFDdUMsVUFBQUEsT0FBTyxDQUFDQyxRQUFRLENBQUM5TyxRQUFRLEVBQUUsQ0FBQyxHQUFHbU4sYUFBVyxDQUFDN0YsS0FBSyxDQUFDeUcsQ0FBQyxDQUFDNUYsQ0FBQyxFQUFFNEcsVUFBVSxDQUFDLENBQUM7QUFDdEU7QUFDQTtBQUNKLFdBQUssU0FBUztRQUNWLEtBQUssTUFBTSxDQUFDRCxRQUFRLEVBQUVDLFVBQVUsQ0FBQyxJQUFJekMsT0FBTyxFQUFFO0FBQzFDO0FBQ0F1QyxVQUFBQSxPQUFPLENBQUNDLFFBQVEsQ0FBQzlPLFFBQVEsRUFBRSxDQUFDLEdBQUcrTyxVQUFVLENBQUMzUyxNQUFNLENBQUN4QixPQUFPLENBQUM7QUFDN0Q7QUFDQTtBQUNKLFdBQUssTUFBTTtBQUNQLGNBQU1vVSxRQUFRLEdBQUcxSCxLQUFLLENBQUN5RyxDQUFDLENBQUM1RixDQUFDO1FBQzFCLEtBQUssTUFBTSxDQUFDMkcsUUFBUSxFQUFFQyxVQUFVLENBQUMsSUFBSXpDLE9BQU8sRUFBRTtBQUMxQztBQUNBdUMsVUFBQUEsT0FBTyxDQUFDQyxRQUFRLENBQUM5TyxRQUFRLEVBQUUsQ0FBQyxHQUFHaVAsU0FBUyxDQUFDRCxRQUFRLEVBQUVELFVBQVUsRUFBRW5VLE9BQU8sQ0FBQzZRLGFBQWEsQ0FBQztBQUN6RjtBQUNBO0FBQ1I7QUFDQSxXQUFPN1EsT0FBTyxDQUFDOEIsaUJBQWlCLElBQUk0UCxPQUFPLENBQUN6WSxNQUFNLEdBQUcsQ0FBQyxHQUNoRGdiLE9BQU8sR0FDUHJiLFNBQVM7QUFDbkI7RUFDQSxJQUFJOFQsS0FBSyxDQUFDVSxRQUFRLEVBQUU7QUFDaEJ0USxJQUFBQSxNQUFNLENBQUNvVSxLQUFLLENBQUNDLE9BQU8sQ0FBQ3BTLEtBQUssQ0FBQyxDQUFDO0lBQzVCLE1BQU11VixPQUFPLEdBQUcsRUFBRTtJQUNsQixRQUFRNUgsS0FBSyxDQUFDWSxJQUFJO0FBQ2QsV0FBSyxRQUFRO0FBQ1QsYUFBSyxJQUFJdFUsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHK0YsS0FBSyxDQUFDOUYsTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRTtBQUNuQ3NiLFVBQUFBLE9BQU8sQ0FBQ3BWLElBQUksQ0FBQ3FULGFBQVcsQ0FBQzdGLEtBQUssQ0FBQ2EsQ0FBQyxFQUFFeE8sS0FBSyxDQUFDL0YsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNoRDtBQUNBO0FBQ0osV0FBSyxNQUFNO0FBQ1AsYUFBSyxJQUFJQSxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUcrRixLQUFLLENBQUM5RixNQUFNLEVBQUVELENBQUMsRUFBRSxFQUFFO0FBQ25Dc2IsVUFBQUEsT0FBTyxDQUFDcFYsSUFBSSxDQUFDbVYsU0FBUyxDQUFDM0gsS0FBSyxDQUFDYSxDQUFDLEVBQUV4TyxLQUFLLENBQUMvRixDQUFDLENBQUMsRUFBRWdILE9BQU8sQ0FBQzZRLGFBQWEsQ0FBQyxDQUFDO0FBQ3JFO0FBQ0E7QUFDSixXQUFLLFNBQVM7QUFDVixhQUFLLElBQUk3WCxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUcrRixLQUFLLENBQUM5RixNQUFNLEVBQUVELENBQUMsRUFBRSxFQUFFO0FBQ25Dc2IsVUFBQUEsT0FBTyxDQUFDcFYsSUFBSSxDQUFDSCxLQUFLLENBQUMvRixDQUFDLENBQUMsQ0FBQ3dJLE1BQU0sQ0FBQ3hCLE9BQU8sQ0FBQyxDQUFDO0FBQzFDO0FBQ0E7QUFDUjtBQUNBLFdBQU9BLE9BQU8sQ0FBQzhCLGlCQUFpQixJQUFJd1MsT0FBTyxDQUFDcmIsTUFBTSxHQUFHLENBQUMsR0FDaERxYixPQUFPLEdBQ1AxYixTQUFTO0FBQ25CO0VBQ0EsUUFBUThULEtBQUssQ0FBQ1ksSUFBSTtBQUNkLFNBQUssUUFBUTtBQUNULGFBQU9pRixhQUFXLENBQUM3RixLQUFLLENBQUNhLENBQUMsRUFBRXhPLEtBQUssQ0FBQztBQUN0QyxTQUFLLE1BQU07TUFDUCxPQUFPc1YsU0FBUyxDQUFDM0gsS0FBSyxDQUFDYSxDQUFDLEVBQUV4TyxLQUFLLEVBQUVpQixPQUFPLENBQUM2USxhQUFhLENBQUM7QUFDM0QsU0FBSyxTQUFTO0FBQ1YsYUFBT04sU0FBUyxDQUFDN0QsS0FBSyxDQUFDYSxDQUFDLEVBQUV4TyxLQUFLLENBQUMsQ0FBQ3lDLE1BQU0sQ0FBQ3hCLE9BQU8sQ0FBQztBQUN4RDtBQUNKO0FBQ0EsU0FBU3FVLFNBQVNBLENBQUNwVSxJQUFJLEVBQUVsQixLQUFLLEVBQUU4UixhQUFhLEVBQUU7QUFDM0MsTUFBSW5QLEVBQUU7QUFDTjVFLEVBQUFBLE1BQU0sQ0FBQyxPQUFPaUMsS0FBSyxJQUFJLFFBQVEsQ0FBQztBQUNoQyxNQUFJa0IsSUFBSSxDQUFDN0IsUUFBUSxJQUFJLDJCQUEyQixFQUFFO0FBQzlDLFdBQU8sSUFBSTtBQUNmO0FBQ0EsTUFBSXlTLGFBQWEsRUFBRTtBQUNmLFdBQU85UixLQUFLO0FBQ2hCO0FBQ0EsUUFBTXdWLEdBQUcsR0FBR3RVLElBQUksQ0FBQ2IsVUFBVSxDQUFDTCxLQUFLLENBQUM7QUFDbEMsU0FBTyxDQUFDMkMsRUFBRSxHQUFHNlMsR0FBRyxLQUFLLElBQUksSUFBSUEsR0FBRyxLQUFLLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHQSxHQUFHLENBQUNwYixJQUFJLE1BQU0sSUFBSSxJQUFJdUksRUFBRSxLQUFLLEtBQUssQ0FBQyxHQUFHQSxFQUFFLEdBQUczQyxLQUFLLENBQUM7QUFDNUc7QUFDQSxTQUFTd1QsYUFBV0EsQ0FBQ3RTLElBQUksRUFBRWxCLEtBQUssRUFBRTtBQUM5QixVQUFRa0IsSUFBSTtBQUNSO0lBQ0EsS0FBS3VILFVBQVUsQ0FBQ2dKLEtBQUs7SUFDckIsS0FBS2hKLFVBQVUsQ0FBQ3FNLFFBQVE7SUFDeEIsS0FBS3JNLFVBQVUsQ0FBQ3NNLE1BQU07SUFDdEIsS0FBS3RNLFVBQVUsQ0FBQ29NLE9BQU87SUFDdkIsS0FBS3BNLFVBQVUsQ0FBQ2lKLE1BQU07QUFDbEIzVCxNQUFBQSxNQUFNLENBQUMsT0FBT2lDLEtBQUssSUFBSSxRQUFRLENBQUM7QUFDaEMsYUFBT0EsS0FBSztBQUNoQjtBQUNBO0lBQ0EsS0FBS3lJLFVBQVUsQ0FBQ2MsS0FBSztBQUNyQjtJQUNBLEtBQUtkLFVBQVUsQ0FBQ2EsTUFBTTtBQUFFO0FBQ3BCdkwsTUFBQUEsTUFBTSxDQUFDLE9BQU9pQyxLQUFLLElBQUksUUFBUSxDQUFDO01BQ2hDLElBQUl0QixNQUFNLENBQUNrVyxLQUFLLENBQUM1VSxLQUFLLENBQUMsRUFDbkIsT0FBTyxLQUFLO0FBQ2hCLFVBQUlBLEtBQUssS0FBS3RCLE1BQU0sQ0FBQytWLGlCQUFpQixFQUNsQyxPQUFPLFVBQVU7QUFDckIsVUFBSXpVLEtBQUssS0FBS3RCLE1BQU0sQ0FBQ2dXLGlCQUFpQixFQUNsQyxPQUFPLFdBQVc7QUFDdEIsYUFBTzFVLEtBQUs7QUFDaEI7SUFDQSxLQUFLeUksVUFBVSxDQUFDZSxNQUFNO0FBQ2xCekwsTUFBQUEsTUFBTSxDQUFDLE9BQU9pQyxLQUFLLElBQUksUUFBUSxDQUFDO0FBQ2hDLGFBQU9BLEtBQUs7QUFDaEI7SUFDQSxLQUFLeUksVUFBVSxDQUFDWSxJQUFJO0FBQ2hCdEwsTUFBQUEsTUFBTSxDQUFDLE9BQU9pQyxLQUFLLElBQUksU0FBUyxDQUFDO0FBQ2pDLGFBQU9BLEtBQUs7QUFDaEI7SUFDQSxLQUFLeUksVUFBVSxDQUFDSyxNQUFNO0lBQ3RCLEtBQUtMLFVBQVUsQ0FBQ00sT0FBTztJQUN2QixLQUFLTixVQUFVLENBQUNPLEtBQUs7SUFDckIsS0FBS1AsVUFBVSxDQUFDUSxRQUFRO0lBQ3hCLEtBQUtSLFVBQVUsQ0FBQ1MsTUFBTTtBQUNsQm5MLE1BQUFBLE1BQU0sQ0FBQyxPQUFPaUMsS0FBSyxJQUFJLFFBQVEsSUFDM0IsT0FBT0EsS0FBSyxJQUFJLFFBQVEsSUFDeEIsT0FBT0EsS0FBSyxJQUFJLFFBQVEsQ0FBQztBQUM3QixhQUFPQSxLQUFLLENBQUNxRyxRQUFRLEVBQUU7QUFDM0I7QUFDQTtJQUNBLEtBQUtvQyxVQUFVLENBQUNHLEtBQUs7QUFDakI3SyxNQUFBQSxNQUFNLENBQUNpQyxLQUFLLFlBQVk2SSxVQUFVLENBQUM7QUFDbkMsYUFBT3NHLFdBQVcsQ0FBQ2xILEdBQUcsQ0FBQ2pJLEtBQUssQ0FBQztBQUNyQztBQUNKOztBQzltQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBLE1BQU15VixtQkFBbUIsR0FBR3pXLE1BQU0sQ0FBQyxtQ0FBbUMsQ0FBQztBQUN2RTtBQUNBLE1BQU0wVyxZQUFZLEdBQUc7QUFDakJDLEVBQUFBLGlCQUFpQixFQUFFLElBQUk7QUFDdkJwVSxFQUFBQSxhQUFhLEVBQUdQLEtBQUssSUFBSyxJQUFJaUwsWUFBWSxDQUFDakwsS0FBSztBQUNwRCxDQUFDO0FBQ0Q7QUFDQSxNQUFNNFUsYUFBYSxHQUFHO0FBQ2xCQyxFQUFBQSxrQkFBa0IsRUFBRSxJQUFJO0FBQ3hCdlQsRUFBQUEsYUFBYSxFQUFFQSxNQUFNLElBQUlxSCxZQUFZLEVBQUM7QUFDMUMsQ0FBQztBQUNELFNBQVN0SSxlQUFlQSxDQUFDSixPQUFPLEVBQUU7QUFDOUIsU0FBT0EsT0FBTyxHQUFHdkQsTUFBTSxDQUFDNkMsTUFBTSxDQUFDN0MsTUFBTSxDQUFDNkMsTUFBTSxDQUFDLEVBQUUsRUFBRW1WLFlBQVksQ0FBQyxFQUFFelUsT0FBTyxDQUFDLEdBQUd5VSxZQUFZO0FBQzNGO0FBQ0EsU0FBU3RULGdCQUFnQkEsQ0FBQ25CLE9BQU8sRUFBRTtBQUMvQixTQUFPQSxPQUFPLEdBQUd2RCxNQUFNLENBQUM2QyxNQUFNLENBQUM3QyxNQUFNLENBQUM2QyxNQUFNLENBQUMsRUFBRSxFQUFFcVYsYUFBYSxDQUFDLEVBQUUzVSxPQUFPLENBQUMsR0FBRzJVLGFBQWE7QUFDN0Y7QUFDTyxTQUFTRSxnQkFBZ0JBLEdBQUc7RUFDL0IsT0FBTztJQUNIelUsZUFBZTtJQUNmZSxnQkFBZ0I7SUFDaEJ5TixpQkFBaUJBLENBQUM1TixPQUFPLEVBQUU7QUFDdkIsVUFBSVUsRUFBRTtBQUNOLGFBQU8sQ0FBQ0EsRUFBRSxHQUFHVixPQUFPLENBQUN3VCxtQkFBbUIsQ0FBQyxNQUFNLElBQUksSUFBSTlTLEVBQUUsS0FBSyxLQUFLLENBQUMsR0FBR0EsRUFBRSxHQUFHLEVBQUU7S0FDakY7SUFDRHlOLG9CQUFvQkEsQ0FBQ25PLE9BQU8sRUFBRTtNQUMxQixPQUFPQSxPQUFPLENBQUN3VCxtQkFBbUIsQ0FBQztLQUN0QztBQUNESSxJQUFBQSxrQkFBa0JBLENBQUM1VCxPQUFPLEVBQUVJLE1BQU0sRUFBRTtNQUNoQyxNQUFNaVAsQ0FBQyxHQUFHclAsT0FBTztBQUNqQixZQUFNOFQsQ0FBQyxHQUFHekUsQ0FBQyxDQUFDbUUsbUJBQW1CLENBQUM7QUFDaEMsVUFBSU0sQ0FBQyxFQUFFO0FBQ0gsYUFBSyxNQUFNekYsQ0FBQyxJQUFJeUYsQ0FBQyxFQUFFO0FBQ2YxVCxVQUFBQSxNQUFNLENBQUNxSSxHQUFHLENBQUM0RixDQUFDLENBQUM3USxFQUFFLEVBQUU2USxDQUFDLENBQUNoRSxRQUFRLENBQUMsQ0FBQzdCLEdBQUcsQ0FBQzZGLENBQUMsQ0FBQ2hOLElBQUksQ0FBQztBQUM1QztBQUNKO0tBQ0g7SUFDRCtNLGNBQWNBLENBQUNwTyxPQUFPLEVBQUV4QyxFQUFFLEVBQUU2TSxRQUFRLEVBQUVoSixJQUFJLEVBQUU7TUFDeEMsTUFBTWdPLENBQUMsR0FBR3JQLE9BQU87TUFDakIsSUFBSSxDQUFDa1EsS0FBSyxDQUFDQyxPQUFPLENBQUNkLENBQUMsQ0FBQ21FLG1CQUFtQixDQUFDLENBQUMsRUFBRTtBQUN4Q25FLFFBQUFBLENBQUMsQ0FBQ21FLG1CQUFtQixDQUFDLEdBQUcsRUFBRTtBQUMvQjtBQUNBbkUsTUFBQUEsQ0FBQyxDQUFDbUUsbUJBQW1CLENBQUMsQ0FBQ3RWLElBQUksQ0FBQztRQUFFVixFQUFFO1FBQUU2TSxRQUFRO0FBQUVoSixRQUFBQSxJQUFBQTtBQUFLLE9BQUMsQ0FBQztLQUN0RDtJQUNEaEMsV0FBV0EsQ0FBQ1csT0FBTyxFQUFFdU8sTUFBTSxFQUFFd0YscUJBQXFCLEVBQUUvVSxPQUFPLEVBQUVnVix3QkFBd0IsRUFBRTtBQUNuRixZQUFNL1UsSUFBSSxHQUFHZSxPQUFPLENBQUN0QixPQUFPLEVBQUU7QUFDOUI7QUFDQSxZQUFNd0UsR0FBRyxHQUFHOFEsd0JBQXdCLEdBQzlCekYsTUFBTSxDQUFDeEcsR0FBRyxHQUNWd0csTUFBTSxDQUFDdE0sR0FBRyxHQUFHOFIscUJBQXFCO01BQ3hDLElBQUlyTCxPQUFPLEVBQUUyQixRQUFRO0FBQ3JCLGFBQU9rRSxNQUFNLENBQUN0TSxHQUFHLEdBQUdpQixHQUFHLEVBQUU7UUFDckIsQ0FBQ3dGLE9BQU8sRUFBRTJCLFFBQVEsQ0FBQyxHQUFHa0UsTUFBTSxDQUFDOUYsR0FBRyxFQUFFO1FBQ2xDLElBQUl1TCx3QkFBd0IsS0FBSyxJQUFJLElBQ2pDM0osUUFBUSxJQUFJNUMsUUFBUSxDQUFDc0QsUUFBUSxFQUFFO0FBQy9CO0FBQ0o7UUFDQSxNQUFNVyxLQUFLLEdBQUd6TSxJQUFJLENBQUNpQyxNQUFNLENBQUN1TixJQUFJLENBQUMvRixPQUFPLENBQUM7UUFDdkMsSUFBSSxDQUFDZ0QsS0FBSyxFQUFFO1VBQ1IsTUFBTXJLLElBQUksR0FBR2tOLE1BQU0sQ0FBQ2pFLElBQUksQ0FBQ0QsUUFBUSxFQUFFM0IsT0FBTyxDQUFDO1VBQzNDLElBQUkxSixPQUFPLENBQUMwVSxpQkFBaUIsRUFBRTtZQUMzQixJQUFJLENBQUN0RixjQUFjLENBQUNwTyxPQUFPLEVBQUUwSSxPQUFPLEVBQUUyQixRQUFRLEVBQUVoSixJQUFJLENBQUM7QUFDekQ7QUFDQTtBQUNKO1FBQ0F5TSxTQUFTLENBQUM5TixPQUFPLEVBQUV1TyxNQUFNLEVBQUU3QyxLQUFLLEVBQUVyQixRQUFRLEVBQUVyTCxPQUFPLENBQUM7QUFDeEQ7QUFDQSxVQUFJZ1Ysd0JBQXdCO0FBQUk7TUFDM0IzSixRQUFRLElBQUk1QyxRQUFRLENBQUNzRCxRQUFRLElBQUlyQyxPQUFPLEtBQUtxTCxxQkFBcUIsQ0FBQyxFQUFFO1FBQ3RFLE1BQU0sSUFBSTlYLEtBQUssd0JBQXdCLENBQUM7QUFDNUM7S0FDSDtJQUNENlIsU0FBUztBQUNUeE4sSUFBQUEsWUFBWUEsQ0FBQ04sT0FBTyxFQUFFSSxNQUFNLEVBQUVwQixPQUFPLEVBQUU7QUFDbkMsWUFBTUMsSUFBSSxHQUFHZSxPQUFPLENBQUN0QixPQUFPLEVBQUU7TUFDOUIsS0FBSyxNQUFNZ04sS0FBSyxJQUFJek0sSUFBSSxDQUFDaUMsTUFBTSxDQUFDK1AsUUFBUSxFQUFFLEVBQUU7QUFDeEMsWUFBSSxDQUFDdkMsVUFBVSxDQUFDaEQsS0FBSyxFQUFFMUwsT0FBTyxDQUFDLEVBQUU7VUFDN0IsSUFBSTBMLEtBQUssQ0FBQ29ELEdBQUcsRUFBRTtBQUNYLGtCQUFNLElBQUk3UyxLQUFLLENBQUE4RCxzQkFBQUEsQ0FBQUEsTUFBQSxDQUF3QmQsSUFBSSxDQUFDN0IsUUFBUSxPQUFBMkMsTUFBQSxDQUFJMkwsS0FBSyxDQUFDdlQsSUFBSSx1Q0FBb0MsQ0FBQztBQUMzRztBQUNBO0FBQ0o7UUFDQSxNQUFNNEYsS0FBSyxHQUFHMk4sS0FBSyxDQUFDa0QsS0FBSyxHQUNuQjVPLE9BQU8sQ0FBQzBMLEtBQUssQ0FBQ2tELEtBQUssQ0FBQ25SLFNBQVMsQ0FBQyxDQUFDTSxLQUFLLEdBQ3BDaUMsT0FBTyxDQUFDMEwsS0FBSyxDQUFDak8sU0FBUyxDQUFDO1FBQzlCNlEsVUFBVSxDQUFDNUMsS0FBSyxFQUFFM04sS0FBSyxFQUFFcUMsTUFBTSxFQUFFcEIsT0FBTyxDQUFDO0FBQzdDO01BQ0EsSUFBSUEsT0FBTyxDQUFDNFUsa0JBQWtCLEVBQUU7QUFDNUIsWUFBSSxDQUFDQSxrQkFBa0IsQ0FBQzVULE9BQU8sRUFBRUksTUFBTSxDQUFDO0FBQzVDO0FBQ0EsYUFBT0EsTUFBTTtLQUNoQjtJQUNEa08sVUFBVUEsQ0FBQzVDLEtBQUssRUFBRTNOLEtBQUssRUFBRXFDLE1BQU0sRUFBRXBCLE9BQU8sRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtNQUNBLElBQUlqQixLQUFLLEtBQUtuRyxTQUFTLEVBQUU7QUFDckIsZUFBT0EsU0FBUztBQUNwQjtNQUNBMFcsVUFBVSxDQUFDNUMsS0FBSyxFQUFFM04sS0FBSyxFQUFFcUMsTUFBTSxFQUFFcEIsT0FBTyxDQUFDO0FBQzdDO0dBQ0g7QUFDTDtBQUNBLFNBQVM4TyxTQUFTQSxDQUFDYSxNQUFNO0FBQUU7QUFDM0JKLE1BQU0sRUFBRTdDLEtBQUssRUFBRXJCLFFBQVEsRUFBRXJMLE9BQU8sRUFBRTtFQUM5QixJQUFJO0lBQUVvTixRQUFRO0FBQUUzTyxJQUFBQSxTQUFBQTtBQUFVLEdBQUMsR0FBR2lPLEtBQUs7RUFDbkMsSUFBSUEsS0FBSyxDQUFDa0QsS0FBSyxFQUFFO0lBQ2JELE1BQU0sR0FBR0EsTUFBTSxDQUFDakQsS0FBSyxDQUFDa0QsS0FBSyxDQUFDblIsU0FBUyxDQUFDO0FBQ3RDLFFBQUlrUixNQUFNLENBQUNFLElBQUksSUFBSXBSLFNBQVMsRUFBRTtNQUMxQixPQUFPa1IsTUFBTSxDQUFDNVEsS0FBSztBQUN2QjtJQUNBNFEsTUFBTSxDQUFDRSxJQUFJLEdBQUdwUixTQUFTO0FBQ3ZCQSxJQUFBQSxTQUFTLEdBQUcsT0FBTztBQUN2QjtFQUNBLFFBQVFpTyxLQUFLLENBQUNZLElBQUk7QUFDZCxTQUFLLFFBQVE7QUFDYixTQUFLLE1BQU07QUFDUCxZQUFNMkgsVUFBVSxHQUFHdkksS0FBSyxDQUFDWSxJQUFJLElBQUksTUFBTSxHQUFHOUYsVUFBVSxDQUFDZ0osS0FBSyxHQUFHOUQsS0FBSyxDQUFDYSxDQUFDO01BQ3BFLElBQUkySCxJQUFJLEdBQUc3QyxVQUFVO0FBQ3JCO01BQ0EsSUFBSTNGLEtBQUssQ0FBQ1ksSUFBSSxJQUFJLFFBQVEsSUFBSVosS0FBSyxDQUFDYyxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQ3ZDMEgsUUFBQUEsSUFBSSxHQUFHQyxrQkFBa0I7QUFDN0I7QUFDQSxVQUFJL0gsUUFBUSxFQUFFO0FBQ1YsWUFBSWdJLEdBQUcsR0FBR3pGLE1BQU0sQ0FBQ2xSLFNBQVMsQ0FBQyxDQUFDO0FBQzVCLGNBQU00VyxRQUFRLEdBQUdoSyxRQUFRLElBQUk1QyxRQUFRLENBQUNrRCxlQUFlLElBQ2pEc0osVUFBVSxJQUFJek4sVUFBVSxDQUFDZSxNQUFNLElBQy9CME0sVUFBVSxJQUFJek4sVUFBVSxDQUFDRyxLQUFLO0FBQ2xDLFlBQUkwTixRQUFRLEVBQUU7VUFDVixJQUFJaGQsQ0FBQyxHQUFHa1gsTUFBTSxDQUFDaEcsTUFBTSxFQUFFLEdBQUdnRyxNQUFNLENBQUN0TSxHQUFHO0FBQ3BDLGlCQUFPc00sTUFBTSxDQUFDdE0sR0FBRyxHQUFHNUssQ0FBQyxFQUFFO1lBQ25CK2MsR0FBRyxDQUFDbFcsSUFBSSxDQUFDZ1csSUFBSSxDQUFDM0YsTUFBTSxFQUFFMEYsVUFBVSxDQUFDLENBQUM7QUFDdEM7QUFDSixTQUFDLE1BQ0k7VUFDREcsR0FBRyxDQUFDbFcsSUFBSSxDQUFDZ1csSUFBSSxDQUFDM0YsTUFBTSxFQUFFMEYsVUFBVSxDQUFDLENBQUM7QUFDdEM7QUFDSixPQUFDLE1BQ0k7UUFDRHRGLE1BQU0sQ0FBQ2xSLFNBQVMsQ0FBQyxHQUFHeVcsSUFBSSxDQUFDM0YsTUFBTSxFQUFFMEYsVUFBVSxDQUFDO0FBQ2hEO0FBQ0E7QUFDSixTQUFLLFNBQVM7QUFDVixZQUFNekYsV0FBVyxHQUFHOUMsS0FBSyxDQUFDYSxDQUFDO0FBQzNCLFVBQUlILFFBQVEsRUFBRTtBQUNWO0FBQ0F1QyxRQUFBQSxNQUFNLENBQUNsUixTQUFTLENBQUMsQ0FBQ1MsSUFBSSxDQUFDb1csZ0JBQWdCLENBQUMvRixNQUFNLEVBQUUsSUFBSUMsV0FBVyxFQUFFLEVBQUV4UCxPQUFPLEVBQUUwTSxLQUFLLENBQUMsQ0FBQztBQUN2RixPQUFDLE1BQ0k7QUFDRCxZQUFJd0QsU0FBUyxDQUFDUCxNQUFNLENBQUNsUixTQUFTLENBQUMsQ0FBQyxFQUFFO1VBQzlCNlcsZ0JBQWdCLENBQUMvRixNQUFNLEVBQUVJLE1BQU0sQ0FBQ2xSLFNBQVMsQ0FBQyxFQUFFdUIsT0FBTyxFQUFFME0sS0FBSyxDQUFDO0FBQy9ELFNBQUMsTUFDSTtBQUNEaUQsVUFBQUEsTUFBTSxDQUFDbFIsU0FBUyxDQUFDLEdBQUc2VyxnQkFBZ0IsQ0FBQy9GLE1BQU0sRUFBRSxJQUFJQyxXQUFXLEVBQUUsRUFBRXhQLE9BQU8sRUFBRTBNLEtBQUssQ0FBQztBQUMvRSxjQUFJOEMsV0FBVyxDQUFDL0IsWUFBWSxJQUFJLENBQUNmLEtBQUssQ0FBQ2tELEtBQUssSUFBSSxDQUFDbEQsS0FBSyxDQUFDVSxRQUFRLEVBQUU7QUFDN0R1QyxZQUFBQSxNQUFNLENBQUNsUixTQUFTLENBQUMsR0FBRytRLFdBQVcsQ0FBQy9CLFlBQVksQ0FBQ0MsV0FBVyxDQUFDaUMsTUFBTSxDQUFDbFIsU0FBUyxDQUFDLENBQUM7QUFDL0U7QUFDSjtBQUNKO0FBQ0E7QUFDSixTQUFLLEtBQUs7QUFDTixVQUFJLENBQUM4VyxNQUFNLEVBQUVDLE1BQU0sQ0FBQyxHQUFHQyxZQUFZLENBQUMvSSxLQUFLLEVBQUU2QyxNQUFNLEVBQUV2UCxPQUFPLENBQUM7QUFDM0Q7QUFDQTJQLE1BQUFBLE1BQU0sQ0FBQ2xSLFNBQVMsQ0FBQyxDQUFDOFcsTUFBTSxDQUFDLEdBQUdDLE1BQU07QUFDbEM7QUFDUjtBQUNKO0FBQ0E7QUFDQTtBQUNBLFNBQVNGLGdCQUFnQkEsQ0FBQy9GLE1BQU0sRUFBRXZPLE9BQU8sRUFBRWhCLE9BQU8sRUFBRTBNLEtBQUssRUFBRTtFQUN2RCxNQUFNeE0sTUFBTSxHQUFHYyxPQUFPLENBQUN0QixPQUFPLEVBQUUsQ0FBQ0MsT0FBTyxDQUFDUSxHQUFHO0FBQzVDLFFBQU11VixTQUFTLEdBQUdoSixLQUFLLEtBQUssSUFBSSxJQUFJQSxLQUFLLEtBQUssS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUdBLEtBQUssQ0FBQ2dKLFNBQVM7QUFDL0V4VixFQUFBQSxNQUFNLENBQUNHLFdBQVcsQ0FBQ1csT0FBTyxFQUFFdU8sTUFBTSxFQUFFbUcsU0FBUyxHQUFHaEosS0FBSyxDQUFDbE8sRUFBRSxHQUFHK1EsTUFBTSxDQUFDaEcsTUFBTSxFQUFFO0FBQUU7RUFDNUV2SixPQUFPLEVBQUUwVixTQUFTLENBQUM7QUFDbkIsU0FBTzFVLE9BQU87QUFDbEI7QUFDQTtBQUNBLFNBQVN5VSxZQUFZQSxDQUFDL0ksS0FBSyxFQUFFNkMsTUFBTSxFQUFFdlAsT0FBTyxFQUFFO0FBQzFDLFFBQU0vRyxNQUFNLEdBQUdzVyxNQUFNLENBQUNoRyxNQUFNLEVBQUU7QUFBRXJGLElBQUFBLEdBQUcsR0FBR3FMLE1BQU0sQ0FBQ3RNLEdBQUcsR0FBR2hLLE1BQU07RUFDekQsSUFBSStaLEdBQUcsRUFBRXVCLEdBQUc7QUFDWixTQUFPaEYsTUFBTSxDQUFDdE0sR0FBRyxHQUFHaUIsR0FBRyxFQUFFO0lBQ3JCLE1BQU0sQ0FBQ3dGLE9BQU8sQ0FBQyxHQUFHNkYsTUFBTSxDQUFDOUYsR0FBRyxFQUFFO0FBQzlCLFlBQVFDLE9BQU87QUFDWCxXQUFLLENBQUM7UUFDRnNKLEdBQUcsR0FBR1gsVUFBVSxDQUFDOUMsTUFBTSxFQUFFN0MsS0FBSyxDQUFDd0csQ0FBQyxDQUFDO0FBQ2pDO0FBQ0osV0FBSyxDQUFDO0FBQ0YsZ0JBQVF4RyxLQUFLLENBQUN5RyxDQUFDLENBQUM3RixJQUFJO0FBQ2hCLGVBQUssUUFBUTtZQUNUaUgsR0FBRyxHQUFHbEMsVUFBVSxDQUFDOUMsTUFBTSxFQUFFN0MsS0FBSyxDQUFDeUcsQ0FBQyxDQUFDNUYsQ0FBQyxDQUFDO0FBQ25DO0FBQ0osZUFBSyxNQUFNO0FBQ1BnSCxZQUFBQSxHQUFHLEdBQUdoRixNQUFNLENBQUM1RixLQUFLLEVBQUU7QUFDcEI7QUFDSixlQUFLLFNBQVM7QUFDVjRLLFlBQUFBLEdBQUcsR0FBR2UsZ0JBQWdCLENBQUMvRixNQUFNLEVBQUUsSUFBSTdDLEtBQUssQ0FBQ3lHLENBQUMsQ0FBQzVGLENBQUMsRUFBRSxFQUFFdk4sT0FBTyxFQUFFcEgsU0FBUyxDQUFDO0FBQ25FO0FBQ1I7QUFDQTtBQUNSO0FBQ0o7RUFDQSxJQUFJb2EsR0FBRyxLQUFLcGEsU0FBUyxFQUFFO0lBQ25Cb2EsR0FBRyxHQUFHOUssZUFBZSxDQUFDd0UsS0FBSyxDQUFDd0csQ0FBQyxFQUFFekwsUUFBUSxDQUFDNkssTUFBTSxDQUFDO0FBQ25EO0VBQ0EsSUFBSSxPQUFPVSxHQUFHLElBQUksUUFBUSxJQUFJLE9BQU9BLEdBQUcsSUFBSSxRQUFRLEVBQUU7QUFDbERBLElBQUFBLEdBQUcsR0FBR0EsR0FBRyxDQUFDNU4sUUFBUSxFQUFFO0FBQ3hCO0VBQ0EsSUFBSW1QLEdBQUcsS0FBSzNiLFNBQVMsRUFBRTtBQUNuQixZQUFROFQsS0FBSyxDQUFDeUcsQ0FBQyxDQUFDN0YsSUFBSTtBQUNoQixXQUFLLFFBQVE7QUFDVGlILFFBQUFBLEdBQUcsR0FBR3JNLGVBQWUsQ0FBQ3dFLEtBQUssQ0FBQ3lHLENBQUMsQ0FBQzVGLENBQUMsRUFBRTlGLFFBQVEsQ0FBQzZLLE1BQU0sQ0FBQztBQUNqRDtBQUNKLFdBQUssTUFBTTtBQUNQaUMsUUFBQUEsR0FBRyxHQUFHN0gsS0FBSyxDQUFDeUcsQ0FBQyxDQUFDNUYsQ0FBQyxDQUFDN1EsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDOEIsRUFBRTtBQUM1QjtBQUNKLFdBQUssU0FBUztRQUNWK1YsR0FBRyxHQUFHLElBQUk3SCxLQUFLLENBQUN5RyxDQUFDLENBQUM1RixDQUFDLEVBQUU7QUFDckI7QUFDUjtBQUNKO0FBQ0EsU0FBTyxDQUFDeUYsR0FBRyxFQUFFdUIsR0FBRyxDQUFDO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFNBQVNZLGtCQUFrQkEsQ0FBQzVGLE1BQU0sRUFBRXRQLElBQUksRUFBRTtBQUN0QyxRQUFNMUIsQ0FBQyxHQUFHOFQsVUFBVSxDQUFDOUMsTUFBTSxFQUFFdFAsSUFBSSxDQUFDO0VBQ2xDLE9BQU8sT0FBTzFCLENBQUMsSUFBSSxRQUFRLEdBQUdBLENBQUMsQ0FBQzZHLFFBQVEsRUFBRSxHQUFHN0csQ0FBQztBQUNsRDtBQUNBO0FBQ0EsU0FBUzhULFVBQVVBLENBQUM5QyxNQUFNLEVBQUV0UCxJQUFJLEVBQUU7QUFDOUIsVUFBUUEsSUFBSTtJQUNSLEtBQUt1SCxVQUFVLENBQUNlLE1BQU07QUFDbEIsYUFBT2dILE1BQU0sQ0FBQzFGLE1BQU0sRUFBRTtJQUMxQixLQUFLckMsVUFBVSxDQUFDWSxJQUFJO0FBQ2hCLGFBQU9tSCxNQUFNLENBQUMzRixJQUFJLEVBQUU7SUFDeEIsS0FBS3BDLFVBQVUsQ0FBQ2EsTUFBTTtBQUNsQixhQUFPa0gsTUFBTSxDQUFDckYsTUFBTSxFQUFFO0lBQzFCLEtBQUsxQyxVQUFVLENBQUNjLEtBQUs7QUFDakIsYUFBT2lILE1BQU0sQ0FBQ3hGLEtBQUssRUFBRTtJQUN6QixLQUFLdkMsVUFBVSxDQUFDZ0osS0FBSztBQUNqQixhQUFPakIsTUFBTSxDQUFDNUYsS0FBSyxFQUFFO0lBQ3pCLEtBQUtuQyxVQUFVLENBQUNPLEtBQUs7QUFDakIsYUFBT3dILE1BQU0sQ0FBQzNFLEtBQUssRUFBRTtJQUN6QixLQUFLcEQsVUFBVSxDQUFDSyxNQUFNO0FBQ2xCLGFBQU8wSCxNQUFNLENBQUN4RSxNQUFNLEVBQUU7SUFDMUIsS0FBS3ZELFVBQVUsQ0FBQ00sT0FBTztBQUNuQixhQUFPeUgsTUFBTSxDQUFDNUUsT0FBTyxFQUFFO0lBQzNCLEtBQUtuRCxVQUFVLENBQUNHLEtBQUs7QUFDakIsYUFBTzRILE1BQU0sQ0FBQ3hQLEtBQUssRUFBRTtJQUN6QixLQUFLeUgsVUFBVSxDQUFDb00sT0FBTztBQUNuQixhQUFPckUsTUFBTSxDQUFDbkYsT0FBTyxFQUFFO0lBQzNCLEtBQUs1QyxVQUFVLENBQUNxTSxRQUFRO0FBQ3BCLGFBQU90RSxNQUFNLENBQUNqRixRQUFRLEVBQUU7SUFDNUIsS0FBSzlDLFVBQVUsQ0FBQ1EsUUFBUTtBQUNwQixhQUFPdUgsTUFBTSxDQUFDL0UsUUFBUSxFQUFFO0lBQzVCLEtBQUtoRCxVQUFVLENBQUNTLE1BQU07QUFDbEIsYUFBT3NILE1BQU0sQ0FBQzFFLE1BQU0sRUFBRTtJQUMxQixLQUFLckQsVUFBVSxDQUFDaUosTUFBTTtBQUNsQixhQUFPbEIsTUFBTSxDQUFDaEcsTUFBTSxFQUFFO0lBQzFCLEtBQUsvQixVQUFVLENBQUNzTSxNQUFNO0FBQ2xCLGFBQU92RSxNQUFNLENBQUNoRixNQUFNLEVBQUU7QUFDOUI7QUFDSjtBQUNBLFNBQVMrRSxVQUFVQSxDQUFDNUMsS0FBSyxFQUFFM04sS0FBSyxFQUFFcUMsTUFBTSxFQUFFcEIsT0FBTyxFQUFFO0FBQy9DbEQsRUFBQUEsTUFBTSxDQUFDaUMsS0FBSyxLQUFLbkcsU0FBUyxDQUFDO0FBQzNCLFFBQU13VSxRQUFRLEdBQUdWLEtBQUssQ0FBQ1UsUUFBUTtFQUMvQixRQUFRVixLQUFLLENBQUNZLElBQUk7QUFDZCxTQUFLLFFBQVE7QUFDYixTQUFLLE1BQU07QUFDUCxVQUFJMkgsVUFBVSxHQUFHdkksS0FBSyxDQUFDWSxJQUFJLElBQUksTUFBTSxHQUFHOUYsVUFBVSxDQUFDZ0osS0FBSyxHQUFHOUQsS0FBSyxDQUFDYSxDQUFDO0FBQ2xFLFVBQUlILFFBQVEsRUFBRTtBQUNWdFEsUUFBQUEsTUFBTSxDQUFDb1UsS0FBSyxDQUFDQyxPQUFPLENBQUNwUyxLQUFLLENBQUMsQ0FBQztRQUM1QixJQUFJMk4sS0FBSyxDQUFDaUosTUFBTSxFQUFFO1VBQ2RDLFdBQVcsQ0FBQ3hVLE1BQU0sRUFBRTZULFVBQVUsRUFBRXZJLEtBQUssQ0FBQ2xPLEVBQUUsRUFBRU8sS0FBSyxDQUFDO0FBQ3BELFNBQUMsTUFDSTtBQUNELGVBQUssTUFBTThXLElBQUksSUFBSTlXLEtBQUssRUFBRTtZQUN0QndULFdBQVcsQ0FBQ25SLE1BQU0sRUFBRTZULFVBQVUsRUFBRXZJLEtBQUssQ0FBQ2xPLEVBQUUsRUFBRXFYLElBQUksQ0FBQztBQUNuRDtBQUNKO0FBQ0osT0FBQyxNQUNJO1FBQ0R0RCxXQUFXLENBQUNuUixNQUFNLEVBQUU2VCxVQUFVLEVBQUV2SSxLQUFLLENBQUNsTyxFQUFFLEVBQUVPLEtBQUssQ0FBQztBQUNwRDtBQUNBO0FBQ0osU0FBSyxTQUFTO0FBQ1YsVUFBSXFPLFFBQVEsRUFBRTtBQUNWdFEsUUFBQUEsTUFBTSxDQUFDb1UsS0FBSyxDQUFDQyxPQUFPLENBQUNwUyxLQUFLLENBQUMsQ0FBQztBQUM1QixhQUFLLE1BQU04VyxJQUFJLElBQUk5VyxLQUFLLEVBQUU7VUFDdEIrVyxpQkFBaUIsQ0FBQzFVLE1BQU0sRUFBRXBCLE9BQU8sRUFBRTBNLEtBQUssRUFBRW1KLElBQUksQ0FBQztBQUNuRDtBQUNKLE9BQUMsTUFDSTtRQUNEQyxpQkFBaUIsQ0FBQzFVLE1BQU0sRUFBRXBCLE9BQU8sRUFBRTBNLEtBQUssRUFBRTNOLEtBQUssQ0FBQztBQUNwRDtBQUNBO0FBQ0osU0FBSyxLQUFLO01BQ05qQyxNQUFNLENBQUMsT0FBT2lDLEtBQUssSUFBSSxRQUFRLElBQUlBLEtBQUssSUFBSSxJQUFJLENBQUM7QUFDakQsV0FBSyxNQUFNLENBQUNpVSxHQUFHLEVBQUV1QixHQUFHLENBQUMsSUFBSTlYLE1BQU0sQ0FBQ2lWLE9BQU8sQ0FBQzNTLEtBQUssQ0FBQyxFQUFFO1FBQzVDZ1gsYUFBYSxDQUFDM1UsTUFBTSxFQUFFcEIsT0FBTyxFQUFFME0sS0FBSyxFQUFFc0csR0FBRyxFQUFFdUIsR0FBRyxDQUFDO0FBQ25EO0FBQ0E7QUFDUjtBQUNKO0FBQ08sU0FBU3dCLGFBQWFBLENBQUMzVSxNQUFNLEVBQUVwQixPQUFPLEVBQUUwTSxLQUFLLEVBQUVzRyxHQUFHLEVBQUVqVSxLQUFLLEVBQUU7RUFDOURxQyxNQUFNLENBQUNxSSxHQUFHLENBQUNpRCxLQUFLLENBQUNsTyxFQUFFLEVBQUVpSyxRQUFRLENBQUNrRCxlQUFlLENBQUM7RUFDOUN2SyxNQUFNLENBQUM4SCxJQUFJLEVBQUU7QUFDYjtBQUNBO0VBQ0EsSUFBSThNLFFBQVEsR0FBR2hELEdBQUc7QUFDbEI7RUFDQSxRQUFRdEcsS0FBSyxDQUFDd0csQ0FBQztJQUNYLEtBQUsxTCxVQUFVLENBQUNnSixLQUFLO0lBQ3JCLEtBQUtoSixVQUFVLENBQUNvTSxPQUFPO0lBQ3ZCLEtBQUtwTSxVQUFVLENBQUNpSixNQUFNO0lBQ3RCLEtBQUtqSixVQUFVLENBQUNxTSxRQUFRO0lBQ3hCLEtBQUtyTSxVQUFVLENBQUNzTSxNQUFNO0FBQ2xCa0MsTUFBQUEsUUFBUSxHQUFHdlksTUFBTSxDQUFDd1ksUUFBUSxDQUFDakQsR0FBRyxDQUFDO0FBQy9CO0lBQ0osS0FBS3hMLFVBQVUsQ0FBQ1ksSUFBSTtNQUNoQnRMLE1BQU0sQ0FBQ2tXLEdBQUcsSUFBSSxNQUFNLElBQUlBLEdBQUcsSUFBSSxPQUFPLENBQUM7TUFDdkNnRCxRQUFRLEdBQUdoRCxHQUFHLElBQUksTUFBTTtBQUN4QjtBQUNSO0FBQ0E7RUFDQVQsV0FBVyxDQUFDblIsTUFBTSxFQUFFc0wsS0FBSyxDQUFDd0csQ0FBQyxFQUFFLENBQUMsRUFBRThDLFFBQVEsQ0FBQztBQUN6QztBQUNBLFVBQVF0SixLQUFLLENBQUN5RyxDQUFDLENBQUM3RixJQUFJO0FBQ2hCLFNBQUssUUFBUTtBQUNUaUYsTUFBQUEsV0FBVyxDQUFDblIsTUFBTSxFQUFFc0wsS0FBSyxDQUFDeUcsQ0FBQyxDQUFDNUYsQ0FBQyxFQUFFLENBQUMsRUFBRXhPLEtBQUssQ0FBQztBQUN4QztBQUNKLFNBQUssTUFBTTtNQUNQd1QsV0FBVyxDQUFDblIsTUFBTSxFQUFFb0csVUFBVSxDQUFDZ0osS0FBSyxFQUFFLENBQUMsRUFBRXpSLEtBQUssQ0FBQztBQUMvQztBQUNKLFNBQUssU0FBUztBQUNWakMsTUFBQUEsTUFBTSxDQUFDaUMsS0FBSyxLQUFLbkcsU0FBUyxDQUFDO0FBQzNCd0ksTUFBQUEsTUFBTSxDQUFDcUksR0FBRyxDQUFDLENBQUMsRUFBRWhCLFFBQVEsQ0FBQ2tELGVBQWUsQ0FBQyxDQUFDNUwsS0FBSyxDQUFDaEIsS0FBSyxDQUFDbUMsUUFBUSxDQUFDbEIsT0FBTyxDQUFDLENBQUM7QUFDdEU7QUFDUjtFQUNBb0IsTUFBTSxDQUFDK0gsSUFBSSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTMk0saUJBQWlCQSxDQUFDMVUsTUFBTSxFQUFFcEIsT0FBTyxFQUFFME0sS0FBSyxFQUFFM04sS0FBSyxFQUFFO0VBQ3RELE1BQU1pQyxPQUFPLEdBQUd1UCxTQUFTLENBQUM3RCxLQUFLLENBQUNhLENBQUMsRUFBRXhPLEtBQUssQ0FBQztBQUN6QztBQUNBLE1BQUkyTixLQUFLLENBQUNnSixTQUFTLEVBQ2Z0VSxNQUFNLENBQ0RxSSxHQUFHLENBQUNpRCxLQUFLLENBQUNsTyxFQUFFLEVBQUVpSyxRQUFRLENBQUNtRCxVQUFVLENBQUMsQ0FDbENwQyxHQUFHLENBQUN4SSxPQUFPLENBQUNFLFFBQVEsQ0FBQ2xCLE9BQU8sQ0FBQyxDQUFDLENBQzlCeUosR0FBRyxDQUFDaUQsS0FBSyxDQUFDbE8sRUFBRSxFQUFFaUssUUFBUSxDQUFDc0QsUUFBUSxDQUFDLENBQUMsS0FFdEMzSyxNQUFNLENBQ0RxSSxHQUFHLENBQUNpRCxLQUFLLENBQUNsTyxFQUFFLEVBQUVpSyxRQUFRLENBQUNrRCxlQUFlLENBQUMsQ0FDdkM1TCxLQUFLLENBQUNpQixPQUFPLENBQUNFLFFBQVEsQ0FBQ2xCLE9BQU8sQ0FBQyxDQUFDO0FBQzdDO0FBQ0EsU0FBU3VTLFdBQVdBLENBQUNuUixNQUFNLEVBQUVuQixJQUFJLEVBQUV5SixPQUFPLEVBQUUzSyxLQUFLLEVBQUU7QUFDL0NqQyxFQUFBQSxNQUFNLENBQUNpQyxLQUFLLEtBQUtuRyxTQUFTLENBQUM7RUFDM0IsSUFBSSxDQUFDeVMsUUFBUSxFQUFFclQsTUFBTSxDQUFDLEdBQUdrZSxjQUFjLENBQUNqVyxJQUFJLENBQUM7QUFDN0NtQixFQUFBQSxNQUFNLENBQUNxSSxHQUFHLENBQUNDLE9BQU8sRUFBRTJCLFFBQVEsQ0FBQyxDQUFDclQsTUFBTSxDQUFDLENBQUMrRyxLQUFLLENBQUM7QUFDaEQ7QUFDQSxTQUFTNlcsV0FBV0EsQ0FBQ3hVLE1BQU0sRUFBRW5CLElBQUksRUFBRXlKLE9BQU8sRUFBRTNLLEtBQUssRUFBRTtBQUMvQyxNQUFJLENBQUNBLEtBQUssQ0FBQzlGLE1BQU0sRUFBRTtBQUNmO0FBQ0o7QUFDQW1JLEVBQUFBLE1BQU0sQ0FBQ3FJLEdBQUcsQ0FBQ0MsT0FBTyxFQUFFakIsUUFBUSxDQUFDa0QsZUFBZSxDQUFDLENBQUN6QyxJQUFJLEVBQUU7QUFDcEQsTUFBSSxHQUFHbFIsTUFBTSxDQUFDLEdBQUdrZSxjQUFjLENBQUNqVyxJQUFJLENBQUM7QUFDckMsT0FBSyxJQUFJakgsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHK0YsS0FBSyxDQUFDOUYsTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRTtJQUNuQ29JLE1BQU0sQ0FBQ3BKLE1BQU0sQ0FBQyxDQUFDK0csS0FBSyxDQUFDL0YsQ0FBQyxDQUFDLENBQUM7QUFDNUI7RUFDQW9JLE1BQU0sQ0FBQytILElBQUksRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTK00sY0FBY0EsQ0FBQ2pXLElBQUksRUFBRTtBQUMxQixNQUFJb0wsUUFBUSxHQUFHNUMsUUFBUSxDQUFDK0MsTUFBTTtBQUM5QjtBQUNBLFVBQVF2TCxJQUFJO0lBQ1IsS0FBS3VILFVBQVUsQ0FBQ0csS0FBSztJQUNyQixLQUFLSCxVQUFVLENBQUNlLE1BQU07TUFDbEI4QyxRQUFRLEdBQUc1QyxRQUFRLENBQUNrRCxlQUFlO0FBQ25DO0lBQ0osS0FBS25FLFVBQVUsQ0FBQ2EsTUFBTTtJQUN0QixLQUFLYixVQUFVLENBQUNNLE9BQU87SUFDdkIsS0FBS04sVUFBVSxDQUFDUSxRQUFRO01BQ3BCcUQsUUFBUSxHQUFHNUMsUUFBUSxDQUFDZ0QsS0FBSztBQUN6QjtJQUNKLEtBQUtqRSxVQUFVLENBQUNvTSxPQUFPO0lBQ3ZCLEtBQUtwTSxVQUFVLENBQUNxTSxRQUFRO0lBQ3hCLEtBQUtyTSxVQUFVLENBQUNjLEtBQUs7TUFDakIrQyxRQUFRLEdBQUc1QyxRQUFRLENBQUNpRCxLQUFLO0FBQ3pCO0FBQ1I7RUFDQSxNQUFNMVQsTUFBTSxHQUFHd1AsVUFBVSxDQUFDdkgsSUFBSSxDQUFDLENBQUNrVyxXQUFXLEVBQUU7QUFDN0MsU0FBTyxDQUFDOUssUUFBUSxFQUFFclQsTUFBTSxDQUFDO0FBQzdCOztBQzFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ08sU0FBU29lLGNBQWNBLEdBQUc7RUFDN0IsT0FBTztJQUNIalksV0FBVztBQUNYb0UsSUFBQUEsV0FBV0EsQ0FBQzhULE1BQU0sRUFBRTFHLE1BQU0sRUFBRTtNQUN4QixJQUFJMEcsTUFBTSxLQUFLemQsU0FBUyxFQUFFO0FBQ3RCO0FBQ0o7QUFDQSxZQUFNcUgsSUFBSSxHQUFHMFAsTUFBTSxDQUFDalEsT0FBTyxFQUFFO01BQzdCLEtBQUssTUFBTTRXLE1BQU0sSUFBSXJXLElBQUksQ0FBQ2lDLE1BQU0sQ0FBQ3FVLFFBQVEsRUFBRSxFQUFFO0FBQ3pDLGNBQU05WCxTQUFTLEdBQUc2WCxNQUFNLENBQUM3WCxTQUFTO0FBQUVQLFVBQUFBLENBQUMsR0FBR3lSLE1BQU07QUFBRXhELFVBQUFBLENBQUMsR0FBR2tLLE1BQU07QUFDMUQsWUFBSWxLLENBQUMsQ0FBQzFOLFNBQVMsQ0FBQyxJQUFJLElBQUksRUFBRTtBQUN0QjtBQUNBO0FBQ0o7UUFDQSxRQUFRNlgsTUFBTSxDQUFDaEosSUFBSTtBQUNmLGVBQUssT0FBTztBQUNSLGtCQUFNa0osRUFBRSxHQUFHckssQ0FBQyxDQUFDMU4sU0FBUyxDQUFDLENBQUNvUixJQUFJO1lBQzVCLElBQUkyRyxFQUFFLEtBQUs1ZCxTQUFTLEVBQUU7QUFDbEI7QUFDSjtBQUNBLGtCQUFNNmQsV0FBVyxHQUFHSCxNQUFNLENBQUNJLFNBQVMsQ0FBQ0YsRUFBRSxDQUFDO0FBQ3hDLGdCQUFJakMsR0FBRyxHQUFHcEksQ0FBQyxDQUFDMU4sU0FBUyxDQUFDLENBQUNNLEtBQUs7QUFDNUIsZ0JBQUkwWCxXQUFXLElBQ1hBLFdBQVcsQ0FBQ25KLElBQUksSUFBSSxTQUFTLElBQzdCLENBQUM0QyxTQUFTLENBQUNxRSxHQUFHLEVBQUVrQyxXQUFXLENBQUNsSixDQUFDLENBQUMsRUFBRTtBQUNoQ2dILGNBQUFBLEdBQUcsR0FBRyxJQUFJa0MsV0FBVyxDQUFDbEosQ0FBQyxDQUFDZ0gsR0FBRyxDQUFDO0FBQ2hDLGFBQUMsTUFDSSxJQUFJa0MsV0FBVyxJQUNoQkEsV0FBVyxDQUFDbkosSUFBSSxLQUFLLFFBQVEsSUFDN0JtSixXQUFXLENBQUNsSixDQUFDLEtBQUsvRixVQUFVLENBQUNHLEtBQUssRUFBRTtBQUNwQzRNLGNBQUFBLEdBQUcsR0FBR29DLE9BQU8sQ0FBQ3BDLEdBQUcsQ0FBQztBQUN0QjtZQUNBclcsQ0FBQyxDQUFDTyxTQUFTLENBQUMsR0FBRztBQUFFb1IsY0FBQUEsSUFBSSxFQUFFMkcsRUFBRTtBQUFFelgsY0FBQUEsS0FBSyxFQUFFd1YsR0FBQUE7YUFBSztBQUN2QztBQUNKLGVBQUssUUFBUTtBQUNiLGVBQUssTUFBTTtBQUNQLGdCQUFJcUMsSUFBSSxHQUFHekssQ0FBQyxDQUFDMU4sU0FBUyxDQUFDO0FBQ3ZCLGdCQUFJNlgsTUFBTSxDQUFDL0ksQ0FBQyxLQUFLL0YsVUFBVSxDQUFDRyxLQUFLLEVBQUU7QUFDL0JpUCxjQUFBQSxJQUFJLEdBQUdOLE1BQU0sQ0FBQ2xKLFFBQVEsR0FDaEJ3SixJQUFJLENBQUNqYSxHQUFHLENBQUNnYSxPQUFPLENBQUMsR0FDakJBLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDO0FBQ3ZCO0FBQ0ExWSxZQUFBQSxDQUFDLENBQUNPLFNBQVMsQ0FBQyxHQUFHbVksSUFBSTtBQUNuQjtBQUNKLGVBQUssS0FBSztBQUNOLG9CQUFRTixNQUFNLENBQUNuRCxDQUFDLENBQUM3RixJQUFJO0FBQ2pCLG1CQUFLLFFBQVE7QUFDYixtQkFBSyxNQUFNO2dCQUNQLElBQUlnSixNQUFNLENBQUNuRCxDQUFDLENBQUM1RixDQUFDLEtBQUsvRixVQUFVLENBQUNHLEtBQUssRUFBRTtBQUNqQyx1QkFBSyxNQUFNLENBQUNrUCxDQUFDLEVBQUV0WSxDQUFDLENBQUMsSUFBSTlCLE1BQU0sQ0FBQ2lWLE9BQU8sQ0FBQ3ZGLENBQUMsQ0FBQzFOLFNBQVMsQ0FBQyxDQUFDLEVBQUU7b0JBQy9DUCxDQUFDLENBQUNPLFNBQVMsQ0FBQyxDQUFDb1ksQ0FBQyxDQUFDLEdBQUdGLE9BQU8sQ0FBQ3BZLENBQUMsQ0FBQztBQUNoQztBQUNKLGlCQUFDLE1BQ0k7QUFDRDlCLGtCQUFBQSxNQUFNLENBQUM2QyxNQUFNLENBQUNwQixDQUFDLENBQUNPLFNBQVMsQ0FBQyxFQUFFME4sQ0FBQyxDQUFDMU4sU0FBUyxDQUFDLENBQUM7QUFDN0M7QUFDQTtBQUNKLG1CQUFLLFNBQVM7QUFDVixzQkFBTStRLFdBQVcsR0FBRzhHLE1BQU0sQ0FBQ25ELENBQUMsQ0FBQzVGLENBQUM7QUFDOUIscUJBQUssTUFBTXNKLENBQUMsSUFBSXBhLE1BQU0sQ0FBQ3NULElBQUksQ0FBQzVELENBQUMsQ0FBQzFOLFNBQVMsQ0FBQyxDQUFDLEVBQUU7a0JBQ3ZDLElBQUk4VixHQUFHLEdBQUdwSSxDQUFDLENBQUMxTixTQUFTLENBQUMsQ0FBQ29ZLENBQUMsQ0FBQztBQUN6QixzQkFBSSxDQUFDckgsV0FBVyxDQUFDL0IsWUFBWSxFQUFFO0FBQzNCO0FBQ0E7QUFDQThHLG9CQUFBQSxHQUFHLEdBQUcsSUFBSS9FLFdBQVcsQ0FBQytFLEdBQUcsQ0FBQztBQUM5QjtBQUNBclcsa0JBQUFBLENBQUMsQ0FBQ08sU0FBUyxDQUFDLENBQUNvWSxDQUFDLENBQUMsR0FBR3RDLEdBQUc7QUFDekI7QUFDQTtBQUNSO0FBQ0E7QUFDSixlQUFLLFNBQVM7QUFDVixrQkFBTXVDLEVBQUUsR0FBR1IsTUFBTSxDQUFDL0ksQ0FBQztZQUNuQixJQUFJK0ksTUFBTSxDQUFDbEosUUFBUSxFQUFFO2NBQ2pCbFAsQ0FBQyxDQUFDTyxTQUFTLENBQUMsR0FBRzBOLENBQUMsQ0FBQzFOLFNBQVMsQ0FBQyxDQUFDOUIsR0FBRyxDQUFFNFgsR0FBRyxJQUFLckUsU0FBUyxDQUFDcUUsR0FBRyxFQUFFdUMsRUFBRSxDQUFDLEdBQUd2QyxHQUFHLEdBQUcsSUFBSXVDLEVBQUUsQ0FBQ3ZDLEdBQUcsQ0FBQyxDQUFDO0FBQ3BGLGFBQUMsTUFDSTtBQUNELG9CQUFNQSxHQUFHLEdBQUdwSSxDQUFDLENBQUMxTixTQUFTLENBQUM7Y0FDeEIsSUFBSXFZLEVBQUUsQ0FBQ3JKLFlBQVksRUFBRTtBQUNqQjtBQUNBO0FBQ0FxSixnQkFBQUEsRUFBRSxDQUFDMVksUUFBUSxLQUFLLDRCQUE0QixFQUFFO0FBQzFDRixrQkFBQUEsQ0FBQyxDQUFDTyxTQUFTLENBQUMsR0FBR2tZLE9BQU8sQ0FBQ3BDLEdBQUcsQ0FBQztBQUMvQixpQkFBQyxNQUNJO0FBQ0RyVyxrQkFBQUEsQ0FBQyxDQUFDTyxTQUFTLENBQUMsR0FBRzhWLEdBQUc7QUFDdEI7QUFDSixlQUFDLE1BQ0k7QUFDRHJXLGdCQUFBQSxDQUFDLENBQUNPLFNBQVMsQ0FBQyxHQUFHeVIsU0FBUyxDQUFDcUUsR0FBRyxFQUFFdUMsRUFBRSxDQUFDLEdBQUd2QyxHQUFHLEdBQUcsSUFBSXVDLEVBQUUsQ0FBQ3ZDLEdBQUcsQ0FBQztBQUN6RDtBQUNKO0FBQ0E7QUFDUjtBQUNKO0tBQ0g7QUFDRDtBQUNBL1UsSUFBQUEsTUFBTUEsQ0FBQ1MsSUFBSSxFQUFFeUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7TUFDZixJQUFJRCxDQUFDLEtBQUtDLENBQUMsRUFBRTtBQUNULGVBQU8sSUFBSTtBQUNmO0FBQ0EsVUFBSSxDQUFDRCxDQUFDLElBQUksQ0FBQ0MsQ0FBQyxFQUFFO0FBQ1YsZUFBTyxLQUFLO0FBQ2hCO01BQ0EsT0FBTzFDLElBQUksQ0FBQ2lDLE1BQU0sQ0FBQ3FVLFFBQVEsRUFBRSxDQUFDbkcsS0FBSyxDQUFFQyxDQUFDLElBQUs7QUFDdkMsY0FBTTBHLEVBQUUsR0FBR3JVLENBQUMsQ0FBQzJOLENBQUMsQ0FBQzVSLFNBQVMsQ0FBQztBQUN6QixjQUFNdVksRUFBRSxHQUFHclUsQ0FBQyxDQUFDME4sQ0FBQyxDQUFDNVIsU0FBUyxDQUFDO1FBQ3pCLElBQUk0UixDQUFDLENBQUNqRCxRQUFRLEVBQUU7QUFDWixjQUFJMkosRUFBRSxDQUFDOWQsTUFBTSxLQUFLK2QsRUFBRSxDQUFDL2QsTUFBTSxFQUFFO0FBQ3pCLG1CQUFPLEtBQUs7QUFDaEI7QUFDQTtVQUNBLFFBQVFvWCxDQUFDLENBQUMvQyxJQUFJO0FBQ1YsaUJBQUssU0FBUztjQUNWLE9BQU95SixFQUFFLENBQUMzRyxLQUFLLENBQUMsQ0FBQzFOLENBQUMsRUFBRTFKLENBQUMsS0FBS3FYLENBQUMsQ0FBQzlDLENBQUMsQ0FBQy9OLE1BQU0sQ0FBQ2tELENBQUMsRUFBRXNVLEVBQUUsQ0FBQ2hlLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbkQsaUJBQUssUUFBUTtjQUNULE9BQU8rZCxFQUFFLENBQUMzRyxLQUFLLENBQUMsQ0FBQzFOLENBQUMsRUFBRTFKLENBQUMsS0FBSzBPLFlBQVksQ0FBQzJJLENBQUMsQ0FBQzlDLENBQUMsRUFBRTdLLENBQUMsRUFBRXNVLEVBQUUsQ0FBQ2hlLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDMUQsaUJBQUssTUFBTTtjQUNQLE9BQU8rZCxFQUFFLENBQUMzRyxLQUFLLENBQUMsQ0FBQzFOLENBQUMsRUFBRTFKLENBQUMsS0FBSzBPLFlBQVksQ0FBQ0YsVUFBVSxDQUFDZ0osS0FBSyxFQUFFOU4sQ0FBQyxFQUFFc1UsRUFBRSxDQUFDaGUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzRTtVQUNBLE1BQU0sSUFBSWlFLEtBQUssQ0FBQThELDBCQUFBQSxDQUFBQSxNQUFBLENBQTRCc1AsQ0FBQyxDQUFDL0MsSUFBSSxDQUFFLENBQUM7QUFDeEQ7UUFDQSxRQUFRK0MsQ0FBQyxDQUFDL0MsSUFBSTtBQUNWLGVBQUssU0FBUztZQUNWLE9BQU8rQyxDQUFDLENBQUM5QyxDQUFDLENBQUMvTixNQUFNLENBQUN1WCxFQUFFLEVBQUVDLEVBQUUsQ0FBQztBQUM3QixlQUFLLE1BQU07WUFDUCxPQUFPdFAsWUFBWSxDQUFDRixVQUFVLENBQUNnSixLQUFLLEVBQUV1RyxFQUFFLEVBQUVDLEVBQUUsQ0FBQztBQUNqRCxlQUFLLFFBQVE7WUFDVCxPQUFPdFAsWUFBWSxDQUFDMkksQ0FBQyxDQUFDOUMsQ0FBQyxFQUFFd0osRUFBRSxFQUFFQyxFQUFFLENBQUM7QUFDcEMsZUFBSyxPQUFPO0FBQ1IsZ0JBQUlELEVBQUUsQ0FBQ2xILElBQUksS0FBS21ILEVBQUUsQ0FBQ25ILElBQUksRUFBRTtBQUNyQixxQkFBTyxLQUFLO0FBQ2hCO1lBQ0EsTUFBTTFELENBQUMsR0FBR2tFLENBQUMsQ0FBQ3FHLFNBQVMsQ0FBQ0ssRUFBRSxDQUFDbEgsSUFBSSxDQUFDO1lBQzlCLElBQUkxRCxDQUFDLEtBQUt2VCxTQUFTLEVBQUU7QUFDakIscUJBQU8sSUFBSTtBQUNmO0FBQ0E7WUFDQSxRQUFRdVQsQ0FBQyxDQUFDbUIsSUFBSTtBQUNWLG1CQUFLLFNBQVM7QUFDVix1QkFBT25CLENBQUMsQ0FBQ29CLENBQUMsQ0FBQy9OLE1BQU0sQ0FBQ3VYLEVBQUUsQ0FBQ2hZLEtBQUssRUFBRWlZLEVBQUUsQ0FBQ2pZLEtBQUssQ0FBQztBQUN6QyxtQkFBSyxNQUFNO0FBQ1AsdUJBQU8ySSxZQUFZLENBQUNGLFVBQVUsQ0FBQ2dKLEtBQUssRUFBRXVHLEVBQUUsQ0FBQ2hZLEtBQUssRUFBRWlZLEVBQUUsQ0FBQ2pZLEtBQUssQ0FBQztBQUM3RCxtQkFBSyxRQUFRO0FBQ1QsdUJBQU8ySSxZQUFZLENBQUN5RSxDQUFDLENBQUNvQixDQUFDLEVBQUV3SixFQUFFLENBQUNoWSxLQUFLLEVBQUVpWSxFQUFFLENBQUNqWSxLQUFLLENBQUM7QUFDcEQ7WUFDQSxNQUFNLElBQUk5QixLQUFLLENBQUE4RCx1QkFBQUEsQ0FBQUEsTUFBQSxDQUF5Qm9MLENBQUMsQ0FBQ21CLElBQUksQ0FBRSxDQUFDO0FBQ3JELGVBQUssS0FBSztBQUNOLGtCQUFNeUMsSUFBSSxHQUFHdFQsTUFBTSxDQUFDc1QsSUFBSSxDQUFDZ0gsRUFBRSxDQUFDLENBQUNoVyxNQUFNLENBQUN0RSxNQUFNLENBQUNzVCxJQUFJLENBQUNpSCxFQUFFLENBQUMsQ0FBQztBQUNwRCxvQkFBUTNHLENBQUMsQ0FBQzhDLENBQUMsQ0FBQzdGLElBQUk7QUFDWixtQkFBSyxTQUFTO0FBQ1Ysc0JBQU1rQyxXQUFXLEdBQUdhLENBQUMsQ0FBQzhDLENBQUMsQ0FBQzVGLENBQUM7Z0JBQ3pCLE9BQU93QyxJQUFJLENBQUNLLEtBQUssQ0FBRXlHLENBQUMsSUFBS3JILFdBQVcsQ0FBQ2hRLE1BQU0sQ0FBQ3VYLEVBQUUsQ0FBQ0YsQ0FBQyxDQUFDLEVBQUVHLEVBQUUsQ0FBQ0gsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM5RCxtQkFBSyxNQUFNO2dCQUNQLE9BQU85RyxJQUFJLENBQUNLLEtBQUssQ0FBRXlHLENBQUMsSUFBS25QLFlBQVksQ0FBQ0YsVUFBVSxDQUFDZ0osS0FBSyxFQUFFdUcsRUFBRSxDQUFDRixDQUFDLENBQUMsRUFBRUcsRUFBRSxDQUFDSCxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzFFLG1CQUFLLFFBQVE7QUFDVCxzQkFBTTVCLFVBQVUsR0FBRzVFLENBQUMsQ0FBQzhDLENBQUMsQ0FBQzVGLENBQUM7Z0JBQ3hCLE9BQU93QyxJQUFJLENBQUNLLEtBQUssQ0FBRXlHLENBQUMsSUFBS25QLFlBQVksQ0FBQ3VOLFVBQVUsRUFBRThCLEVBQUUsQ0FBQ0YsQ0FBQyxDQUFDLEVBQUVHLEVBQUUsQ0FBQ0gsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN4RTtBQUNBO0FBQ1I7QUFDSixPQUFDLENBQUM7S0FDTDtBQUNEO0lBQ0FoWCxLQUFLQSxDQUFDbUIsT0FBTyxFQUFFO0FBQ1gsWUFBTWYsSUFBSSxHQUFHZSxPQUFPLENBQUN0QixPQUFPLEVBQUU7QUFBRWlRLFFBQUFBLE1BQU0sR0FBRyxJQUFJMVAsSUFBSSxFQUFFO0FBQUVnWCxRQUFBQSxHQUFHLEdBQUd0SCxNQUFNO01BQ2pFLEtBQUssTUFBTTJHLE1BQU0sSUFBSXJXLElBQUksQ0FBQ2lDLE1BQU0sQ0FBQ3FVLFFBQVEsRUFBRSxFQUFFO0FBQ3pDLGNBQU1GLE1BQU0sR0FBR3JWLE9BQU8sQ0FBQ3NWLE1BQU0sQ0FBQzdYLFNBQVMsQ0FBQztBQUN4QyxZQUFJbVksSUFBSTtRQUNSLElBQUlOLE1BQU0sQ0FBQ2xKLFFBQVEsRUFBRTtBQUNqQndKLFVBQUFBLElBQUksR0FBR1AsTUFBTSxDQUFDMVosR0FBRyxDQUFDdWEsa0JBQWtCLENBQUM7QUFDekMsU0FBQyxNQUNJLElBQUlaLE1BQU0sQ0FBQ2hKLElBQUksSUFBSSxLQUFLLEVBQUU7QUFDM0JzSixVQUFBQSxJQUFJLEdBQUdLLEdBQUcsQ0FBQ1gsTUFBTSxDQUFDN1gsU0FBUyxDQUFDO0FBQzVCLGVBQUssTUFBTSxDQUFDdVUsR0FBRyxFQUFFelUsQ0FBQyxDQUFDLElBQUk5QixNQUFNLENBQUNpVixPQUFPLENBQUMyRSxNQUFNLENBQUMsRUFBRTtBQUMzQ08sWUFBQUEsSUFBSSxDQUFDNUQsR0FBRyxDQUFDLEdBQUdrRSxrQkFBa0IsQ0FBQzNZLENBQUMsQ0FBQztBQUNyQztBQUNKLFNBQUMsTUFDSSxJQUFJK1gsTUFBTSxDQUFDaEosSUFBSSxJQUFJLE9BQU8sRUFBRTtVQUM3QixNQUFNK0IsQ0FBQyxHQUFHaUgsTUFBTSxDQUFDSSxTQUFTLENBQUNMLE1BQU0sQ0FBQ3hHLElBQUksQ0FBQztVQUN2QytHLElBQUksR0FBR3ZILENBQUMsR0FDRjtZQUFFUSxJQUFJLEVBQUV3RyxNQUFNLENBQUN4RyxJQUFJO0FBQUU5USxZQUFBQSxLQUFLLEVBQUVtWSxrQkFBa0IsQ0FBQ2IsTUFBTSxDQUFDdFgsS0FBSztBQUFFLFdBQUMsR0FDOUQ7QUFBRThRLFlBQUFBLElBQUksRUFBRWpYLFNBQUFBO1dBQVc7QUFDN0IsU0FBQyxNQUNJO0FBQ0RnZSxVQUFBQSxJQUFJLEdBQUdNLGtCQUFrQixDQUFDYixNQUFNLENBQUM7QUFDckM7QUFDQVksUUFBQUEsR0FBRyxDQUFDWCxNQUFNLENBQUM3WCxTQUFTLENBQUMsR0FBR21ZLElBQUk7QUFDaEM7QUFDQSxXQUFLLE1BQU05SSxFQUFFLElBQUk3TixJQUFJLENBQUNOLE9BQU8sQ0FBQ1EsR0FBRyxDQUFDeU8saUJBQWlCLENBQUM1TixPQUFPLENBQUMsRUFBRTtRQUMxRGYsSUFBSSxDQUFDTixPQUFPLENBQUNRLEdBQUcsQ0FBQ2lQLGNBQWMsQ0FBQzZILEdBQUcsRUFBRW5KLEVBQUUsQ0FBQ3RQLEVBQUUsRUFBRXNQLEVBQUUsQ0FBQ3pDLFFBQVEsRUFBRXlDLEVBQUUsQ0FBQ3pMLElBQUksQ0FBQztBQUNyRTtBQUNBLGFBQU9zTixNQUFNO0FBQ2pCO0dBQ0g7QUFDTDtBQUNBO0FBQ0EsU0FBU3VILGtCQUFrQkEsQ0FBQ25ZLEtBQUssRUFBRTtFQUMvQixJQUFJQSxLQUFLLEtBQUtuRyxTQUFTLEVBQUU7QUFDckIsV0FBT21HLEtBQUs7QUFDaEI7QUFDQSxNQUFJbVIsU0FBUyxDQUFDblIsS0FBSyxDQUFDLEVBQUU7QUFDbEIsV0FBT0EsS0FBSyxDQUFDYyxLQUFLLEVBQUU7QUFDeEI7RUFDQSxJQUFJZCxLQUFLLFlBQVk2SSxVQUFVLEVBQUU7SUFDN0IsTUFBTWtOLENBQUMsR0FBRyxJQUFJbE4sVUFBVSxDQUFDN0ksS0FBSyxDQUFDd0IsVUFBVSxDQUFDO0FBQzFDdVUsSUFBQUEsQ0FBQyxDQUFDN0wsR0FBRyxDQUFDbEssS0FBSyxDQUFDO0FBQ1osV0FBTytWLENBQUM7QUFDWjtBQUNBLFNBQU8vVixLQUFLO0FBQ2hCO0FBQ0E7QUFDQSxTQUFTNFgsT0FBT0EsQ0FBQ3RiLEtBQUssRUFBRTtFQUNwQixPQUFPQSxLQUFLLFlBQVl1TSxVQUFVLEdBQUd2TSxLQUFLLEdBQUcsSUFBSXVNLFVBQVUsQ0FBQ3ZNLEtBQUssQ0FBQztBQUN0RTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPTyxTQUFTOGIsZ0JBQWdCQSxDQUFDQyxNQUFNLEVBQUUzVSxZQUFZLEVBQUVILFVBQVUsRUFBRTtFQUMvRCxPQUFPO0lBQ0g4VSxNQUFNO0lBQ04xVyxJQUFJLEVBQUV1USxjQUFjLEVBQUU7SUFDdEI5USxHQUFHLEVBQUUwVSxnQkFBZ0IsRUFBRTtBQUN2QmpWLElBQUFBLElBQUksRUFBRW5ELE1BQU0sQ0FBQzZDLE1BQU0sQ0FBQzdDLE1BQU0sQ0FBQzZDLE1BQU0sQ0FBQyxFQUFFLEVBQUU4VyxjQUFjLEVBQUUsQ0FBQyxFQUFFO01BQUUzVCxZQUFZO0FBQ25FSCxNQUFBQSxVQUFBQTtBQUFXLEtBQUMsQ0FBQztBQUNqQkwsSUFBQUEsZUFBZUEsQ0FBQzdELFFBQVEsRUFBRThELE1BQU0sRUFBRTdELEdBQUcsRUFBRTtNQUNuQyxPQUFPNEQsZUFBZSxDQUFDLElBQUksRUFBRTdELFFBQVEsRUFBRThELE1BQU0sRUFBRTdELEdBQUcsQ0FBQztLQUN0RDtJQUNEZ0IsUUFBUTtJQUNSZixZQUFZO0lBQ1pOLFdBQVc7QUFDWHdPLElBQUFBLGFBQWFBLENBQUNwTyxRQUFRLEVBQUVxTyxRQUFRLEVBQUVDLEtBQUssRUFBRTtNQUNyQyxPQUFPRixhQUFhLENBQUMsSUFBSSxFQUFFcE8sUUFBUSxFQUFFcU8sUUFBUSxFQUFFQyxLQUFLLENBQUM7QUFDekQ7R0FDSDtBQUNMOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU0ySyxpQkFBaUIsQ0FBQztBQUMzQnJWLEVBQUFBLFdBQVdBLENBQUNFLE1BQU0sRUFBRW9WLFVBQVUsRUFBRTtJQUM1QixJQUFJLENBQUNDLE9BQU8sR0FBR3JWLE1BQU07SUFDckIsSUFBSSxDQUFDc1YsV0FBVyxHQUFHRixVQUFVO0FBQ2pDO0VBQ0EzRixZQUFZQSxDQUFDOUUsUUFBUSxFQUFFO0FBQ25CLFFBQUksQ0FBQyxJQUFJLENBQUM0SyxTQUFTLEVBQUU7TUFDakIsTUFBTXZaLENBQUMsR0FBRyxFQUFFO01BQ1osS0FBSyxNQUFNbVIsQ0FBQyxJQUFJLElBQUksQ0FBQ3ZDLElBQUksRUFBRSxFQUFFO0FBQ3pCNU8sUUFBQUEsQ0FBQyxDQUFDbVIsQ0FBQyxDQUFDeEMsUUFBUSxDQUFDLEdBQUczTyxDQUFDLENBQUNtUixDQUFDLENBQUNsVyxJQUFJLENBQUMsR0FBR2tXLENBQUM7QUFDakM7TUFDQSxJQUFJLENBQUNvSSxTQUFTLEdBQUd2WixDQUFDO0FBQ3RCO0FBQ0EsV0FBTyxJQUFJLENBQUN1WixTQUFTLENBQUM1SyxRQUFRLENBQUM7QUFDbkM7RUFDQTRDLElBQUlBLENBQUMvRixPQUFPLEVBQUU7QUFDVixRQUFJLENBQUMsSUFBSSxDQUFDN0ssT0FBTyxFQUFFO01BQ2YsTUFBTVgsQ0FBQyxHQUFHLEVBQUU7TUFDWixLQUFLLE1BQU1tUixDQUFDLElBQUksSUFBSSxDQUFDdkMsSUFBSSxFQUFFLEVBQUU7QUFDekI1TyxRQUFBQSxDQUFDLENBQUNtUixDQUFDLENBQUM3USxFQUFFLENBQUMsR0FBRzZRLENBQUM7QUFDZjtNQUNBLElBQUksQ0FBQ3hRLE9BQU8sR0FBR1gsQ0FBQztBQUNwQjtBQUNBLFdBQU8sSUFBSSxDQUFDVyxPQUFPLENBQUM2SyxPQUFPLENBQUM7QUFDaEM7QUFDQW9ELEVBQUFBLElBQUlBLEdBQUc7QUFDSCxRQUFJLENBQUMsSUFBSSxDQUFDNEssR0FBRyxFQUFFO01BQ1gsSUFBSSxDQUFDQSxHQUFHLEdBQUcsSUFBSSxDQUFDRixXQUFXLENBQUMsSUFBSSxDQUFDRCxPQUFPLENBQUM7QUFDN0M7SUFDQSxPQUFPLElBQUksQ0FBQ0csR0FBRztBQUNuQjtBQUNBekYsRUFBQUEsUUFBUUEsR0FBRztBQUNQLFFBQUksQ0FBQyxJQUFJLENBQUMwRixVQUFVLEVBQUU7TUFDbEIsSUFBSSxDQUFDQSxVQUFVLEdBQUcsSUFBSSxDQUFDN0ssSUFBSSxFQUFFLENBQ3hCL0wsTUFBTSxFQUFFLENBQ1I2VyxJQUFJLENBQUMsQ0FBQ2xWLENBQUMsRUFBRUMsQ0FBQyxLQUFLRCxDQUFDLENBQUNsRSxFQUFFLEdBQUdtRSxDQUFDLENBQUNuRSxFQUFFLENBQUM7QUFDcEM7SUFDQSxPQUFPLElBQUksQ0FBQ21aLFVBQVU7QUFDMUI7QUFDQXBCLEVBQUFBLFFBQVFBLEdBQUc7QUFDUCxRQUFJLENBQUMsSUFBSSxDQUFDc0IsT0FBTyxFQUFFO01BQ2YsSUFBSSxDQUFDQSxPQUFPLEdBQUcsRUFBRTtBQUNqQixZQUFNblYsQ0FBQyxHQUFHLElBQUksQ0FBQ21WLE9BQU87QUFDdEIsVUFBSUMsQ0FBQztNQUNMLEtBQUssTUFBTXpJLENBQUMsSUFBSSxJQUFJLENBQUN2QyxJQUFJLEVBQUUsRUFBRTtRQUN6QixJQUFJdUMsQ0FBQyxDQUFDTyxLQUFLLEVBQUU7QUFDVCxjQUFJUCxDQUFDLENBQUNPLEtBQUssS0FBS2tJLENBQUMsRUFBRTtZQUNmQSxDQUFDLEdBQUd6SSxDQUFDLENBQUNPLEtBQUs7QUFDWGxOLFlBQUFBLENBQUMsQ0FBQ3hELElBQUksQ0FBQzRZLENBQUMsQ0FBQztBQUNiO0FBQ0osU0FBQyxNQUNJO0FBQ0RwVixVQUFBQSxDQUFDLENBQUN4RCxJQUFJLENBQUNtUSxDQUFDLENBQUM7QUFDYjtBQUNKO0FBQ0o7SUFDQSxPQUFPLElBQUksQ0FBQ3dJLE9BQU87QUFDdkI7QUFDSjs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNFLGNBQWNBLENBQUNDLFNBQVMsRUFBRUMsT0FBTyxFQUFFO0FBQy9DLFFBQU05ZSxJQUFJLEdBQUcrZSxjQUFjLENBQUNGLFNBQVMsQ0FBQztBQUN0QyxNQUFJQyxPQUFPLEVBQUU7QUFDVDtBQUNBLFdBQU85ZSxJQUFJO0FBQ2Y7QUFDQSxTQUFPZ2Ysa0JBQWtCLENBQUNDLG1CQUFtQixDQUFDamYsSUFBSSxDQUFDLENBQUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTa2YsY0FBY0EsQ0FBQ0wsU0FBUyxFQUFFO0FBQ3RDLFNBQU9ELGNBQWMsQ0FBQ0MsU0FBUyxFQUFFLEtBQUssQ0FBQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU1NLGFBQWEsR0FBR0osY0FBYztBQTZCM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQSxjQUFjQSxDQUFDSyxTQUFTLEVBQUU7RUFDL0IsSUFBSUMsT0FBTyxHQUFHLEtBQUs7RUFDbkIsTUFBTTdWLENBQUMsR0FBRyxFQUFFO0FBQ1osT0FBSyxJQUFJM0osQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHdWYsU0FBUyxDQUFDdGYsTUFBTSxFQUFFRCxDQUFDLEVBQUUsRUFBRTtBQUN2QyxRQUFJOGIsQ0FBQyxHQUFHeUQsU0FBUyxDQUFDRSxNQUFNLENBQUN6ZixDQUFDLENBQUM7QUFDM0IsWUFBUThiLENBQUM7QUFDTCxXQUFLLEdBQUc7QUFDSjBELFFBQUFBLE9BQU8sR0FBRyxJQUFJO0FBQ2Q7QUFDSixXQUFLLEdBQUc7QUFDUixXQUFLLEdBQUc7QUFDUixXQUFLLEdBQUc7QUFDUixXQUFLLEdBQUc7QUFDUixXQUFLLEdBQUc7QUFDUixXQUFLLEdBQUc7QUFDUixXQUFLLEdBQUc7QUFDUixXQUFLLEdBQUc7QUFDUixXQUFLLEdBQUc7QUFDUixXQUFLLEdBQUc7QUFDSjdWLFFBQUFBLENBQUMsQ0FBQ3pELElBQUksQ0FBQzRWLENBQUMsQ0FBQztBQUNUMEQsUUFBQUEsT0FBTyxHQUFHLEtBQUs7QUFDZjtBQUNKO0FBQ0ksWUFBSUEsT0FBTyxFQUFFO0FBQ1RBLFVBQUFBLE9BQU8sR0FBRyxLQUFLO0FBQ2YxRCxVQUFBQSxDQUFDLEdBQUdBLENBQUMsQ0FBQ3phLFdBQVcsRUFBRTtBQUN2QjtBQUNBc0ksUUFBQUEsQ0FBQyxDQUFDekQsSUFBSSxDQUFDNFYsQ0FBQyxDQUFDO0FBQ1Q7QUFDUjtBQUNKO0FBQ0EsU0FBT25TLENBQUMsQ0FBQ3dHLElBQUksQ0FBQyxFQUFFLENBQUM7QUFDckI7QUFrRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNdVAsd0JBQXdCLEdBQUcsSUFBSUMsR0FBRyxDQUFDO0FBQ3JDO0FBQ0EsYUFBYSxFQUNiLFVBQVUsRUFDVixRQUFRLEVBQ1IsU0FBUyxDQUNaLENBQUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLHlCQUF5QixHQUFHLElBQUlELEdBQUcsQ0FBQztBQUN0QztBQUNBLFNBQVMsRUFDVCxPQUFPLEVBQ1AsUUFBUSxFQUNSLFlBQVksRUFDWixVQUFVLEVBQ1YsZ0JBQWdCLEVBQ2hCLFVBQVUsRUFDVixRQUFRLEVBQ1IsY0FBYztBQUNkO0FBQ0EsVUFBVSxDQUNiLENBQUM7QUFDRixNQUFNRSxRQUFRLEdBQUkxZixJQUFJLE9BQUE0SCxNQUFBLENBQVE1SCxJQUFJLEVBQUc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNaWYsbUJBQW1CLEdBQUlqZixJQUFJLElBQUs7QUFDbEMsTUFBSXlmLHlCQUF5QixDQUFDRSxHQUFHLENBQUMzZixJQUFJLENBQUMsRUFBRTtJQUNyQyxPQUFPMGYsUUFBUSxDQUFDMWYsSUFBSSxDQUFDO0FBQ3pCO0FBQ0EsU0FBT0EsSUFBSTtBQUNmLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU1nZixrQkFBa0IsR0FBSWhmLElBQUksSUFBSztBQUN4QyxNQUFJdWYsd0JBQXdCLENBQUNJLEdBQUcsQ0FBQzNmLElBQUksQ0FBQyxFQUFFO0lBQ3BDLE9BQU8wZixRQUFRLENBQUMxZixJQUFJLENBQUM7QUFDekI7QUFDQSxTQUFPQSxJQUFJO0FBQ2YsQ0FBQzs7QUNuUUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHTyxNQUFNNGYsaUJBQWlCLENBQUM7RUFDM0IvVyxXQUFXQSxDQUFDN0ksSUFBSSxFQUFFO0lBQ2QsSUFBSSxDQUFDbVUsSUFBSSxHQUFHLE9BQU87SUFDbkIsSUFBSSxDQUFDRixRQUFRLEdBQUcsS0FBSztJQUNyQixJQUFJLENBQUN1SSxNQUFNLEdBQUcsS0FBSztJQUNuQixJQUFJLENBQUN0WCxHQUFHLEdBQUcsS0FBSztJQUNoQixJQUFJLENBQUN5UixHQUFHLEdBQUcsS0FBSztJQUNoQixJQUFJLENBQUN6QyxPQUFPLEdBQUd6VSxTQUFTO0lBQ3hCLElBQUksQ0FBQ3NKLE1BQU0sR0FBRyxFQUFFO0lBQ2hCLElBQUksQ0FBQy9JLElBQUksR0FBR0EsSUFBSTtBQUNoQixRQUFJLENBQUNzRixTQUFTLEdBQUc0WixjQUFjLENBQUNsZixJQUFJLENBQUM7QUFDekM7RUFDQTZmLFFBQVFBLENBQUN0TSxLQUFLLEVBQUU7QUFDWjVQLElBQUFBLE1BQU0sQ0FBQzRQLEtBQUssQ0FBQ2tELEtBQUssS0FBSyxJQUFJLFdBQUE3TyxNQUFBLENBQVcyTCxLQUFLLENBQUN2VCxJQUFJLGtCQUFBNEgsTUFBQSxDQUFlLElBQUksQ0FBQzVILElBQUksQ0FBRSxDQUFDO0FBQzNFLFFBQUksQ0FBQytJLE1BQU0sQ0FBQ2hELElBQUksQ0FBQ3dOLEtBQUssQ0FBQztBQUMzQjtFQUNBZ0ssU0FBU0EsQ0FBQ2pZLFNBQVMsRUFBRTtBQUNqQixRQUFJLENBQUMsSUFBSSxDQUFDd2EsT0FBTyxFQUFFO01BQ2YsSUFBSSxDQUFDQSxPQUFPLEdBQUd4YyxNQUFNLENBQUNtQyxNQUFNLENBQUMsSUFBSSxDQUFDO0FBQ2xDLFdBQUssSUFBSTVGLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBRyxJQUFJLENBQUNrSixNQUFNLENBQUNqSixNQUFNLEVBQUVELENBQUMsRUFBRSxFQUFFO0FBQ3pDLFlBQUksQ0FBQ2lnQixPQUFPLENBQUMsSUFBSSxDQUFDL1csTUFBTSxDQUFDbEosQ0FBQyxDQUFDLENBQUN5RixTQUFTLENBQUMsR0FBRyxJQUFJLENBQUN5RCxNQUFNLENBQUNsSixDQUFDLENBQUM7QUFDM0Q7QUFDSjtBQUNBLFdBQU8sSUFBSSxDQUFDaWdCLE9BQU8sQ0FBQ3hhLFNBQVMsQ0FBQztBQUNsQztBQUNKOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVN5YSxtQkFBbUJBLENBQUNDLFVBQVUsRUFBRUMsZUFBZSxFQUFFO0VBQzdELElBQUkxWCxFQUFFLEVBQUUyWCxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUU7RUFDMUIsTUFBTXJILENBQUMsR0FBRyxFQUFFO0FBQ1osTUFBSTBGLENBQUM7QUFDTCxPQUFLLE1BQU1wTCxLQUFLLElBQUksT0FBT3lNLFVBQVUsSUFBSSxVQUFVLEdBQzdDQSxVQUFVLEVBQUUsR0FDWkEsVUFBVSxFQUFFO0lBQ2QsTUFBTTlKLENBQUMsR0FBRzNDLEtBQUs7QUFDZjJDLElBQUFBLENBQUMsQ0FBQzVRLFNBQVMsR0FBR3NaLGNBQWMsQ0FBQ3JMLEtBQUssQ0FBQ3ZULElBQUksRUFBRXVULEtBQUssQ0FBQ2tELEtBQUssS0FBS2hYLFNBQVMsQ0FBQztJQUNuRXlXLENBQUMsQ0FBQ3hDLFFBQVEsR0FBRyxDQUFDbkwsRUFBRSxHQUFHZ0wsS0FBSyxDQUFDRyxRQUFRLE1BQU0sSUFBSSxJQUFJbkwsRUFBRSxLQUFLLEtBQUssQ0FBQyxHQUFHQSxFQUFFLEdBQUc0VyxhQUFhLENBQUM1TCxLQUFLLENBQUN2VCxJQUFJLENBQUM7QUFDN0ZrVyxJQUFBQSxDQUFDLENBQUNqQyxRQUFRLEdBQUcsQ0FBQ2lNLEVBQUUsR0FBRzNNLEtBQUssQ0FBQ1UsUUFBUSxNQUFNLElBQUksSUFBSWlNLEVBQUUsS0FBSyxLQUFLLENBQUMsR0FBR0EsRUFBRSxHQUFHLEtBQUs7QUFDekUsUUFBSTNNLEtBQUssQ0FBQ1ksSUFBSSxJQUFJLFFBQVEsRUFBRTtNQUN4QitCLENBQUMsQ0FBQzdCLENBQUMsR0FBRyxDQUFDOEwsRUFBRSxHQUFHNU0sS0FBSyxDQUFDYyxDQUFDLE1BQU0sSUFBSSxJQUFJOEwsRUFBRSxLQUFLLEtBQUssQ0FBQyxHQUFHQSxFQUFFLEdBQUc3UixRQUFRLENBQUM2SyxNQUFNO0FBQ3pFO0FBQ0FqRCxJQUFBQSxDQUFDLENBQUNxRyxTQUFTLEdBQUcsQ0FBQzZELEVBQUUsR0FBRzdNLEtBQUssQ0FBQ2dKLFNBQVMsTUFBTSxJQUFJLElBQUk2RCxFQUFFLEtBQUssS0FBSyxDQUFDLEdBQUdBLEVBQUUsR0FBRyxLQUFLO0FBQzNFbEssSUFBQUEsQ0FBQyxDQUFDUyxHQUFHLEdBQUcsQ0FBQzBKLEVBQUUsR0FBRzlNLEtBQUssQ0FBQ29ELEdBQUcsTUFBTSxJQUFJLElBQUkwSixFQUFFLEtBQUssS0FBSyxDQUFDLEdBQUdBLEVBQUUsR0FBRyxLQUFLO0FBQy9EbkssSUFBQUEsQ0FBQyxDQUFDaFIsR0FBRyxHQUFHLENBQUNvYixFQUFFLEdBQUcvTSxLQUFLLENBQUNyTyxHQUFHLE1BQU0sSUFBSSxJQUFJb2IsRUFBRSxLQUFLLEtBQUssQ0FBQyxHQUFHQSxFQUFFLEdBQUcsS0FBSztBQUMvRCxRQUFJL00sS0FBSyxDQUFDaUosTUFBTSxLQUFLL2MsU0FBUyxFQUFFO0FBQzVCLE1BQXFCO0FBQ2pCeVcsUUFBQUEsQ0FBQyxDQUFDc0csTUFBTSxHQUNKakosS0FBSyxDQUFDWSxJQUFJLElBQUksTUFBTSxJQUNmWixLQUFLLENBQUNZLElBQUksSUFBSSxRQUFRLElBQ25CWixLQUFLLENBQUNhLENBQUMsSUFBSS9GLFVBQVUsQ0FBQ0csS0FBSyxJQUMzQitFLEtBQUssQ0FBQ2EsQ0FBQyxJQUFJL0YsVUFBVSxDQUFDZSxNQUFPO0FBQzdDLE9BR0E7QUFDSjtBQUNBO0FBQ0E7QUFDQSxRQUFJbUUsS0FBSyxDQUFDa0QsS0FBSyxLQUFLaFgsU0FBUyxFQUFFO0FBQzNCLFlBQU04Z0IsTUFBTSxHQUFHLE9BQU9oTixLQUFLLENBQUNrRCxLQUFLLElBQUksUUFBUSxHQUFHbEQsS0FBSyxDQUFDa0QsS0FBSyxHQUFHbEQsS0FBSyxDQUFDa0QsS0FBSyxDQUFDelcsSUFBSTtNQUM5RSxJQUFJLENBQUMyZSxDQUFDLElBQUlBLENBQUMsQ0FBQzNlLElBQUksSUFBSXVnQixNQUFNLEVBQUU7QUFDeEI1QixRQUFBQSxDQUFDLEdBQUcsSUFBSWlCLGlCQUFpQixDQUFDVyxNQUFNLENBQUM7QUFDckM7TUFDQXJLLENBQUMsQ0FBQ08sS0FBSyxHQUFHa0ksQ0FBQztBQUNYQSxNQUFBQSxDQUFDLENBQUNrQixRQUFRLENBQUMzSixDQUFDLENBQUM7QUFDakI7QUFDQStDLElBQUFBLENBQUMsQ0FBQ2xULElBQUksQ0FBQ21RLENBQUMsQ0FBQztBQUNiO0FBQ0EsU0FBTytDLENBQUM7QUFDWjs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDTyxNQUFNdUgsTUFBTSxHQUFHeEMsZ0JBQWdCLENBQUMsUUFBUSxFQUFHalYsTUFBTSxJQUFLO0FBQ3pELFNBQU8sSUFBSW1WLGlCQUFpQixDQUFDblYsTUFBTSxFQUFHbVUsTUFBTSxJQUFLNkMsbUJBQW1CLENBQUM3QyxNQUFZLENBQUMsQ0FBQztBQUN2RixDQUFDO0FBQ0Q7QUFDQzFHLE1BQU0sSUFBSztBQUNSLE9BQUssTUFBTTJHLE1BQU0sSUFBSTNHLE1BQU0sQ0FBQ2pRLE9BQU8sRUFBRSxDQUFDd0MsTUFBTSxDQUFDcVUsUUFBUSxFQUFFLEVBQUU7SUFDckQsSUFBSUQsTUFBTSxDQUFDalksR0FBRyxFQUFFO0FBQ1o7QUFDSjtBQUNBLFVBQU1sRixJQUFJLEdBQUdtZCxNQUFNLENBQUM3WCxTQUFTO0FBQUVQLE1BQUFBLENBQUMsR0FBR3lSLE1BQU07SUFDekMsSUFBSTJHLE1BQU0sQ0FBQ2xKLFFBQVEsRUFBRTtBQUNqQmxQLE1BQUFBLENBQUMsQ0FBQy9FLElBQUksQ0FBQyxHQUFHLEVBQUU7QUFDWjtBQUNKO0lBQ0EsUUFBUW1kLE1BQU0sQ0FBQ2hKLElBQUk7QUFDZixXQUFLLE9BQU87UUFDUnBQLENBQUMsQ0FBQy9FLElBQUksQ0FBQyxHQUFHO0FBQUUwVyxVQUFBQSxJQUFJLEVBQUVqWCxTQUFBQTtTQUFXO0FBQzdCO0FBQ0osV0FBSyxNQUFNO0FBQ1BzRixRQUFBQSxDQUFDLENBQUMvRSxJQUFJLENBQUMsR0FBRyxDQUFDO0FBQ1g7QUFDSixXQUFLLEtBQUs7QUFDTitFLFFBQUFBLENBQUMsQ0FBQy9FLElBQUksQ0FBQyxHQUFHLEVBQUU7QUFDWjtBQUNKLFdBQUssUUFBUTtBQUNUK0UsUUFBQUEsQ0FBQyxDQUFDL0UsSUFBSSxDQUFDLEdBQUcrTyxlQUFlLENBQUNvTyxNQUFNLENBQUMvSSxDQUFDLEVBQUUrSSxNQUFNLENBQUM5SSxDQUFDLENBQUM7QUFDN0M7QUFJUjtBQUNKO0FBQ0osQ0FBQyxDQUFDOztBQ3BERjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBK0NBO0FBQ0E7QUFDQTtBQUNPLE1BQU1vTSxTQUFTLGdCQUFpQkQsTUFBTSxDQUFDdGEsUUFBUSxDQUNwRCxtQkFBbUIsRUFDbkIsQ0FDRTtBQUFDYixFQUFBQSxFQUFFLEVBQUUsQ0FBQztBQUFFckYsRUFBQUEsSUFBSSxFQUFFO0FBQU8sQ0FBQyxFQUN0QjtBQUFDcUYsRUFBQUEsRUFBRSxFQUFFLENBQUM7QUFBRXJGLEVBQUFBLElBQUksRUFBRTtBQUFPLENBQUMsRUFDdEI7QUFBQ3FGLEVBQUFBLEVBQUUsRUFBRSxDQUFDO0FBQUVyRixFQUFBQSxJQUFJLEVBQUU7QUFBTSxDQUFDLENBRXpCLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ08sTUFBTTBnQixXQUFXLGdCQUFpQkYsTUFBTSxDQUFDdGEsUUFBUSxDQUN0RCxxQkFBcUIsRUFDckIsQ0FDRTtBQUFDYixFQUFBQSxFQUFFLEVBQUUsQ0FBQztBQUFFckYsRUFBQUEsSUFBSSxFQUFFO0FBQVMsQ0FBQyxFQUN4QjtBQUFDcUYsRUFBQUEsRUFBRSxFQUFFLENBQUM7QUFBRXJGLEVBQUFBLElBQUksRUFBRTtBQUFRLENBQUMsRUFDdkI7QUFBQ3FGLEVBQUFBLEVBQUUsRUFBRSxDQUFDO0FBQUVyRixFQUFBQSxJQUFJLEVBQUU7QUFBWSxDQUFDLEVBQzNCO0FBQUNxRixFQUFBQSxFQUFFLEVBQUUsQ0FBQztBQUFFckYsRUFBQUEsSUFBSSxFQUFFO0FBQWMsQ0FBQyxFQUM3QjtBQUFDcUYsRUFBQUEsRUFBRSxFQUFFLENBQUM7QUFBRXJGLEVBQUFBLElBQUksRUFBRTtBQUFvQixDQUFDLENBRXZDLENBQUM7O0FDbkZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFxQkE7QUFDQTtBQUNBO0FBQ08sTUFBTTJnQixXQUFXLGdCQUFpQkgsTUFBTSxDQUFDdGEsUUFBUSxDQUN0RCxxQkFBcUIsRUFDckIsQ0FDRTtBQUFDYixFQUFBQSxFQUFFLEVBQUUsQ0FBQztBQUFFckYsRUFBQUEsSUFBSSxFQUFFO0FBQVEsQ0FBQyxFQUN2QjtBQUFDcUYsRUFBQUEsRUFBRSxFQUFFLENBQUM7QUFBRXJGLEVBQUFBLElBQUksRUFBRTtBQUFRLENBQUMsQ0FFM0IsQ0FBQzs7QUMxQ0Q7QUFDQTtBQUVBLE1BQU00Z0IsdUJBQXVCLEdBQUcsNEJBQTRCO0FBWTVELElBQUlDLGNBQTBDO0FBRTlDOztBQUVHO1NBQ2FDLFVBQVVBLENBQUN4aUIsU0FBa0IsRUFBYztBQUFBLE1BQVp5aUIsS0FBSyxHQUFBM2hCLFNBQUEsQ0FBQVUsTUFBQSxRQUFBVixTQUFBLFFBQUFLLFNBQUEsR0FBQUwsU0FBQSxNQUFHLElBQUk7RUFDekQsSUFBd0MsT0FBT2hCLFNBQVMsS0FBSyxXQUFXLEVBQUU7QUFDeEU7QUFDRjtFQUNBLE1BQU00aUIsRUFBRSxHQUFHLENBQWM1aUIsU0FBUyxDQUFDRSxTQUFTLEVBQUUwZSxXQUFXLEVBQUU7QUFDM0QsTUFBSTZELGNBQWMsS0FBS3BoQixTQUFTLElBQUlzaEIsS0FBSyxFQUFFO0FBQ3pDLFVBQU1FLE9BQU8sR0FBR0MsWUFBWSxDQUFDNUssSUFBSSxDQUFDNkssSUFBQTtNQUFBLElBQUM7QUFBRTlpQixRQUFBQSxJQUFBQTtBQUFJLE9BQUUsR0FBQThpQixJQUFBO0FBQUEsYUFBSzlpQixJQUFJLENBQUNBLElBQUksQ0FBQzJpQixFQUFFLENBQUM7S0FBQztBQUM5REgsSUFBQUEsY0FBYyxHQUFHSSxPQUFPLGFBQVBBLE9BQU8sdUJBQVBBLE9BQU8sQ0FBRUcsUUFBUSxDQUFDSixFQUFFLENBQUM7QUFDeEM7QUFDQSxTQUFPSCxjQUFjO0FBQ3ZCO0FBRUEsTUFBTUssWUFBWSxHQUFHLENBQ25CO0FBQ0U3aUIsRUFBQUEsSUFBSSxFQUFFLDBCQUEwQjtFQUNoQytpQixRQUFRQSxDQUFDSixFQUFVO0FBQ2pCLFVBQU1DLE9BQU8sR0FBbUI7QUFDOUJqaEIsTUFBQUEsSUFBSSxFQUFFLFNBQVM7QUFDZnFoQixNQUFBQSxPQUFPLEVBQUVDLFFBQVEsQ0FBQyxtREFBbUQsRUFBRU4sRUFBRSxDQUFDO0FBQzFFTyxNQUFBQSxFQUFFLEVBQUVQLEVBQUUsQ0FBQ2hFLFdBQVcsRUFBRSxDQUFDd0UsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEtBQUssR0FBRy9oQixTQUFTO01BQzFEZ2lCLFNBQVMsRUFBRUMsWUFBWSxDQUFDVixFQUFFO0tBQzNCO0FBQ0QsV0FBT0MsT0FBTztBQUNoQjtBQUNELEdBQ0Q7QUFDRTVpQixFQUFBQSxJQUFJLEVBQUUsbUJBQW1CO0VBQ3pCK2lCLFFBQVFBLENBQUNKLEVBQVU7QUFDakIsVUFBTUMsT0FBTyxHQUFtQjtBQUM5QmpoQixNQUFBQSxJQUFJLEVBQUUsUUFBUTtBQUNkcWhCLE1BQUFBLE9BQU8sRUFBRUMsUUFBUSxDQUFDLG1EQUFtRCxFQUFFTixFQUFFLENBQUM7QUFDMUVPLE1BQUFBLEVBQUUsRUFBRVAsRUFBRSxDQUFDaEUsV0FBVyxFQUFFLENBQUN3RSxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsS0FBSyxHQUFHL2hCLFNBQVM7TUFDMURnaUIsU0FBUyxFQUFFQyxZQUFZLENBQUNWLEVBQUU7S0FDM0I7QUFFRCxXQUFPQyxPQUFPO0FBQ2hCO0FBQ0Q7QUFFRDtBQUNFNWlCLEVBQUFBLElBQUksRUFBRSxxQkFBcUI7RUFDM0IraUIsUUFBUUEsQ0FBQ0osRUFBVTtBQUNqQixVQUFNQyxPQUFPLEdBQW1CO0FBQzlCamhCLE1BQUFBLElBQUksRUFBRSxRQUFRO0FBQ2RxaEIsTUFBQUEsT0FBTyxFQUFFQyxRQUFRLENBQUNWLHVCQUF1QixFQUFFSSxFQUFFLENBQUM7TUFDOUNPLEVBQUUsRUFBRVAsRUFBRSxDQUFDUSxRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsS0FBSyxHQUFHLE9BQU87TUFDNUNDLFNBQVMsRUFBRUMsWUFBWSxDQUFDVixFQUFFO0tBQzNCO0FBRUQsV0FBT0MsT0FBTztBQUNoQjtBQUNELEVBQ0Y7QUFFRCxTQUFTSyxRQUFRQSxDQUFDSyxHQUFXLEVBQUVYLEVBQVUsRUFBUTtBQUFBLE1BQU5ZLEVBQUUsR0FBQXhpQixTQUFBLENBQUFVLE1BQUEsUUFBQVYsU0FBQSxRQUFBSyxTQUFBLEdBQUFMLFNBQUEsTUFBRyxDQUFDO0FBQy9DLFFBQU15aUIsS0FBSyxHQUFHYixFQUFFLENBQUNhLEtBQUssQ0FBQ0YsR0FBRyxDQUFDO0FBQzNCLFNBQVFFLEtBQUssSUFBSUEsS0FBSyxDQUFDL2hCLE1BQU0sSUFBSThoQixFQUFFLElBQUlDLEtBQUssQ0FBQ0QsRUFBRSxDQUFDLElBQUssRUFBRTtBQUN6RDtBQUVBLFNBQVNGLFlBQVlBLENBQUNWLEVBQVU7RUFDOUIsT0FBT0EsRUFBRSxDQUFDUSxRQUFRLENBQUMsUUFBUSxDQUFDLEdBQ3hCRixRQUFRLENBQUMseUJBQXlCLEVBQUVOLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQ2MsT0FBTyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsR0FDN0RyaUIsU0FBUztBQUNmOztNQ29OYXNpQixXQUFXO0VBaUJ0QmxaLFdBQ0VBLENBQUFtWixjQUEyQyxFQUMzQ0MsTUFBZSxFQUNmQyxVQUFtQixFQUNuQkMsWUFBcUIsRUFDckJDLFFBQTBCO0FBRTFCLFFBQUksT0FBT0osY0FBYyxLQUFLLFFBQVEsRUFBRTtBQUN0QyxVQUFJLENBQUNLLEtBQUssR0FBR0wsY0FBYyxDQUFDSyxLQUFLO0FBQ2pDLFVBQUksQ0FBQ0osTUFBTSxHQUFHRCxjQUFjLENBQUNDLE1BQU07QUFDbkMsVUFBSSxDQUFDSyxXQUFXLEdBQUdOLGNBQWMsQ0FBQ00sV0FBVztNQUM3QyxJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNkTCxVQUFVLEVBQUVGLGNBQWMsQ0FBQ0UsVUFBVTtRQUNyQ0MsWUFBWSxFQUFFSCxjQUFjLENBQUNHLFlBQVk7UUFDekNDLFFBQVEsRUFBRUosY0FBYyxDQUFDSSxRQUFBQTtPQUMxQjtLQUNGLE1BQU0sSUFBSUgsTUFBTSxLQUFLeGlCLFNBQVMsSUFBSXlpQixVQUFVLEtBQUt6aUIsU0FBUyxFQUFFO01BQzNELElBQUksQ0FBQzRpQixLQUFLLEdBQUdMLGNBQWM7TUFDM0IsSUFBSSxDQUFDQyxNQUFNLEdBQUdBLE1BQU07QUFDcEIsVUFBSSxDQUFDSyxXQUFXLEdBQUdOLGNBQWMsR0FBR0MsTUFBTTtNQUMxQyxJQUFJLENBQUNNLFFBQVEsR0FBRztRQUNkTCxVQUFVO1FBQ1ZDLFlBQVk7QUFDWkMsUUFBQUEsUUFBQUE7T0FDRDtBQUNILEtBQUMsTUFBTTtBQUNMLFlBQU0sSUFBSWpnQixTQUFTLENBQUMsb0VBQW9FLENBQUM7QUFDM0Y7QUFDRjtFQUVBLElBQUlxZ0IsVUFBVUEsR0FBQTtJQUNaLE9BQU87TUFDTEgsS0FBSyxFQUFFLElBQUksQ0FBQ0EsS0FBSztNQUNqQkosTUFBTSxFQUFFLElBQUksQ0FBQ0EsTUFBTTtBQUNuQlEsTUFBQUEsU0FBUyxFQUFFLElBQUksQ0FBQ0YsUUFBUSxDQUFDSixZQUFZO01BQ3JDRyxXQUFXLEVBQUUsSUFBSSxDQUFDQSxXQUFBQTtLQUNuQjtBQUNIO0FBQ0Q7QUE2Q0ssSUFBV0ksWUFBWTtBQUE3QixXQUFpQkEsWUFBWTtFQUNkQSxZQUFBLENBQUFDLFNBQVMsR0FBZ0I7QUFDcENULElBQUFBLFVBQVUsRUFBRTtHQUNiO0VBQ1lRLFlBQUEsQ0FBQUUsTUFBTSxHQUFnQjtBQUNqQ1YsSUFBQUEsVUFBVSxFQUFFO0dBQ2I7RUFDWVEsWUFBQSxDQUFBRyxLQUFLLEdBQWdCO0FBQ2hDWCxJQUFBQSxVQUFVLEVBQUU7R0FDYjtFQUNZUSxZQUFBLENBQUFJLFdBQVcsR0FBZ0I7QUFDdENaLElBQUFBLFVBQVUsRUFBRTtHQUNiO0VBQ1lRLFlBQUEsQ0FBQUssZ0JBQWdCLEdBQWdCO0FBQzNDYixJQUFBQSxVQUFVLEVBQUU7R0FDYjtFQUNZUSxZQUFBLENBQUFNLHNCQUFzQixHQUFnQjtBQUNqRGQsSUFBQUEsVUFBVSxFQUFFO0dBQ2I7QUFDSCxDQUFDLEVBbkJnQlEsWUFBWSxLQUFaQSxZQUFZLEdBbUI1QjtBQUVEOztBQUVHO0NBQ3lCO0VBQzFCTyxHQUFHLEVBQUUsSUFBSWxCLFdBQVcsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLEtBQU0sRUFBRSxFQUFFLENBQUM7RUFDekNtQixJQUFJLEVBQUUsSUFBSW5CLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLE1BQU8sRUFBRSxFQUFFLENBQUM7RUFDNUNvQixJQUFJLEVBQUUsSUFBSXBCLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLE1BQU8sRUFBRSxFQUFFLENBQUM7RUFDNUNxQixJQUFJLEVBQUUsSUFBSXJCLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLE1BQU8sRUFBRSxFQUFFLENBQUM7RUFDNUNzQixJQUFJLEVBQUUsSUFBSXRCLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLE1BQU8sRUFBRSxFQUFFLENBQUM7RUFDNUN1QixJQUFJLEVBQUUsSUFBSXZCLFdBQVcsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLE9BQVMsRUFBRSxFQUFFLENBQUM7RUFDL0N3QixLQUFLLEVBQUUsSUFBSXhCLFdBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQVMsRUFBRSxFQUFFLENBQUM7RUFDakR5QixLQUFLLEVBQUUsSUFBSXpCLFdBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQVMsRUFBRSxFQUFFLENBQUM7RUFDakQwQixLQUFLLEVBQUUsSUFBSTFCLFdBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQVMsRUFBRSxFQUFFO0dBQ3hDO0FBRVY7O0FBRUc7Q0FDMkI7RUFDNUIyQixJQUFJLEVBQUUsSUFBSTNCLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEtBQU0sRUFBRSxFQUFFLENBQUM7RUFDM0NtQixJQUFJLEVBQUUsSUFBSW5CLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLE1BQU8sRUFBRSxFQUFFLENBQUM7RUFDNUM0QixJQUFJLEVBQUUsSUFBSTVCLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLE1BQU8sRUFBRSxFQUFFLENBQUM7RUFDNUNxQixJQUFJLEVBQUUsSUFBSXJCLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLE1BQU8sRUFBRSxFQUFFLENBQUM7RUFDNUM2QixJQUFJLEVBQUUsSUFBSTdCLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLE1BQU8sRUFBRSxFQUFFLENBQUM7RUFDNUNzQixJQUFJLEVBQUUsSUFBSXRCLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLE1BQU8sRUFBRSxFQUFFLENBQUM7RUFDNUN1QixJQUFJLEVBQUUsSUFBSXZCLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLE9BQVMsRUFBRSxFQUFFLENBQUM7RUFDOUN3QixLQUFLLEVBQUUsSUFBSXhCLFdBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQVMsRUFBRSxFQUFFLENBQUM7RUFDakR5QixLQUFLLEVBQUUsSUFBSXpCLFdBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQVMsRUFBRSxFQUFFO0dBQ3hDO0NBRXdCO0FBQ2hDOEIsRUFBQUEsUUFBUSxFQUFFLElBQUk5QixXQUFXLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxNQUFPLEVBQUUsQ0FBQyxFQUFFLFFBQVEsQ0FBQztBQUN6RCtCLEVBQUFBLFNBQVMsRUFBRSxJQUFJL0IsV0FBVyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsTUFBTyxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUM7QUFDM0RnQyxFQUFBQSxRQUFRLEVBQUUsSUFBSWhDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLE1BQU8sRUFBRSxDQUFDLEVBQUUsUUFBUSxDQUFDO0FBQzFEaUMsRUFBQUEsU0FBUyxFQUFFLElBQUlqQyxXQUFXLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxPQUFTLEVBQUUsRUFBRSxFQUFFLFFBQVEsQ0FBQztBQUM5RGtDLEVBQUFBLFNBQVMsRUFBRSxJQUFJbEMsV0FBVyxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsT0FBUyxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUM7QUFDOURtQyxFQUFBQSxVQUFVLEVBQUUsSUFBSW5DLFdBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQVMsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDO0FBQ2hFb0MsRUFBQUEsVUFBVSxFQUFFLElBQUlwQyxXQUFXLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxPQUFTLEVBQUUsRUFBRSxFQUFFLFFBQVEsQ0FBQztBQUNoRTtBQUNBcUMsRUFBQUEsUUFBUSxFQUFFLElBQUlyQyxXQUFXLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxPQUFTLEVBQUUsRUFBRSxFQUFFLFFBQVE7Ozs7Ozs7OztFQ2hiekQsSUFBSXNDLENBQUMsR0FBRyxPQUFPQyxPQUFPLEtBQUssUUFBUSxHQUFHQSxPQUFPLEdBQUcsSUFBSTtFQUNwRCxJQUFJQyxZQUFZLEdBQUdGLENBQUMsSUFBSSxPQUFPQSxDQUFDLENBQUNsbEIsS0FBSyxLQUFLLFVBQVUsR0FDakRrbEIsQ0FBQyxDQUFDbGxCLEtBQUssR0FDUCxTQUFTb2xCLFlBQVlBLENBQUMvTixNQUFNLEVBQUVnTyxRQUFRLEVBQUVDLElBQUksRUFBRTtBQUM5QyxXQUFPMWxCLFFBQVEsQ0FBQ0MsU0FBUyxDQUFDRyxLQUFLLENBQUNGLElBQUksQ0FBQ3VYLE1BQU0sRUFBRWdPLFFBQVEsRUFBRUMsSUFBSSxDQUFDO0dBQzdEO0FBRUgsTUFBSUMsY0FBYztFQUNsQixJQUFJTCxDQUFDLElBQUksT0FBT0EsQ0FBQyxDQUFDTSxPQUFPLEtBQUssVUFBVSxFQUFFO0lBQ3hDRCxjQUFjLEdBQUdMLENBQUMsQ0FBQ00sT0FBTztBQUM1QixHQUFDLE1BQU0sSUFBSXJoQixNQUFNLENBQUNzaEIscUJBQXFCLEVBQUU7QUFDdkNGLElBQUFBLGNBQWMsR0FBRyxTQUFTQSxjQUFjQSxDQUFDbE8sTUFBTSxFQUFFO0FBQy9DLGFBQU9sVCxNQUFNLENBQUMwVCxtQkFBbUIsQ0FBQ1IsTUFBTSxDQUFDLENBQ3RDNU8sTUFBTSxDQUFDdEUsTUFBTSxDQUFDc2hCLHFCQUFxQixDQUFDcE8sTUFBTSxDQUFDLENBQUM7S0FDaEQ7QUFDSCxHQUFDLE1BQU07QUFDTGtPLElBQUFBLGNBQWMsR0FBRyxTQUFTQSxjQUFjQSxDQUFDbE8sTUFBTSxFQUFFO0FBQy9DLGFBQU9sVCxNQUFNLENBQUMwVCxtQkFBbUIsQ0FBQ1IsTUFBTSxDQUFDO0tBQzFDO0FBQ0g7RUFFQSxTQUFTcU8sa0JBQWtCQSxDQUFDQyxPQUFPLEVBQUU7SUFDbkMsSUFBSXhsQixPQUFPLElBQUlBLE9BQU8sQ0FBQ3lsQixJQUFJLEVBQUV6bEIsT0FBTyxDQUFDeWxCLElBQUksQ0FBQ0QsT0FBTyxDQUFDO0FBQ3BEO0VBRUEsSUFBSUUsV0FBVyxHQUFHMWdCLE1BQU0sQ0FBQ2tXLEtBQUssSUFBSSxTQUFTd0ssV0FBV0EsQ0FBQ3BmLEtBQUssRUFBRTtJQUM1RCxPQUFPQSxLQUFLLEtBQUtBLEtBQUs7R0FDdkI7RUFFRCxTQUFTcWYsWUFBWUEsR0FBRztBQUN0QkEsSUFBQUEsWUFBWSxDQUFDQyxJQUFJLENBQUNqbUIsSUFBSSxDQUFDLElBQUksQ0FBQztBQUM5QjtFQUNja21CLE1BQUEsQ0FBQXRuQixPQUFBLEdBQUdvbkIsWUFBWTtBQUNWRSxFQUFBQSxNQUFBLENBQUF0bkIsT0FBQSxDQUFBdW5CLElBQUEsR0FBR0EsSUFBSTs7QUFFMUI7RUFDQUgsWUFBWSxDQUFDQSxZQUFZLEdBQUdBLFlBQVk7QUFFeENBLEVBQUFBLFlBQVksQ0FBQ2ptQixTQUFTLENBQUNxbUIsT0FBTyxHQUFHNWxCLFNBQVM7QUFDMUN3bEIsRUFBQUEsWUFBWSxDQUFDam1CLFNBQVMsQ0FBQ3NtQixZQUFZLEdBQUcsQ0FBQztBQUN2Q0wsRUFBQUEsWUFBWSxDQUFDam1CLFNBQVMsQ0FBQ3VtQixhQUFhLEdBQUc5bEIsU0FBUzs7QUFFaEQ7QUFDQTtFQUNBLElBQUkrbEIsbUJBQW1CLEdBQUcsRUFBRTtFQUU1QixTQUFTQyxhQUFhQSxDQUFDQyxRQUFRLEVBQUU7QUFDL0IsUUFBSSxPQUFPQSxRQUFRLEtBQUssVUFBVSxFQUFFO0FBQ2xDLFlBQU0sSUFBSXZqQixTQUFTLENBQUMsa0VBQWtFLEdBQUcsT0FBT3VqQixRQUFRLENBQUM7QUFDMUc7QUFDSDtBQUVBcGlCLEVBQUFBLE1BQU0sQ0FBQ3FpQixjQUFjLENBQUNWLFlBQVksRUFBRSxxQkFBcUIsRUFBRTtBQUN6RFcsSUFBQUEsVUFBVSxFQUFFLElBQUk7SUFDaEJsUSxHQUFHLEVBQUUsWUFBVztBQUNkLGFBQU84UCxtQkFBbUI7S0FDM0I7QUFDRDFWLElBQUFBLEdBQUcsRUFBRSxVQUFTekwsR0FBRyxFQUFFO0FBQ2pCLFVBQUksT0FBT0EsR0FBRyxLQUFLLFFBQVEsSUFBSUEsR0FBRyxHQUFHLENBQUMsSUFBSTJnQixXQUFXLENBQUMzZ0IsR0FBRyxDQUFDLEVBQUU7UUFDMUQsTUFBTSxJQUFJeU8sVUFBVSxDQUFDLGlHQUFpRyxHQUFHek8sR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUNwSTtBQUNEbWhCLE1BQUFBLG1CQUFtQixHQUFHbmhCLEdBQUc7QUFDMUI7QUFDSCxHQUFDLENBQUM7RUFFRjRnQixZQUFZLENBQUNDLElBQUksR0FBRyxZQUFXO0FBRTdCLFFBQUksSUFBSSxDQUFDRyxPQUFPLEtBQUs1bEIsU0FBUyxJQUMxQixJQUFJLENBQUM0bEIsT0FBTyxLQUFLL2hCLE1BQU0sQ0FBQ3NGLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQ3ljLE9BQU8sRUFBRTtNQUN4RCxJQUFJLENBQUNBLE9BQU8sR0FBRy9oQixNQUFNLENBQUNtQyxNQUFNLENBQUMsSUFBSSxDQUFDO01BQ2xDLElBQUksQ0FBQzZmLFlBQVksR0FBRyxDQUFDO0FBQ3RCO0FBRUQsUUFBSSxDQUFDQyxhQUFhLEdBQUcsSUFBSSxDQUFDQSxhQUFhLElBQUk5bEIsU0FBUztHQUNyRDs7QUFFRDtBQUNBO0VBQ0F3bEIsWUFBWSxDQUFDam1CLFNBQVMsQ0FBQzZtQixlQUFlLEdBQUcsU0FBU0EsZUFBZUEsQ0FBQ2hnQixDQUFDLEVBQUU7QUFDbkUsUUFBSSxPQUFPQSxDQUFDLEtBQUssUUFBUSxJQUFJQSxDQUFDLEdBQUcsQ0FBQyxJQUFJbWYsV0FBVyxDQUFDbmYsQ0FBQyxDQUFDLEVBQUU7TUFDcEQsTUFBTSxJQUFJaU4sVUFBVSxDQUFDLCtFQUErRSxHQUFHak4sQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUNoSDtJQUNELElBQUksQ0FBQzBmLGFBQWEsR0FBRzFmLENBQUM7QUFDdEIsV0FBTyxJQUFJO0dBQ1o7RUFFRCxTQUFTaWdCLGdCQUFnQkEsQ0FBQ0MsSUFBSSxFQUFFO0lBQzlCLElBQUlBLElBQUksQ0FBQ1IsYUFBYSxLQUFLOWxCLFNBQVMsRUFDbEMsT0FBT3dsQixZQUFZLENBQUNPLG1CQUFtQjtJQUN6QyxPQUFPTyxJQUFJLENBQUNSLGFBQWE7QUFDM0I7RUFFQU4sWUFBWSxDQUFDam1CLFNBQVMsQ0FBQ2duQixlQUFlLEdBQUcsU0FBU0EsZUFBZUEsR0FBRztJQUNsRSxPQUFPRixnQkFBZ0IsQ0FBQyxJQUFJLENBQUM7R0FDOUI7RUFFRGIsWUFBWSxDQUFDam1CLFNBQVMsQ0FBQ2luQixJQUFJLEdBQUcsU0FBU0EsSUFBSUEsQ0FBQ25mLElBQUksRUFBRTtJQUNoRCxJQUFJMmQsSUFBSSxHQUFHLEVBQUU7SUFDYixLQUFLLElBQUk1a0IsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHVCxTQUFTLENBQUNVLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEVBQUU0a0IsSUFBSSxDQUFDMWUsSUFBSSxDQUFDM0csU0FBUyxDQUFDUyxDQUFDLENBQUMsQ0FBQztBQUNsRSxRQUFJcW1CLE9BQU8sR0FBSXBmLElBQUksS0FBSyxPQUFRO0FBRWhDLFFBQUlxZixNQUFNLEdBQUcsSUFBSSxDQUFDZCxPQUFPO0lBQ3pCLElBQUljLE1BQU0sS0FBSzFtQixTQUFTLEVBQ3RCeW1CLE9BQU8sR0FBSUEsT0FBTyxJQUFJQyxNQUFNLENBQUNDLEtBQUssS0FBSzNtQixTQUFVLENBQUMsS0FDL0MsSUFBSSxDQUFDeW1CLE9BQU8sRUFDZixPQUFPLEtBQUs7O0FBRWhCO0FBQ0UsUUFBSUEsT0FBTyxFQUFFO0FBQ1gsVUFBSUcsRUFBRTtNQUNOLElBQUk1QixJQUFJLENBQUMza0IsTUFBTSxHQUFHLENBQUMsRUFDakJ1bUIsRUFBRSxHQUFHNUIsSUFBSSxDQUFDLENBQUMsQ0FBQztNQUNkLElBQUk0QixFQUFFLFlBQVl2aUIsS0FBSyxFQUFFO0FBQzdCO0FBQ0E7UUFDTSxNQUFNdWlCLEVBQUUsQ0FBQztBQUNWO0FBQ0w7QUFDSSxVQUFJQyxHQUFHLEdBQUcsSUFBSXhpQixLQUFLLENBQUMsa0JBQWtCLElBQUl1aUIsRUFBRSxHQUFHLElBQUksR0FBR0EsRUFBRSxDQUFDeGUsT0FBTyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQztNQUM3RXllLEdBQUcsQ0FBQ0MsT0FBTyxHQUFHRixFQUFFO01BQ2hCLE1BQU1DLEdBQUcsQ0FBQztBQUNYO0FBRUQsUUFBSUUsT0FBTyxHQUFHTCxNQUFNLENBQUNyZixJQUFJLENBQUM7QUFFMUIsUUFBSTBmLE9BQU8sS0FBSy9tQixTQUFTLEVBQ3ZCLE9BQU8sS0FBSztBQUVkLFFBQUksT0FBTyttQixPQUFPLEtBQUssVUFBVSxFQUFFO0FBQ2pDakMsTUFBQUEsWUFBWSxDQUFDaUMsT0FBTyxFQUFFLElBQUksRUFBRS9CLElBQUksQ0FBQztBQUNyQyxLQUFHLE1BQU07QUFDTCxVQUFJN1UsR0FBRyxHQUFHNFcsT0FBTyxDQUFDMW1CLE1BQU07QUFDeEIsVUFBSTJtQixTQUFTLEdBQUdDLFVBQVUsQ0FBQ0YsT0FBTyxFQUFFNVcsR0FBRyxDQUFDO01BQ3hDLEtBQUssSUFBSS9QLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBRytQLEdBQUcsRUFBRSxFQUFFL1AsQ0FBQyxFQUMxQjBrQixZQUFZLENBQUNrQyxTQUFTLENBQUM1bUIsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFNGtCLElBQUksQ0FBQztBQUN6QztBQUVELFdBQU8sSUFBSTtHQUNaO0VBRUQsU0FBU2tDLFlBQVlBLENBQUNuUSxNQUFNLEVBQUUxUCxJQUFJLEVBQUU0ZSxRQUFRLEVBQUVrQixPQUFPLEVBQUU7QUFDckQsUUFBSTFQLENBQUM7QUFDTCxRQUFJaVAsTUFBTTtBQUNWLFFBQUlVLFFBQVE7SUFFWnBCLGFBQWEsQ0FBQ0MsUUFBUSxDQUFDO0lBRXZCUyxNQUFNLEdBQUczUCxNQUFNLENBQUM2TyxPQUFPO0lBQ3ZCLElBQUljLE1BQU0sS0FBSzFtQixTQUFTLEVBQUU7TUFDeEIwbUIsTUFBTSxHQUFHM1AsTUFBTSxDQUFDNk8sT0FBTyxHQUFHL2hCLE1BQU0sQ0FBQ21DLE1BQU0sQ0FBQyxJQUFJLENBQUM7TUFDN0MrUSxNQUFNLENBQUM4TyxZQUFZLEdBQUcsQ0FBQztBQUMzQixLQUFHLE1BQU07QUFDVDtBQUNBO0FBQ0ksVUFBSWEsTUFBTSxDQUFDVyxXQUFXLEtBQUtybkIsU0FBUyxFQUFFO0FBQ3BDK1csUUFBQUEsTUFBTSxDQUFDeVAsSUFBSSxDQUFDLGFBQWEsRUFBRW5mLElBQUksRUFDbkI0ZSxRQUFRLENBQUNBLFFBQVEsR0FBR0EsUUFBUSxDQUFDQSxRQUFRLEdBQUdBLFFBQVEsQ0FBQzs7QUFFbkU7QUFDQTtRQUNNUyxNQUFNLEdBQUczUCxNQUFNLENBQUM2TyxPQUFPO0FBQ3hCO0FBQ0R3QixNQUFBQSxRQUFRLEdBQUdWLE1BQU0sQ0FBQ3JmLElBQUksQ0FBQztBQUN4QjtJQUVELElBQUkrZixRQUFRLEtBQUtwbkIsU0FBUyxFQUFFO0FBQzlCO0FBQ0lvbkIsTUFBQUEsUUFBUSxHQUFHVixNQUFNLENBQUNyZixJQUFJLENBQUMsR0FBRzRlLFFBQVE7TUFDbEMsRUFBRWxQLE1BQU0sQ0FBQzhPLFlBQVk7QUFDekIsS0FBRyxNQUFNO0FBQ0wsVUFBSSxPQUFPdUIsUUFBUSxLQUFLLFVBQVUsRUFBRTtBQUN4QztBQUNNQSxRQUFBQSxRQUFRLEdBQUdWLE1BQU0sQ0FBQ3JmLElBQUksQ0FBQyxHQUNyQjhmLE9BQU8sR0FBRyxDQUFDbEIsUUFBUSxFQUFFbUIsUUFBUSxDQUFDLEdBQUcsQ0FBQ0EsUUFBUSxFQUFFbkIsUUFBUSxDQUFDO0FBQzdEO09BQ0ssTUFBTSxJQUFJa0IsT0FBTyxFQUFFO0FBQ2xCQyxRQUFBQSxRQUFRLENBQUNFLE9BQU8sQ0FBQ3JCLFFBQVEsQ0FBQztBQUNoQyxPQUFLLE1BQU07QUFDTG1CLFFBQUFBLFFBQVEsQ0FBQzlnQixJQUFJLENBQUMyZixRQUFRLENBQUM7QUFDeEI7O0FBRUw7QUFDSXhPLE1BQUFBLENBQUMsR0FBRzRPLGdCQUFnQixDQUFDdFAsTUFBTSxDQUFDO0FBQzVCLFVBQUlVLENBQUMsR0FBRyxDQUFDLElBQUkyUCxRQUFRLENBQUMvbUIsTUFBTSxHQUFHb1gsQ0FBQyxJQUFJLENBQUMyUCxRQUFRLENBQUNHLE1BQU0sRUFBRTtRQUNwREgsUUFBUSxDQUFDRyxNQUFNLEdBQUcsSUFBSTtBQUM1QjtBQUNBO1FBQ00sSUFBSUMsQ0FBQyxHQUFHLElBQUluakIsS0FBSyxDQUFDLDhDQUE4QyxHQUM1QytpQixRQUFRLENBQUMvbUIsTUFBTSxHQUFHLEdBQUcsR0FBR2dJLE1BQU0sQ0FBQ2hCLElBQUksQ0FBQyxHQUFHLGFBQWEsR0FDcEQsMENBQTBDLEdBQzFDLGdCQUFnQixDQUFDO1FBQ3JDbWdCLENBQUMsQ0FBQ2puQixJQUFJLEdBQUcsNkJBQTZCO1FBQ3RDaW5CLENBQUMsQ0FBQ0MsT0FBTyxHQUFHMVEsTUFBTTtRQUNsQnlRLENBQUMsQ0FBQ25nQixJQUFJLEdBQUdBLElBQUk7QUFDYm1nQixRQUFBQSxDQUFDLENBQUNFLEtBQUssR0FBR04sUUFBUSxDQUFDL21CLE1BQU07UUFDekIra0Isa0JBQWtCLENBQUNvQyxDQUFDLENBQUM7QUFDdEI7QUFDRjtBQUVELFdBQU96USxNQUFNO0FBQ2Y7RUFFQXlPLFlBQVksQ0FBQ2ptQixTQUFTLENBQUNvb0IsV0FBVyxHQUFHLFNBQVNBLFdBQVdBLENBQUN0Z0IsSUFBSSxFQUFFNGUsUUFBUSxFQUFFO0lBQ3hFLE9BQU9pQixZQUFZLENBQUMsSUFBSSxFQUFFN2YsSUFBSSxFQUFFNGUsUUFBUSxFQUFFLEtBQUssQ0FBQztHQUNqRDtFQUVEVCxZQUFZLENBQUNqbUIsU0FBUyxDQUFDcW9CLEVBQUUsR0FBR3BDLFlBQVksQ0FBQ2ptQixTQUFTLENBQUNvb0IsV0FBVztFQUU5RG5DLFlBQVksQ0FBQ2ptQixTQUFTLENBQUNzb0IsZUFBZSxHQUNsQyxTQUFTQSxlQUFlQSxDQUFDeGdCLElBQUksRUFBRTRlLFFBQVEsRUFBRTtJQUN2QyxPQUFPaUIsWUFBWSxDQUFDLElBQUksRUFBRTdmLElBQUksRUFBRTRlLFFBQVEsRUFBRSxJQUFJLENBQUM7R0FDaEQ7RUFFTCxTQUFTNkIsV0FBV0EsR0FBRztBQUNyQixRQUFJLENBQUMsSUFBSSxDQUFDQyxLQUFLLEVBQUU7QUFDZixVQUFJLENBQUNoUixNQUFNLENBQUNpUixjQUFjLENBQUMsSUFBSSxDQUFDM2dCLElBQUksRUFBRSxJQUFJLENBQUM0Z0IsTUFBTSxDQUFDO01BQ2xELElBQUksQ0FBQ0YsS0FBSyxHQUFHLElBQUk7QUFDakIsVUFBSXBvQixTQUFTLENBQUNVLE1BQU0sS0FBSyxDQUFDLEVBQ3hCLE9BQU8sSUFBSSxDQUFDNGxCLFFBQVEsQ0FBQ3ptQixJQUFJLENBQUMsSUFBSSxDQUFDdVgsTUFBTSxDQUFDO01BQ3hDLE9BQU8sSUFBSSxDQUFDa1AsUUFBUSxDQUFDdm1CLEtBQUssQ0FBQyxJQUFJLENBQUNxWCxNQUFNLEVBQUVwWCxTQUFTLENBQUM7QUFDbkQ7QUFDSDtBQUVBLFdBQVN1b0IsU0FBU0EsQ0FBQ25SLE1BQU0sRUFBRTFQLElBQUksRUFBRTRlLFFBQVEsRUFBRTtBQUN6QyxRQUFJa0MsS0FBSyxHQUFHO0FBQUVKLE1BQUFBLEtBQUssRUFBRSxLQUFLO0FBQUVFLE1BQUFBLE1BQU0sRUFBRWpvQixTQUFTO0FBQUUrVyxNQUFBQSxNQUFNLEVBQUVBLE1BQU07QUFBRTFQLE1BQUFBLElBQUksRUFBRUEsSUFBSTtBQUFFNGUsTUFBQUEsUUFBUSxFQUFFQSxRQUFBQTtLQUFVO0FBQy9GLFFBQUltQyxPQUFPLEdBQUdOLFdBQVcsQ0FBQ3pvQixJQUFJLENBQUM4b0IsS0FBSyxDQUFDO0lBQ3JDQyxPQUFPLENBQUNuQyxRQUFRLEdBQUdBLFFBQVE7SUFDM0JrQyxLQUFLLENBQUNGLE1BQU0sR0FBR0csT0FBTztBQUN0QixXQUFPQSxPQUFPO0FBQ2hCO0VBRUE1QyxZQUFZLENBQUNqbUIsU0FBUyxDQUFDb21CLElBQUksR0FBRyxTQUFTQSxJQUFJQSxDQUFDdGUsSUFBSSxFQUFFNGUsUUFBUSxFQUFFO0lBQzFERCxhQUFhLENBQUNDLFFBQVEsQ0FBQztBQUN2QixRQUFJLENBQUMyQixFQUFFLENBQUN2Z0IsSUFBSSxFQUFFNmdCLFNBQVMsQ0FBQyxJQUFJLEVBQUU3Z0IsSUFBSSxFQUFFNGUsUUFBUSxDQUFDLENBQUM7QUFDOUMsV0FBTyxJQUFJO0dBQ1o7RUFFRFQsWUFBWSxDQUFDam1CLFNBQVMsQ0FBQzhvQixtQkFBbUIsR0FDdEMsU0FBU0EsbUJBQW1CQSxDQUFDaGhCLElBQUksRUFBRTRlLFFBQVEsRUFBRTtJQUMzQ0QsYUFBYSxDQUFDQyxRQUFRLENBQUM7QUFDdkIsUUFBSSxDQUFDNEIsZUFBZSxDQUFDeGdCLElBQUksRUFBRTZnQixTQUFTLENBQUMsSUFBSSxFQUFFN2dCLElBQUksRUFBRTRlLFFBQVEsQ0FBQyxDQUFDO0FBQzNELFdBQU8sSUFBSTtHQUNaOztBQUVMO0VBQ0FULFlBQVksQ0FBQ2ptQixTQUFTLENBQUN5b0IsY0FBYyxHQUNqQyxTQUFTQSxjQUFjQSxDQUFDM2dCLElBQUksRUFBRTRlLFFBQVEsRUFBRTtJQUN0QyxJQUFJL1IsSUFBSSxFQUFFd1MsTUFBTSxFQUFFNEIsUUFBUSxFQUFFbG9CLENBQUMsRUFBRW1vQixnQkFBZ0I7SUFFL0N2QyxhQUFhLENBQUNDLFFBQVEsQ0FBQztJQUV2QlMsTUFBTSxHQUFHLElBQUksQ0FBQ2QsT0FBTztBQUNyQixRQUFJYyxNQUFNLEtBQUsxbUIsU0FBUyxFQUN0QixPQUFPLElBQUk7QUFFYmtVLElBQUFBLElBQUksR0FBR3dTLE1BQU0sQ0FBQ3JmLElBQUksQ0FBQztBQUNuQixRQUFJNk0sSUFBSSxLQUFLbFUsU0FBUyxFQUNwQixPQUFPLElBQUk7SUFFYixJQUFJa1UsSUFBSSxLQUFLK1IsUUFBUSxJQUFJL1IsSUFBSSxDQUFDK1IsUUFBUSxLQUFLQSxRQUFRLEVBQUU7QUFDbkQsVUFBSSxFQUFFLElBQUksQ0FBQ0osWUFBWSxLQUFLLENBQUMsRUFDM0IsSUFBSSxDQUFDRCxPQUFPLEdBQUcvaEIsTUFBTSxDQUFDbUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQ2hDO1FBQ0gsT0FBTzBnQixNQUFNLENBQUNyZixJQUFJLENBQUM7QUFDbkIsWUFBSXFmLE1BQU0sQ0FBQ3NCLGNBQWMsRUFDdkIsSUFBSSxDQUFDeEIsSUFBSSxDQUFDLGdCQUFnQixFQUFFbmYsSUFBSSxFQUFFNk0sSUFBSSxDQUFDK1IsUUFBUSxJQUFJQSxRQUFRLENBQUM7QUFDL0Q7QUFDVCxLQUFPLE1BQU0sSUFBSSxPQUFPL1IsSUFBSSxLQUFLLFVBQVUsRUFBRTtNQUNyQ29VLFFBQVEsR0FBRyxDQUFDLENBQUM7QUFFYixXQUFLbG9CLENBQUMsR0FBRzhULElBQUksQ0FBQzdULE1BQU0sR0FBRyxDQUFDLEVBQUVELENBQUMsSUFBSSxDQUFDLEVBQUVBLENBQUMsRUFBRSxFQUFFO0FBQ3JDLFlBQUk4VCxJQUFJLENBQUM5VCxDQUFDLENBQUMsS0FBSzZsQixRQUFRLElBQUkvUixJQUFJLENBQUM5VCxDQUFDLENBQUMsQ0FBQzZsQixRQUFRLEtBQUtBLFFBQVEsRUFBRTtBQUN6RHNDLFVBQUFBLGdCQUFnQixHQUFHclUsSUFBSSxDQUFDOVQsQ0FBQyxDQUFDLENBQUM2bEIsUUFBUTtBQUNuQ3FDLFVBQUFBLFFBQVEsR0FBR2xvQixDQUFDO0FBQ1o7QUFDRDtBQUNGO0FBRUQsVUFBSWtvQixRQUFRLEdBQUcsQ0FBQyxFQUNkLE9BQU8sSUFBSTtNQUViLElBQUlBLFFBQVEsS0FBSyxDQUFDLEVBQ2hCcFUsSUFBSSxDQUFDL0osS0FBSyxFQUFFLENBQUMsS0FDVjtBQUNIcWUsUUFBQUEsU0FBUyxDQUFDdFUsSUFBSSxFQUFFb1UsUUFBUSxDQUFDO0FBQzFCO0FBRUQsVUFBSXBVLElBQUksQ0FBQzdULE1BQU0sS0FBSyxDQUFDLEVBQ25CcW1CLE1BQU0sQ0FBQ3JmLElBQUksQ0FBQyxHQUFHNk0sSUFBSSxDQUFDLENBQUMsQ0FBQztBQUV4QixVQUFJd1MsTUFBTSxDQUFDc0IsY0FBYyxLQUFLaG9CLFNBQVMsRUFDckMsSUFBSSxDQUFDd21CLElBQUksQ0FBQyxnQkFBZ0IsRUFBRW5mLElBQUksRUFBRWtoQixnQkFBZ0IsSUFBSXRDLFFBQVEsQ0FBQztBQUNsRTtBQUVELFdBQU8sSUFBSTtHQUNaO0VBRUxULFlBQVksQ0FBQ2ptQixTQUFTLENBQUNrcEIsR0FBRyxHQUFHakQsWUFBWSxDQUFDam1CLFNBQVMsQ0FBQ3lvQixjQUFjO0VBRWxFeEMsWUFBWSxDQUFDam1CLFNBQVMsQ0FBQ21wQixrQkFBa0IsR0FDckMsU0FBU0Esa0JBQWtCQSxDQUFDcmhCLElBQUksRUFBRTtBQUNoQyxRQUFJMmYsU0FBUyxFQUFFTixNQUFNLEVBQUV0bUIsQ0FBQztJQUV4QnNtQixNQUFNLEdBQUcsSUFBSSxDQUFDZCxPQUFPO0FBQ3JCLFFBQUljLE1BQU0sS0FBSzFtQixTQUFTLEVBQ3RCLE9BQU8sSUFBSTs7QUFFbkI7QUFDTSxRQUFJMG1CLE1BQU0sQ0FBQ3NCLGNBQWMsS0FBS2hvQixTQUFTLEVBQUU7QUFDdkMsVUFBSUwsU0FBUyxDQUFDVSxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQzFCLElBQUksQ0FBQ3VsQixPQUFPLEdBQUcvaEIsTUFBTSxDQUFDbUMsTUFBTSxDQUFDLElBQUksQ0FBQztRQUNsQyxJQUFJLENBQUM2ZixZQUFZLEdBQUcsQ0FBQztPQUN0QixNQUFNLElBQUlhLE1BQU0sQ0FBQ3JmLElBQUksQ0FBQyxLQUFLckgsU0FBUyxFQUFFO1FBQ3JDLElBQUksRUFBRSxJQUFJLENBQUM2bEIsWUFBWSxLQUFLLENBQUMsRUFDM0IsSUFBSSxDQUFDRCxPQUFPLEdBQUcvaEIsTUFBTSxDQUFDbUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBRW5DLE9BQU8wZ0IsTUFBTSxDQUFDcmYsSUFBSSxDQUFDO0FBQ3RCO0FBQ0QsYUFBTyxJQUFJO0FBQ1o7O0FBRVA7QUFDTSxRQUFJMUgsU0FBUyxDQUFDVSxNQUFNLEtBQUssQ0FBQyxFQUFFO0FBQzFCLFVBQUk4VyxJQUFJLEdBQUd0VCxNQUFNLENBQUNzVCxJQUFJLENBQUN1UCxNQUFNLENBQUM7QUFDOUIsVUFBSXRNLEdBQUc7QUFDUCxXQUFLaGEsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHK1csSUFBSSxDQUFDOVcsTUFBTSxFQUFFLEVBQUVELENBQUMsRUFBRTtBQUNoQ2dhLFFBQUFBLEdBQUcsR0FBR2pELElBQUksQ0FBQy9XLENBQUMsQ0FBQztRQUNiLElBQUlnYSxHQUFHLEtBQUssZ0JBQWdCLEVBQUU7QUFDOUIsWUFBSSxDQUFDc08sa0JBQWtCLENBQUN0TyxHQUFHLENBQUM7QUFDN0I7QUFDRCxVQUFJLENBQUNzTyxrQkFBa0IsQ0FBQyxnQkFBZ0IsQ0FBQztNQUN6QyxJQUFJLENBQUM5QyxPQUFPLEdBQUcvaEIsTUFBTSxDQUFDbUMsTUFBTSxDQUFDLElBQUksQ0FBQztNQUNsQyxJQUFJLENBQUM2ZixZQUFZLEdBQUcsQ0FBQztBQUNyQixhQUFPLElBQUk7QUFDWjtBQUVEbUIsSUFBQUEsU0FBUyxHQUFHTixNQUFNLENBQUNyZixJQUFJLENBQUM7QUFFeEIsUUFBSSxPQUFPMmYsU0FBUyxLQUFLLFVBQVUsRUFBRTtBQUNuQyxVQUFJLENBQUNnQixjQUFjLENBQUMzZ0IsSUFBSSxFQUFFMmYsU0FBUyxDQUFDO0FBQzVDLEtBQU8sTUFBTSxJQUFJQSxTQUFTLEtBQUtobkIsU0FBUyxFQUFFO0FBQzFDO0FBQ1EsV0FBS0ksQ0FBQyxHQUFHNG1CLFNBQVMsQ0FBQzNtQixNQUFNLEdBQUcsQ0FBQyxFQUFFRCxDQUFDLElBQUksQ0FBQyxFQUFFQSxDQUFDLEVBQUUsRUFBRTtRQUMxQyxJQUFJLENBQUM0bkIsY0FBYyxDQUFDM2dCLElBQUksRUFBRTJmLFNBQVMsQ0FBQzVtQixDQUFDLENBQUMsQ0FBQztBQUN4QztBQUNGO0FBRUQsV0FBTyxJQUFJO0dBQ1o7QUFFTCxXQUFTdW9CLFVBQVVBLENBQUM1UixNQUFNLEVBQUUxUCxJQUFJLEVBQUV1aEIsTUFBTSxFQUFFO0FBQ3hDLFFBQUlsQyxNQUFNLEdBQUczUCxNQUFNLENBQUM2TyxPQUFPO0FBRTNCLFFBQUljLE1BQU0sS0FBSzFtQixTQUFTLEVBQ3RCLE9BQU8sRUFBRTtBQUVYLFFBQUk2b0IsVUFBVSxHQUFHbkMsTUFBTSxDQUFDcmYsSUFBSSxDQUFDO0FBQzdCLFFBQUl3aEIsVUFBVSxLQUFLN29CLFNBQVMsRUFDMUIsT0FBTyxFQUFFO0FBRVgsUUFBSSxPQUFPNm9CLFVBQVUsS0FBSyxVQUFVLEVBQ2xDLE9BQU9ELE1BQU0sR0FBRyxDQUFDQyxVQUFVLENBQUM1QyxRQUFRLElBQUk0QyxVQUFVLENBQUMsR0FBRyxDQUFDQSxVQUFVLENBQUM7QUFFcEUsV0FBT0QsTUFBTSxHQUNYRSxlQUFlLENBQUNELFVBQVUsQ0FBQyxHQUFHNUIsVUFBVSxDQUFDNEIsVUFBVSxFQUFFQSxVQUFVLENBQUN4b0IsTUFBTSxDQUFDO0FBQzNFO0VBRUFtbEIsWUFBWSxDQUFDam1CLFNBQVMsQ0FBQ3luQixTQUFTLEdBQUcsU0FBU0EsU0FBU0EsQ0FBQzNmLElBQUksRUFBRTtBQUMxRCxXQUFPc2hCLFVBQVUsQ0FBQyxJQUFJLEVBQUV0aEIsSUFBSSxFQUFFLElBQUksQ0FBQztHQUNwQztFQUVEbWUsWUFBWSxDQUFDam1CLFNBQVMsQ0FBQ3dwQixZQUFZLEdBQUcsU0FBU0EsWUFBWUEsQ0FBQzFoQixJQUFJLEVBQUU7QUFDaEUsV0FBT3NoQixVQUFVLENBQUMsSUFBSSxFQUFFdGhCLElBQUksRUFBRSxLQUFLLENBQUM7R0FDckM7QUFFRG1lLEVBQUFBLFlBQVksQ0FBQ3dELGFBQWEsR0FBRyxVQUFTdkIsT0FBTyxFQUFFcGdCLElBQUksRUFBRTtBQUNuRCxRQUFJLE9BQU9vZ0IsT0FBTyxDQUFDdUIsYUFBYSxLQUFLLFVBQVUsRUFBRTtBQUMvQyxhQUFPdkIsT0FBTyxDQUFDdUIsYUFBYSxDQUFDM2hCLElBQUksQ0FBQztBQUN0QyxLQUFHLE1BQU07QUFDTCxhQUFPMmhCLGFBQWEsQ0FBQ3hwQixJQUFJLENBQUNpb0IsT0FBTyxFQUFFcGdCLElBQUksQ0FBQztBQUN6QztHQUNGO0FBRURtZSxFQUFBQSxZQUFZLENBQUNqbUIsU0FBUyxDQUFDeXBCLGFBQWEsR0FBR0EsYUFBYTtFQUNwRCxTQUFTQSxhQUFhQSxDQUFDM2hCLElBQUksRUFBRTtBQUMzQixRQUFJcWYsTUFBTSxHQUFHLElBQUksQ0FBQ2QsT0FBTztJQUV6QixJQUFJYyxNQUFNLEtBQUsxbUIsU0FBUyxFQUFFO0FBQ3hCLFVBQUk2b0IsVUFBVSxHQUFHbkMsTUFBTSxDQUFDcmYsSUFBSSxDQUFDO0FBRTdCLFVBQUksT0FBT3doQixVQUFVLEtBQUssVUFBVSxFQUFFO0FBQ3BDLGVBQU8sQ0FBQztBQUNkLE9BQUssTUFBTSxJQUFJQSxVQUFVLEtBQUs3b0IsU0FBUyxFQUFFO1FBQ25DLE9BQU82b0IsVUFBVSxDQUFDeG9CLE1BQU07QUFDekI7QUFDRjtBQUVELFdBQU8sQ0FBQztBQUNWO0VBRUFtbEIsWUFBWSxDQUFDam1CLFNBQVMsQ0FBQzBwQixVQUFVLEdBQUcsU0FBU0EsVUFBVUEsR0FBRztBQUN4RCxXQUFPLElBQUksQ0FBQ3BELFlBQVksR0FBRyxDQUFDLEdBQUdaLGNBQWMsQ0FBQyxJQUFJLENBQUNXLE9BQU8sQ0FBQyxHQUFHLEVBQUU7R0FDakU7QUFFRCxXQUFTcUIsVUFBVUEsQ0FBQ3pLLEdBQUcsRUFBRXBXLENBQUMsRUFBRTtBQUMxQixRQUFJNFgsSUFBSSxHQUFHLElBQUkxRixLQUFLLENBQUNsUyxDQUFDLENBQUM7SUFDdkIsS0FBSyxJQUFJaEcsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHZ0csQ0FBQyxFQUFFLEVBQUVoRyxDQUFDLEVBQ3hCNGQsSUFBSSxDQUFDNWQsQ0FBQyxDQUFDLEdBQUdvYyxHQUFHLENBQUNwYyxDQUFDLENBQUM7QUFDbEIsV0FBTzRkLElBQUk7QUFDYjtBQUVBLFdBQVN3SyxTQUFTQSxDQUFDdFUsSUFBSSxFQUFFZ1YsS0FBSyxFQUFFO0lBQzlCLE9BQU9BLEtBQUssR0FBRyxDQUFDLEdBQUdoVixJQUFJLENBQUM3VCxNQUFNLEVBQUU2b0IsS0FBSyxFQUFFLEVBQ3JDaFYsSUFBSSxDQUFDZ1YsS0FBSyxDQUFDLEdBQUdoVixJQUFJLENBQUNnVixLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQy9CaFYsSUFBSSxDQUFDeEQsR0FBRyxFQUFFO0FBQ1o7RUFFQSxTQUFTb1ksZUFBZUEsQ0FBQ3RNLEdBQUcsRUFBRTtJQUM1QixJQUFJMk0sR0FBRyxHQUFHLElBQUk3USxLQUFLLENBQUNrRSxHQUFHLENBQUNuYyxNQUFNLENBQUM7QUFDL0IsU0FBSyxJQUFJRCxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUcrb0IsR0FBRyxDQUFDOW9CLE1BQU0sRUFBRSxFQUFFRCxDQUFDLEVBQUU7QUFDbkMrb0IsTUFBQUEsR0FBRyxDQUFDL29CLENBQUMsQ0FBQyxHQUFHb2MsR0FBRyxDQUFDcGMsQ0FBQyxDQUFDLENBQUM2bEIsUUFBUSxJQUFJekosR0FBRyxDQUFDcGMsQ0FBQyxDQUFDO0FBQ25DO0FBQ0QsV0FBTytvQixHQUFHO0FBQ1o7QUFFQSxXQUFTeEQsSUFBSUEsQ0FBQzhCLE9BQU8sRUFBRWxuQixJQUFJLEVBQUU7QUFDM0IsV0FBTyxJQUFJNm9CLE9BQU8sQ0FBQyxVQUFVQyxPQUFPLEVBQUVDLE1BQU0sRUFBRTtNQUM1QyxTQUFTQyxhQUFhQSxDQUFDMUMsR0FBRyxFQUFFO0FBQzFCWSxRQUFBQSxPQUFPLENBQUNPLGNBQWMsQ0FBQ3puQixJQUFJLEVBQUVpcEIsUUFBUSxDQUFDO1FBQ3RDRixNQUFNLENBQUN6QyxHQUFHLENBQUM7QUFDWjtNQUVELFNBQVMyQyxRQUFRQSxHQUFHO0FBQ2xCLFlBQUksT0FBTy9CLE9BQU8sQ0FBQ08sY0FBYyxLQUFLLFVBQVUsRUFBRTtBQUNoRFAsVUFBQUEsT0FBTyxDQUFDTyxjQUFjLENBQUMsT0FBTyxFQUFFdUIsYUFBYSxDQUFDO0FBQy9DO1FBQ0RGLE9BQU8sQ0FBQyxFQUFFLENBQUNobkIsS0FBSyxDQUFDN0MsSUFBSSxDQUFDRyxTQUFTLENBQUMsQ0FBQztBQUN2QztBQUVJOHBCLE1BQUFBLDhCQUE4QixDQUFDaEMsT0FBTyxFQUFFbG5CLElBQUksRUFBRWlwQixRQUFRLEVBQUU7QUFBRTdELFFBQUFBLElBQUksRUFBRTtBQUFJLE9BQUUsQ0FBQztNQUN2RSxJQUFJcGxCLElBQUksS0FBSyxPQUFPLEVBQUU7QUFDcEJtcEIsUUFBQUEsNkJBQTZCLENBQUNqQyxPQUFPLEVBQUU4QixhQUFhLEVBQUU7QUFBRTVELFVBQUFBLElBQUksRUFBRTtBQUFNLFVBQUM7QUFDdEU7QUFDTCxLQUFHLENBQUM7QUFDSjtBQUVBLFdBQVMrRCw2QkFBNkJBLENBQUNqQyxPQUFPLEVBQUVWLE9BQU8sRUFBRTRDLEtBQUssRUFBRTtBQUM5RCxRQUFJLE9BQU9sQyxPQUFPLENBQUNHLEVBQUUsS0FBSyxVQUFVLEVBQUU7TUFDcEM2Qiw4QkFBOEIsQ0FBQ2hDLE9BQU8sRUFBRSxPQUFPLEVBQUVWLE9BQU8sRUFBRTRDLEtBQUssQ0FBQztBQUNqRTtBQUNIO0VBRUEsU0FBU0YsOEJBQThCQSxDQUFDaEMsT0FBTyxFQUFFbG5CLElBQUksRUFBRTBsQixRQUFRLEVBQUUwRCxLQUFLLEVBQUU7QUFDdEUsUUFBSSxPQUFPbEMsT0FBTyxDQUFDRyxFQUFFLEtBQUssVUFBVSxFQUFFO01BQ3BDLElBQUkrQixLQUFLLENBQUNoRSxJQUFJLEVBQUU7QUFDZDhCLFFBQUFBLE9BQU8sQ0FBQzlCLElBQUksQ0FBQ3BsQixJQUFJLEVBQUUwbEIsUUFBUSxDQUFDO0FBQ2xDLE9BQUssTUFBTTtBQUNMd0IsUUFBQUEsT0FBTyxDQUFDRyxFQUFFLENBQUNybkIsSUFBSSxFQUFFMGxCLFFBQVEsQ0FBQztBQUMzQjtLQUNGLE1BQU0sSUFBSSxPQUFPd0IsT0FBTyxDQUFDbUMsZ0JBQWdCLEtBQUssVUFBVSxFQUFFO0FBQzdEO0FBQ0E7TUFDSW5DLE9BQU8sQ0FBQ21DLGdCQUFnQixDQUFDcnBCLElBQUksRUFBRSxTQUFTc3BCLFlBQVlBLENBQUNqbEIsR0FBRyxFQUFFO0FBQzlEO0FBQ0E7UUFDTSxJQUFJK2tCLEtBQUssQ0FBQ2hFLElBQUksRUFBRTtBQUNkOEIsVUFBQUEsT0FBTyxDQUFDcUMsbUJBQW1CLENBQUN2cEIsSUFBSSxFQUFFc3BCLFlBQVksQ0FBQztBQUNoRDtRQUNENUQsUUFBUSxDQUFDcmhCLEdBQUcsQ0FBQztBQUNuQixPQUFLLENBQUM7QUFDTixLQUFHLE1BQU07QUFDTCxZQUFNLElBQUlsQyxTQUFTLENBQUMscUVBQXFFLEdBQUcsT0FBTytrQixPQUFPLENBQUM7QUFDNUc7QUFDSDs7Ozs7O0FDaGZBOzs7Ozs7OztBQVFHO0FBRUgsSUFBWXNDLFNBdVVYO0FBdlVELFdBQVlBLFNBQVM7QUFDbkI7O0FBRUc7QUFDSEEsRUFBQUEsU0FBQSwyQkFBdUI7QUFFdkI7OztBQUdHO0FBQ0hBLEVBQUFBLFNBQUEsaUNBQTZCO0FBRTdCOzs7O0FBSUc7QUFDSEEsRUFBQUEsU0FBQSw2Q0FBeUM7QUFFekM7O0FBRUc7QUFDSEEsRUFBQUEsU0FBQSwrQkFBMkI7QUFFM0I7Ozs7Ozs7Ozs7QUFVRztBQUNIQSxFQUFBQSxTQUFBLGlDQUE2QjtBQUU3Qjs7OztBQUlHO0FBQ0hBLEVBQUFBLFNBQUEscURBQWlEO0FBRWpEOztBQUVHO0FBQ0hBLEVBQUFBLFNBQUEsK0NBQTJDO0FBRTNDOzs7Ozs7QUFNRztBQUNIQSxFQUFBQSxTQUFBLGlEQUE2QztBQUU3Qzs7Ozs7QUFLRztBQUNIQSxFQUFBQSxTQUFBLHVEQUFtRDtBQUVuRDs7Ozs7Ozs7QUFRRztBQUNIQSxFQUFBQSxTQUFBLHFDQUFpQztBQUVqQzs7Ozs7QUFLRztBQUNIQSxFQUFBQSxTQUFBLHVDQUFtQztBQUVuQzs7OztBQUlHO0FBQ0hBLEVBQUFBLFNBQUEsdURBQW1EO0FBRW5EOzs7O0FBSUc7QUFDSEEsRUFBQUEsU0FBQSx5Q0FBcUM7QUFFckM7Ozs7O0FBS0c7QUFDSEEsRUFBQUEsU0FBQSwyQ0FBdUM7QUFFdkM7Ozs7QUFJRztBQUNIQSxFQUFBQSxTQUFBLDZCQUF5QjtBQUV6Qjs7OztBQUlHO0FBQ0hBLEVBQUFBLFNBQUEsaUNBQTZCO0FBRTdCOzs7OztBQUtHO0FBQ0hBLEVBQUFBLFNBQUEsK0NBQTJDO0FBRTNDOzs7Ozs7OztBQVFHO0FBQ0hBLEVBQUFBLFNBQUEsbURBQStDO0FBRS9DOzs7OztBQUtHO0FBQ0hBLEVBQUFBLFNBQUEsMkRBQXVEO0FBRXZEOzs7Ozs7O0FBT0c7QUFDSEEsRUFBQUEsU0FBQSxtREFBK0M7QUFFL0M7Ozs7Ozs7O0FBUUc7QUFDSEEsRUFBQUEsU0FBQSw2REFBeUQ7QUFFekQ7Ozs7O0FBS0c7QUFDSEEsRUFBQUEsU0FBQSxxREFBaUQ7QUFFakQ7Ozs7O0FBS0c7QUFDSEEsRUFBQUEsU0FBQSxpRUFBNkQ7QUFFN0Q7Ozs7Ozs7QUFPRztBQUNIQSxFQUFBQSxTQUFBLCtDQUEyQztBQUUzQzs7Ozs7O0FBTUc7QUFDSEEsRUFBQUEsU0FBQSxpQ0FBNkI7QUFFN0I7Ozs7QUFJRztBQUNIQSxFQUFBQSxTQUFBLHVDQUFtQztBQUVuQzs7O0FBR0c7QUFDSEEsRUFBQUEsU0FBQSxtREFBK0M7QUFFL0M7Ozs7OztBQU1HO0FBQ0hBLEVBQUFBLFNBQUEseURBQXFEO0FBRXJEOzs7Ozs7Ozs7QUFTRztBQUNIQSxFQUFBQSxTQUFBLHVEQUFtRDtBQUVuRDs7Ozs7Ozs7O0FBU0c7QUFDSEEsRUFBQUEsU0FBQSw2RUFBeUU7QUFFekU7Ozs7Ozs7QUFPRztBQUNIQSxFQUFBQSxTQUFBLHFFQUFpRTtBQUVqRTs7OztBQUlHO0FBQ0hBLEVBQUFBLFNBQUEsdURBQW1EO0FBRW5EOzs7O0FBSUc7QUFDSEEsRUFBQUEsU0FBQSx1REFBbUQ7QUFFbkQ7Ozs7Ozs7O0FBUUc7QUFDSEEsRUFBQUEsU0FBQSwyQ0FBdUM7QUFFdkM7OztBQUdHO0FBQ0hBLEVBQUFBLFNBQUEsbUVBQStEO0FBRS9EOztBQUVHO0FBQ0hBLEVBQUFBLFNBQUEsdUNBQW1DO0FBRW5DOzs7QUFHRztBQUNIQSxFQUFBQSxTQUFBLHFEQUFpRDtBQUVqREEsRUFBQUEsU0FBQSw2RUFBeUU7QUFFekVBLEVBQUFBLFNBQUEsdUNBQW1DO0FBQ25DOzs7QUFHRztBQUNIQSxFQUFBQSxTQUFBLG1EQUErQztBQUUvQzs7O0FBR0c7QUFDSEEsRUFBQUEsU0FBQSwrQ0FBMkM7QUFFM0NBLEVBQUFBLFNBQUEsK0JBQTJCO0FBQzNCOztBQUVHO0FBQ0hBLEVBQUFBLFNBQUEsaURBQTZDO0FBRTdDOztBQUVHO0FBQ0hBLEVBQUFBLFNBQUEsdUNBQW1DO0FBQ3JDLENBQUMsRUF2VVdBLFNBQVMsS0FBVEEsU0FBUyxHQXVVcEI7QUFFRCxJQUFZQyxnQkFpTVg7QUFqTUQsV0FBWUEsZ0JBQWdCO0FBQzFCOzs7Ozs7OztBQVFHO0FBQ0hBLEVBQUFBLGdCQUFBLHFDQUFpQztBQUVqQzs7Ozs7QUFLRztBQUNIQSxFQUFBQSxnQkFBQSx1Q0FBbUM7QUFFbkM7Ozs7QUFJRztBQUNIQSxFQUFBQSxnQkFBQSx1REFBbUQ7QUFFbkQ7Ozs7QUFJRztBQUNIQSxFQUFBQSxnQkFBQSx5Q0FBcUM7QUFFckM7Ozs7O0FBS0c7QUFDSEEsRUFBQUEsZ0JBQUEsMkNBQXVDO0FBRXZDOzs7O0FBSUc7QUFDSEEsRUFBQUEsZ0JBQUEsNkJBQXlCO0FBRXpCOzs7O0FBSUc7QUFDSEEsRUFBQUEsZ0JBQUEsaUNBQTZCO0FBRTdCOzs7OztBQUtHO0FBQ0hBLEVBQUFBLGdCQUFBLCtDQUEyQztBQUUzQzs7Ozs7Ozs7QUFRRztBQUNIQSxFQUFBQSxnQkFBQSxtREFBK0M7QUFFL0M7Ozs7Ozs7OztBQVNHO0FBQ0hBLEVBQUFBLGdCQUFBLDZEQUF5RDtBQUV6RDs7Ozs7QUFLRztBQUNIQSxFQUFBQSxnQkFBQSxxREFBaUQ7QUFFakQ7Ozs7OztBQU1HO0FBQ0hBLEVBQUFBLGdCQUFBLGlDQUE2QjtBQUU3Qjs7OztBQUlHO0FBQ0hBLEVBQUFBLGdCQUFBLHVDQUFtQztBQUVuQzs7O0FBR0c7QUFDSEEsRUFBQUEsZ0JBQUEsbURBQStDO0FBRS9DOzs7O0FBSUc7QUFDSEEsRUFBQUEsZ0JBQUEsMkNBQXVDO0FBRXZDOzs7Ozs7QUFNRztBQUNIQSxFQUFBQSxnQkFBQSx5REFBcUQ7QUFFckQ7Ozs7Ozs7O0FBUUc7QUFDSEEsRUFBQUEsZ0JBQUEsdURBQW1EO0FBRW5EOzs7Ozs7OztBQVFHO0FBQ0hBLEVBQUFBLGdCQUFBLDZFQUF5RTtBQUV6RTs7O0FBR0c7QUFDSEEsRUFBQUEsZ0JBQUEscUVBQWlFO0FBRWpFO0FBQ0E7QUFDQUEsRUFBQUEsZ0JBQUEsMkNBQXVDO0FBRXZDO0FBQ0E7QUFDQUEsRUFBQUEsZ0JBQUEsK0NBQTJDO0FBRTNDOzs7QUFHRztBQUNIQSxFQUFBQSxnQkFBQSxtRUFBK0Q7QUFFL0Q7QUFDQUEsRUFBQUEsZ0JBQUEsaUNBQTZCO0FBRTdCOzs7OztBQUtHO0FBQ0hBLEVBQUFBLGdCQUFBLDJDQUF1QztBQUV2Qzs7QUFFRztBQUNIQSxFQUFBQSxnQkFBQSxpREFBNkM7QUFFN0M7QUFDQUEsRUFBQUEsZ0JBQUEsK0JBQTJCO0FBQzdCLENBQUMsRUFqTVdBLGdCQUFnQixLQUFoQkEsZ0JBQWdCLEdBaU0zQjtBQUVEO0FBQ0EsSUFBWUMsV0E2Qlg7QUE3QkQsV0FBWUEsV0FBVztBQUNyQkEsRUFBQUEsV0FBQSwyQ0FBdUM7QUFDdkNBLEVBQUFBLFdBQUEsMkJBQXVCO0FBQ3ZCQSxFQUFBQSxXQUFBLGlDQUE2QjtBQUM3QkEsRUFBQUEsV0FBQSx5QkFBcUI7QUFDckJBLEVBQUFBLFdBQUEsdUJBQW1CO0FBQ25CQSxFQUFBQSxXQUFBLDZCQUF5QjtBQUN6QkEsRUFBQUEsV0FBQSwyQkFBdUI7QUFDdkJBLEVBQUFBLFdBQUEsbUNBQStCO0FBQy9CQSxFQUFBQSxXQUFBLHVDQUFtQztBQUNuQ0EsRUFBQUEsV0FBQSx1QkFBbUI7QUFDbkJBLEVBQUFBLFdBQUEsdUNBQW1DO0FBQ25DQSxFQUFBQSxXQUFBLGlEQUE2QztBQUM3Q0EsRUFBQUEsV0FBQSw2Q0FBeUM7QUFDekNBLEVBQUFBLFdBQUEsMkNBQXVDO0FBQ3ZDQSxFQUFBQSxXQUFBLG1EQUErQztBQUMvQ0EsRUFBQUEsV0FBQSwyQ0FBdUM7QUFDdkNBLEVBQUFBLFdBQUEsNkJBQXlCO0FBQ3pCQSxFQUFBQSxXQUFBLHVDQUFtQztBQUNuQ0EsRUFBQUEsV0FBQSw2Q0FBeUM7QUFDekNBLEVBQUFBLFdBQUEsdURBQW1EO0FBQ25EQSxFQUFBQSxXQUFBLDJDQUF1QztBQUN2Q0EsRUFBQUEsV0FBQSxpRUFBNkQ7QUFDN0RBLEVBQUFBLFdBQUEsNkJBQXlCO0FBQ3pCQSxFQUFBQSxXQUFBLHVEQUFtRDtBQUNuREEsRUFBQUEsV0FBQSxtREFBK0M7QUFDL0NBLEVBQUFBLFdBQUEsaURBQTZDO0FBQzdDQSxFQUFBQSxXQUFBLHVCQUFtQjtBQUNuQkEsRUFBQUEsV0FBQSxtREFBK0M7QUFDakQsQ0FBQyxFQTdCV0EsV0FBVyxLQUFYQSxXQUFXLEdBNkJ0QjtBQUVELElBQVlDLFVBOEVYO0FBOUVELFdBQVlBLFVBQVU7QUFDcEJBLEVBQUFBLFVBQUEsdUJBQW1CO0FBQ25CQSxFQUFBQSxVQUFBLG1CQUFlO0FBQ2ZBLEVBQUFBLFVBQUEsdUJBQW1CO0FBQ25COztBQUVHO0FBQ0hBLEVBQUFBLFVBQUEsMkJBQXVCO0FBQ3ZCQSxFQUFBQSxVQUFBLG1CQUFlO0FBQ2ZBLEVBQUFBLFVBQUEsNkJBQXlCO0FBQ3pCQSxFQUFBQSxVQUFBLGlDQUE2QjtBQUM3QjtBQUNBQSxFQUFBQSxVQUFBLHFDQUFpQztBQUNqQztBQUNBQSxFQUFBQSxVQUFBLDZDQUF5QztBQUN6QztBQUNBQSxFQUFBQSxVQUFBLGlEQUE2QztBQUM3QztBQUNBQSxFQUFBQSxVQUFBLCtDQUEyQztBQUMzQzs7O0FBR0c7QUFDSEEsRUFBQUEsVUFBQSxpREFBNkM7QUFDN0M7QUFDQUEsRUFBQUEsVUFBQSwyQ0FBdUM7QUFDdkM7QUFDQUEsRUFBQUEsVUFBQSxxREFBaUQ7QUFDakQ7QUFDQUEsRUFBQUEsVUFBQSxpREFBNkM7QUFDN0M7QUFDQUEsRUFBQUEsVUFBQSwrQ0FBMkM7QUFDM0M7QUFDQUEsRUFBQUEsVUFBQSx1Q0FBbUM7QUFDbkM7QUFDQUEsRUFBQUEsVUFBQSx1Q0FBbUM7QUFDbkM7OztBQUdHO0FBQ0hBLEVBQUFBLFVBQUEscUNBQWlDO0FBQ2pDOzs7QUFHRztBQUNIQSxFQUFBQSxVQUFBLHVDQUFtQztBQUNuQzs7O0FBR0c7QUFDSEEsRUFBQUEsVUFBQSxtRUFBK0Q7QUFDL0Q7O0FBRUc7QUFDSEEsRUFBQUEsVUFBQSwyREFBdUQ7QUFDdkQ7O0FBRUc7QUFDSEEsRUFBQUEsVUFBQSw2Q0FBeUM7QUFDekM7O0FBRUc7QUFDSEEsRUFBQUEsVUFBQSxpREFBNkM7QUFFN0M7O0FBRUc7QUFDSEEsRUFBQUEsVUFBQSx1REFBbUQ7QUFFbkQ7O0FBRUc7QUFDSEEsRUFBQUEsVUFBQSxtREFBK0M7QUFFL0M7O0FBRUc7QUFDSEEsRUFBQUEsVUFBQSxxQ0FBaUM7QUFDbkMsQ0FBQyxFQTlFV0EsVUFBVSxLQUFWQSxVQUFVLEdBOEVyQjs7QUNubkJELE1BQU1DLHlCQUF5QixHQUFHLElBQUk7QUFFdEM7QUFDQTtBQUNBLE1BQU1DLGdCQUFnQixHQUE0QixFQUFFO0FBRXBELElBQVlDLFlBSVg7QUFKRCxXQUFZQSxZQUFZO0VBQ3RCQSxZQUFBLENBQUFBLFlBQUEsb0JBQXNCO0VBQ3RCQSxZQUFBLENBQUFBLFlBQUEsMEJBQTRCO0VBQzVCQSxZQUFBLENBQUFBLFlBQUEsc0JBQXdCO0FBQzFCLENBQUMsRUFKV0EsWUFBWSxLQUFaQSxZQUFZLEdBSXZCO0FBQ0ssTUFBZ0JDLEtBRXBCLFNBQVM5RSwwQkFBaUU7QUE4QzFFcGMsRUFBQUEsV0FBQUEsQ0FDRW1oQixVQUE0QixFQUM1QjdWLElBQWUsRUFDa0I7QUFBQSxRQUFqQzhWLG9GQUErQixFQUFFOztBQUVqQyxTQUFLLEVBQUU7SUFoRFQsSUFBZ0IsQ0FBQUMsZ0JBQUEsR0FBdUIsRUFBRTtJQUV6QyxJQUFPLENBQUFDLE9BQUEsR0FBWSxLQUFLO0FBY3hCOzs7QUFHRztBQUNILFNBQUFDLFdBQVcsR0FBc0JMLEtBQUssQ0FBQ3BKLFdBQVcsQ0FBQzBKLE1BQU07SUFTL0MsSUFBYyxDQUFBQyxjQUFBLEdBQVksS0FBSztJQVEvQixJQUFlLENBQUFDLGVBQUEsR0FBVyxDQUFDO0lBSTNCLElBQUcsQ0FBQXpzQixHQUFBLEdBQXFCQSxhQUFHO0lBMk4zQixJQUE0QixDQUFBMHNCLDRCQUFBLEdBQUcsTUFBSztNQUM1QyxJQUFJLElBQUksQ0FBQ0MsaUJBQWlCLEVBQUU7QUFDMUJDLFFBQUFBLFlBQVksQ0FBQyxJQUFJLENBQUNELGlCQUFpQixDQUFDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFVBQUlwcEIsUUFBUSxDQUFDc3BCLGVBQWUsS0FBSyxRQUFRLEVBQUU7QUFDekMsWUFBSSxDQUFDRixpQkFBaUIsR0FBR0csVUFBVSxDQUNqQyxNQUFNLElBQUksQ0FBQ0MsMEJBQTBCLEVBQUUsRUFDdkNqQix5QkFBeUIsQ0FDMUI7QUFDSCxPQUFDLE1BQU07UUFDTCxJQUFJLENBQUNpQiwwQkFBMEIsRUFBRTtBQUNuQztLQUNEO0lBak9DLElBQUksQ0FBQy9zQixHQUFHLEdBQUdnRixTQUFTLENBQUMsQ0FBQXlGLEVBQUEsR0FBQTBoQixhQUFhLENBQUNhLFVBQVUsTUFBSSxRQUFBdmlCLEVBQUEsY0FBQUEsRUFBQSxHQUFBbkYsV0FBVyxDQUFDMm1CLEtBQUssQ0FBQztBQUNuRSxRQUFJLENBQUNnQixlQUFlLEdBQUdkLGFBQWEsQ0FBQ2MsZUFBZTtBQUVwRCxRQUFJLENBQUNsRixlQUFlLENBQUMsR0FBRyxDQUFDO0lBQ3pCLElBQUksQ0FBQzFSLElBQUksR0FBR0EsSUFBSTtJQUNoQixJQUFJLENBQUM2VyxpQkFBaUIsR0FBR2hCLFVBQVU7QUFDbkMsUUFBSSxDQUFDaUIsY0FBYyxHQUFHakIsVUFBVSxDQUFDcEksRUFBRTtBQUNuQyxRQUFJLENBQUMxRSxNQUFNLEdBQUc2TSxLQUFLLENBQUNtQixNQUFNLENBQUNDLE9BQU87QUFDcEM7RUFFQSxJQUFjQyxVQUFVQSxHQUFBOztBQUN0QixXQUNLOW5CLE1BQUEsQ0FBQTZDLE1BQUEsQ0FBQTdDLE1BQUEsQ0FBQTZDLE1BQUEsTUFBQW9DLEVBQUEsT0FBSSxDQUFDd2lCLGVBQWUsY0FBQXhpQixFQUFBLHVCQUFBQSxFQUFBLENBQUF0SixJQUFBLE1BQUksR0FDeEJvc0Isc0JBQXNCLENBQUMsSUFBSSxDQUFDLENBQy9CO0FBQ0o7QUFFQTtFQUNBLElBQUlDLGNBQWNBLEdBQUE7SUFDaEIsT0FBTyxJQUFJLENBQUNmLGVBQWU7QUFDN0I7RUFFQSxJQUFJZ0IsZ0JBQWdCQSxHQUFBO0lBQ2xCLE9BQU8sSUFBSSxDQUFDUCxpQkFBaUI7QUFDL0I7QUFFQTs7OztBQUlHO0VBQ0gsSUFBSVEsYUFBYUEsR0FBQTtJQUNmLE9BQU8sSUFBSSxDQUFDUCxjQUFjO0FBQzVCO0VBV0FRLE1BQU1BLENBQUNDLE9BQTBCO0lBQy9CLElBQUlDLFdBQVcsR0FBRyxPQUFPO0lBQ3pCLElBQUksSUFBSSxDQUFDeFgsSUFBSSxLQUFLNFYsS0FBSyxDQUFDNkIsSUFBSSxDQUFDQyxLQUFLLEVBQUU7QUFDbENGLE1BQUFBLFdBQVcsR0FBRyxPQUFPO0FBQ3ZCO0FBQ0EsUUFBSSxJQUFJLENBQUN6QixnQkFBZ0IsQ0FBQ3BxQixNQUFNLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQ3FVLElBQUksS0FBSzRWLEtBQUssQ0FBQzZCLElBQUksQ0FBQ0MsS0FBSyxFQUFFO01BQ3hFLElBQUksQ0FBQ0Msd0JBQXdCLEVBQUU7QUFDakM7SUFDQSxJQUFJLENBQUNKLE9BQU8sRUFBRTtNQUNaLElBQUlDLFdBQVcsS0FBSyxPQUFPLEVBQUU7QUFDM0I5QixRQUFBQSxnQkFBZ0IsQ0FBQ2tDLE9BQU8sQ0FBRTdzQixDQUFDLElBQUk7VUFDN0IsSUFBSUEsQ0FBQyxDQUFDOHNCLGFBQWEsS0FBSyxJQUFJLElBQUksQ0FBQ04sT0FBTyxFQUFFO0FBQ3hDQSxZQUFBQSxPQUFPLEdBQUd4c0IsQ0FBQztBQUNiO0FBQ0YsU0FBQyxDQUFDO0FBQ0YsWUFBSXdzQixPQUFPLEVBQUU7QUFDWDtVQUNBN0IsZ0JBQWdCLENBQUNvQyxNQUFNLENBQUNwQyxnQkFBZ0IsQ0FBQ2pvQixPQUFPLENBQUM4cEIsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQy9EO0FBQ0Y7TUFDQSxJQUFJLENBQUNBLE9BQU8sRUFBRTtBQUNaQSxRQUFBQSxPQUFPLEdBQXFCcnFCLFFBQVEsQ0FBQzZxQixhQUFhLENBQUNQLFdBQVcsQ0FBQztBQUNqRTtBQUNGO0lBRUEsSUFBSSxDQUFDLElBQUksQ0FBQ3pCLGdCQUFnQixDQUFDMUksUUFBUSxDQUFDa0ssT0FBTyxDQUFDLEVBQUU7QUFDNUMsVUFBSSxDQUFDeEIsZ0JBQWdCLENBQUNua0IsSUFBSSxDQUFDMmxCLE9BQU8sQ0FBQztBQUNyQztBQUVBO0FBQ0E7QUFDQTtBQUNBUyxJQUFBQSxlQUFlLENBQUMsSUFBSSxDQUFDWixnQkFBZ0IsRUFBRUcsT0FBTyxDQUFDO0FBRS9DO0lBQ0EsTUFBTVUsb0JBQW9CLEdBQUlWLE9BQU8sQ0FBQ1csU0FBeUIsQ0FBQ0MsU0FBUyxFQUFFO0FBQzNFLFVBQU1DLFFBQVEsR0FBR0gsb0JBQW9CLENBQUNJLElBQUksQ0FBRUMsRUFBRSxJQUFLQSxFQUFFLENBQUN0WSxJQUFJLEtBQUssT0FBTyxDQUFDO0FBRXZFO0FBQ0F1WCxJQUFBQSxPQUFPLENBQ0pnQixJQUFJLEVBQUUsQ0FDTkMsSUFBSSxDQUFDLE1BQUs7QUFDVCxVQUFJLENBQUMxRyxJQUFJLENBQUNzRyxRQUFRLEdBQUc1QyxVQUFVLENBQUNpRCxvQkFBb0IsR0FBR2pELFVBQVUsQ0FBQ2tELG9CQUFvQixDQUFDO0FBQ3pGLEtBQUMsQ0FBQyxDQUNEQyxLQUFLLENBQUU1dEIsQ0FBQyxJQUFJO0FBQ1gsVUFBSUEsQ0FBQyxDQUFDYyxJQUFJLEtBQUssaUJBQWlCLEVBQUU7QUFDaEMsWUFBSSxDQUFDaW1CLElBQUksQ0FBQ3NHLFFBQVEsR0FBRzVDLFVBQVUsQ0FBQ29ELG1CQUFtQixHQUFHcEQsVUFBVSxDQUFDcUQsbUJBQW1CLEVBQUU5dEIsQ0FBQyxDQUFDO0FBQzFGLE9BQUMsTUFBTSxJQUFJQSxDQUFDLENBQUNjLElBQUksS0FBSyxZQUFZLEVBQUU7QUFDbEM7UUFDQWxDLGFBQUcsQ0FBQ21DLEtBQUssSUFBQTJILE1BQUEsQ0FDSjJrQixRQUFRLEdBQUcsT0FBTyxHQUFHLE9BQU8sc0RBQW1ELENBQ25GO0FBQ0gsT0FBQyxNQUFNO0FBQ0x6dUIsUUFBQUEsYUFBRyxDQUFDaW5CLElBQUksQ0FBQW5kLHFCQUFBQSxDQUFBQSxNQUFBLENBQXVCMmtCLFFBQVEsR0FBRyxPQUFPLEdBQUcsT0FBTyxDQUFJcnRCLEVBQUFBLENBQUMsQ0FBQztBQUNuRTtBQUNBO01BQ0EsSUFDRXF0QixRQUFRLElBQ1JiLE9BQU8sSUFDUFUsb0JBQW9CLENBQUNJLElBQUksQ0FBRUMsRUFBRSxJQUFLQSxFQUFFLENBQUN0WSxJQUFJLEtBQUssT0FBTyxDQUFDLElBQ3REalYsQ0FBQyxDQUFDYyxJQUFJLEtBQUssaUJBQWlCLEVBQzVCO1FBQ0EwckIsT0FBTyxDQUFDdUIsS0FBSyxHQUFHLElBQUk7QUFDcEJ2QixRQUFBQSxPQUFPLENBQUNnQixJQUFJLEVBQUUsQ0FBQ0ksS0FBSyxDQUFDLE1BQUs7QUFDeEI7QUFBQSxTQUNELENBQUM7QUFDSjtBQUNGLEtBQUMsQ0FBQztJQUVKLElBQUksQ0FBQzdHLElBQUksQ0FBQzBELFVBQVUsQ0FBQ3VELGVBQWUsRUFBRXhCLE9BQU8sQ0FBQztBQUM5QyxXQUFPQSxPQUFPO0FBQ2hCO0VBWUF5QixNQUFNQSxDQUFDekIsT0FBMEI7SUFDL0IsSUFBSTtBQUNGO0FBQ0EsVUFBSUEsT0FBTyxFQUFFO0FBQ1gwQixRQUFBQSxXQUFXLENBQUMsSUFBSSxDQUFDN0IsZ0JBQWdCLEVBQUVHLE9BQU8sQ0FBQztRQUMzQyxNQUFNMkIsR0FBRyxHQUFHLElBQUksQ0FBQ25ELGdCQUFnQixDQUFDdG9CLE9BQU8sQ0FBQzhwQixPQUFPLENBQUM7UUFDbEQsSUFBSTJCLEdBQUcsSUFBSSxDQUFDLEVBQUU7VUFDWixJQUFJLENBQUNuRCxnQkFBZ0IsQ0FBQytCLE1BQU0sQ0FBQ29CLEdBQUcsRUFBRSxDQUFDLENBQUM7QUFDcEMsY0FBSSxDQUFDQyxjQUFjLENBQUM1QixPQUFPLENBQUM7VUFDNUIsSUFBSSxDQUFDekYsSUFBSSxDQUFDMEQsVUFBVSxDQUFDNEQsZUFBZSxFQUFFN0IsT0FBTyxDQUFDO0FBQ2hEO0FBQ0EsZUFBT0EsT0FBTztBQUNoQjtNQUVBLE1BQU04QixRQUFRLEdBQXVCLEVBQUU7QUFDdkMsVUFBSSxDQUFDdEQsZ0JBQWdCLENBQUM2QixPQUFPLENBQUUwQixHQUFHLElBQUk7QUFDcENMLFFBQUFBLFdBQVcsQ0FBQyxJQUFJLENBQUM3QixnQkFBZ0IsRUFBRWtDLEdBQUcsQ0FBQztBQUN2Q0QsUUFBQUEsUUFBUSxDQUFDem5CLElBQUksQ0FBQzBuQixHQUFHLENBQUM7QUFDbEIsWUFBSSxDQUFDSCxjQUFjLENBQUNHLEdBQUcsQ0FBQztRQUN4QixJQUFJLENBQUN4SCxJQUFJLENBQUMwRCxVQUFVLENBQUM0RCxlQUFlLEVBQUVFLEdBQUcsQ0FBQztBQUM1QyxPQUFDLENBQUM7QUFFRjtNQUNBLElBQUksQ0FBQ3ZELGdCQUFnQixHQUFHLEVBQUU7QUFDMUIsYUFBT3NELFFBQVE7QUFDakIsS0FBQyxTQUFTO0FBQ1IsVUFBSSxJQUFJLENBQUN0RCxnQkFBZ0IsQ0FBQ3BxQixNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3RDLElBQUksQ0FBQzR0QiwyQkFBMkIsRUFBRTtBQUNwQztBQUNGO0FBQ0Y7QUFFQUMsRUFBQUEsSUFBSUEsR0FBQTtJQUNGLElBQUksQ0FBQ0MsV0FBVyxFQUFFO0FBQ2xCLFFBQUksQ0FBQzVDLGlCQUFpQixDQUFDMkMsSUFBSSxFQUFFO0FBQy9CO0FBRVVFLEVBQUFBLE1BQU1BLEdBQUE7QUFDZCxRQUFJLENBQUM3QyxpQkFBaUIsQ0FBQzhDLE9BQU8sR0FBRyxJQUFJO0FBQ3ZDO0FBRVVDLEVBQUFBLE9BQU9BLEdBQUE7QUFDZixRQUFJLENBQUMvQyxpQkFBaUIsQ0FBQzhDLE9BQU8sR0FBRyxLQUFLO0FBQ3hDO0FBS0E7QUFDQUYsRUFBQUEsV0FBV0EsR0FBQTtJQUNULElBQUksSUFBSSxDQUFDSSxlQUFlLEVBQUU7QUFDeEJDLE1BQUFBLGFBQWEsQ0FBQyxJQUFJLENBQUNELGVBQWUsQ0FBQztBQUNyQztJQUNBLElBQUksSUFBSSxDQUFDRSxjQUFjLEVBQUU7QUFDdkJDLE1BQUFBLG9CQUFvQixDQUFDLElBQUksQ0FBQ0QsY0FBYyxDQUFDO0FBQzNDO0FBQ0Y7QUFFQTtFQUNBRSxtQkFBbUJBLENBQUNuRSxhQUE0QjtJQUM5QyxJQUFJQSxhQUFhLENBQUNhLFVBQVUsRUFBRTtNQUM1QixJQUFJLENBQUNodEIsR0FBRyxHQUFHZ0YsU0FBUyxDQUFDbW5CLGFBQWEsQ0FBQ2EsVUFBVSxDQUFDO0FBQ2hEO0lBQ0EsSUFBSWIsYUFBYSxDQUFDYyxlQUFlLEVBQUU7QUFDakMsVUFBSSxDQUFDQSxlQUFlLEdBQUdkLGFBQWEsQ0FBQ2MsZUFBZTtBQUN0RDtBQUNGO0VBRVF1QyxjQUFjQSxDQUFDNUIsT0FBeUI7SUFDOUMsSUFBSUEsT0FBTyxZQUFZMkMsZ0JBQWdCLEVBQUU7QUFDdkM7TUFDQSxJQUFJQyxXQUFXLEdBQUcsSUFBSTtNQUN0QjVDLE9BQU8sQ0FBQzZDLEtBQUssRUFBRTtBQUNmMUUsTUFBQUEsZ0JBQWdCLENBQUNrQyxPQUFPLENBQUU3c0IsQ0FBQyxJQUFJO0FBQzdCLFlBQUksQ0FBQ0EsQ0FBQyxDQUFDOHNCLGFBQWEsRUFBRTtBQUNwQnNDLFVBQUFBLFdBQVcsR0FBRyxLQUFLO0FBQ3JCO0FBQ0YsT0FBQyxDQUFDO0FBQ0YsVUFBSUEsV0FBVyxFQUFFO0FBQ2Z6RSxRQUFBQSxnQkFBZ0IsQ0FBQzlqQixJQUFJLENBQUMybEIsT0FBTyxDQUFDO0FBQ2hDO0FBQ0Y7QUFDRjtBQWtCZ0JiLEVBQUFBLDBCQUEwQkEsR0FBQTs7QUFDeEMsVUFBSSxDQUFDUCxjQUFjLEdBQUdqcEIsUUFBUSxDQUFDc3BCLGVBQWUsS0FBSyxRQUFRO0FBQzNELFVBQUksQ0FBQyxJQUFJLENBQUNMLGNBQWMsSUFBSSxJQUFJLENBQUNuVyxJQUFJLEtBQUs0VixLQUFLLENBQUM2QixJQUFJLENBQUNDLEtBQUssRUFBRTtBQUMxRGpCLFFBQUFBLFVBQVUsQ0FDUixNQUNFLElBQUksQ0FBQ1YsZ0JBQWdCLENBQUM2QixPQUFPLENBQUV5QyxFQUFFLElBQy9CQSxFQUFFLENBQUM5QixJQUFJLEVBQUUsQ0FBQ0ksS0FBSyxDQUFDLE1BQUs7QUFDbkI7QUFBQSxTQUNELENBQUMsQ0FDSCxFQUNILENBQUMsQ0FDRjtBQUNIO0FBQ0YsS0FBQztBQUFBO0FBRVNoQixFQUFBQSx3QkFBd0JBLEdBQUE7SUFDaEMsSUFBSTJDLEtBQUssRUFBRSxFQUFFO0FBQ1gsVUFBSSxDQUFDbkUsY0FBYyxHQUFHanBCLFFBQVEsQ0FBQ3NwQixlQUFlLEtBQUssUUFBUTtNQUMzRHRwQixRQUFRLENBQUNnb0IsZ0JBQWdCLENBQUMsa0JBQWtCLEVBQUUsSUFBSSxDQUFDbUIsNEJBQTRCLENBQUM7QUFDbEYsS0FBQyxNQUFNO01BQ0wsSUFBSSxDQUFDRixjQUFjLEdBQUcsS0FBSztBQUM3QjtBQUNGO0FBRVVvRCxFQUFBQSwyQkFBMkJBLEdBQUE7SUFDbkMsSUFBSWUsS0FBSyxFQUFFLEVBQUU7TUFDWHB0QixRQUFRLENBQUNrb0IsbUJBQW1CLENBQUMsa0JBQWtCLEVBQUUsSUFBSSxDQUFDaUIsNEJBQTRCLENBQUM7QUFDckY7QUFDRjtBQUNEO0FBRWUsU0FBQTJCLGVBQWVBLENBQUN1QyxLQUF1QixFQUFFaEQsT0FBeUI7QUFDaEYsTUFBSWlELFdBQXdCO0FBQzVCLE1BQUlqRCxPQUFPLENBQUNXLFNBQVMsWUFBWXVDLFdBQVcsRUFBRTtJQUM1Q0QsV0FBVyxHQUFHakQsT0FBTyxDQUFDVyxTQUFTO0FBQ2pDLEdBQUMsTUFBTTtBQUNMc0MsSUFBQUEsV0FBVyxHQUFHLElBQUlDLFdBQVcsRUFBRTtBQUNqQztBQUVBO0FBQ0EsTUFBSUMsY0FBa0M7QUFDdEMsTUFBSUgsS0FBSyxDQUFDdmEsSUFBSSxLQUFLLE9BQU8sRUFBRTtBQUMxQjBhLElBQUFBLGNBQWMsR0FBR0YsV0FBVyxDQUFDRyxjQUFjLEVBQUU7QUFDL0MsR0FBQyxNQUFNO0FBQ0xELElBQUFBLGNBQWMsR0FBR0YsV0FBVyxDQUFDSSxjQUFjLEVBQUU7QUFDL0M7QUFDQSxNQUFJLENBQUNGLGNBQWMsQ0FBQ3JOLFFBQVEsQ0FBQ2tOLEtBQUssQ0FBQyxFQUFFO0FBQ25DRyxJQUFBQSxjQUFjLENBQUM5QyxPQUFPLENBQUVpRCxFQUFFLElBQUk7QUFDNUJMLE1BQUFBLFdBQVcsQ0FBQ00sV0FBVyxDQUFDRCxFQUFFLENBQUM7QUFDN0IsS0FBQyxDQUFDO0FBQ0ZMLElBQUFBLFdBQVcsQ0FBQ08sUUFBUSxDQUFDUixLQUFLLENBQUM7QUFDN0I7RUFFQSxJQUFJLENBQUNTLFFBQVEsRUFBRSxJQUFJLEVBQUV6RCxPQUFPLFlBQVkwRCxnQkFBZ0IsQ0FBQyxFQUFFO0FBQ3pEO0FBQ0E7QUFDQTtJQUNBMUQsT0FBTyxDQUFDMkQsUUFBUSxHQUFHLElBQUk7QUFDekI7QUFDQTtFQUNBM0QsT0FBTyxDQUFDdUIsS0FBSyxHQUFHMEIsV0FBVyxDQUFDRyxjQUFjLEVBQUUsQ0FBQ2h2QixNQUFNLEtBQUssQ0FBQztFQUN6RCxJQUFJNHJCLE9BQU8sWUFBWTBELGdCQUFnQixFQUFFO0lBQ3ZDMUQsT0FBTyxDQUFDNEQsV0FBVyxHQUFHLElBQUk7QUFDNUI7QUFFQTtBQUNBLE1BQUk1RCxPQUFPLENBQUNXLFNBQVMsS0FBS3NDLFdBQVcsRUFBRTtJQUNyQ2pELE9BQU8sQ0FBQ1csU0FBUyxHQUFHc0MsV0FBVztBQUMvQixRQUFJLENBQUNRLFFBQVEsRUFBRSxJQUFJSSxTQUFTLEVBQUUsS0FBSzdELE9BQU8sWUFBWTBELGdCQUFnQixFQUFFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBeEUsTUFBQUEsVUFBVSxDQUFDLE1BQUs7UUFDZGMsT0FBTyxDQUFDVyxTQUFTLEdBQUdzQyxXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBakQsUUFBQUEsT0FBTyxDQUFDZ0IsSUFBSSxFQUFFLENBQUNJLEtBQUssQ0FBQyxNQUFLO0FBQ3hCO0FBQUEsU0FDRCxDQUFDO09BQ0gsRUFBRSxDQUFDLENBQUM7QUFDUDtBQUNGO0FBQ0Y7QUFFQTtBQUNnQixTQUFBTSxXQUFXQSxDQUFDc0IsS0FBdUIsRUFBRWhELE9BQXlCO0FBQzVFLE1BQUlBLE9BQU8sQ0FBQ1csU0FBUyxZQUFZdUMsV0FBVyxFQUFFO0FBQzVDLFVBQU1ELFdBQVcsR0FBR2pELE9BQU8sQ0FBQ1csU0FBUztBQUNyQ3NDLElBQUFBLFdBQVcsQ0FBQ00sV0FBVyxDQUFDUCxLQUFLLENBQUM7SUFDOUIsSUFBSUMsV0FBVyxDQUFDckMsU0FBUyxFQUFFLENBQUN4c0IsTUFBTSxHQUFHLENBQUMsRUFBRTtNQUN0QzRyQixPQUFPLENBQUNXLFNBQVMsR0FBR3NDLFdBQVc7QUFDakMsS0FBQyxNQUFNO01BQ0xqRCxPQUFPLENBQUNXLFNBQVMsR0FBRyxJQUFJO0FBQzFCO0FBQ0Y7QUFDRjtBQUVBLFdBQWlCdEMsS0FBSztBQUNwQixNQUFZNkIsSUFJWDtFQUpELFdBQVlBLElBQUk7QUFDZEEsSUFBQUEsSUFBQSxtQkFBZTtBQUNmQSxJQUFBQSxJQUFBLG1CQUFlO0FBQ2ZBLElBQUFBLElBQUEsdUJBQW1CO0FBQ3JCLEdBQUMsRUFKV0EsSUFBSSxHQUFKN0IsS0FBSSxDQUFBNkIsSUFBQSxLQUFKN0IsVUFBSSxHQUlmO0FBRUQsTUFBWW1CLE1BTVg7RUFORCxXQUFZQSxNQUFNO0FBQ2hCQSxJQUFBQSxNQUFBLHFCQUFpQjtBQUNqQkEsSUFBQUEsTUFBQSw2QkFBeUI7QUFDekJBLElBQUFBLE1BQUEsZ0NBQTRCO0FBQzVCQSxJQUFBQSxNQUFBLDJDQUF1QztBQUN2Q0EsSUFBQUEsTUFBQSx1QkFBbUI7QUFDckIsR0FBQyxFQU5XQSxNQUFNLEdBQU5uQixLQUFNLENBQUFtQixNQUFBLEtBQU5uQixZQUFNLEdBTWpCO0FBRUQsTUFBWXBKLGFBSVg7RUFKRCxXQUFZQSxXQUFXO0FBQ3JCQSxJQUFBQSxXQUFBLHFCQUFpQjtBQUNqQkEsSUFBQUEsV0FBQSxxQkFBaUI7QUFDakJBLElBQUFBLFdBQUEsdUJBQW1CO0FBQ3JCLEdBQUMsRUFKV0EsYUFBVyxHQUFYb0osS0FBVyxDQUFBcEosV0FBQSxLQUFYb0osaUJBQVcsR0FJdEI7QUFPRDtFQUNBLFNBQWdCeUYsV0FBV0EsQ0FBQzlSLENBQU87QUFDakMsWUFBUUEsQ0FBQztNQUNQLEtBQUtrTyxJQUFJLENBQUM2RCxLQUFLO1FBQ2IsT0FBT2hQLFNBQVMsQ0FBQ2lQLEtBQUs7TUFDeEIsS0FBSzlELElBQUksQ0FBQ0MsS0FBSztRQUNiLE9BQU9wTCxTQUFTLENBQUNrUCxLQUFLO0FBQ3hCO0FBQ0U7UUFDQSxPQUFPbFAsU0FBUyxDQUFDbVAsSUFBSTtBQUN6QjtBQUNGO0VBVmdCN0YsS0FBQSxDQUFBeUYsV0FBVyxjQVUxQjtBQUVEO0VBQ0EsU0FBZ0JLLGFBQWFBLENBQUM5cUIsQ0FBWTtBQUN4QyxZQUFRQSxDQUFDO01BQ1AsS0FBSzBiLFNBQVMsQ0FBQ2lQLEtBQUs7UUFDbEIsT0FBTzlELElBQUksQ0FBQzZELEtBQUs7TUFDbkIsS0FBS2hQLFNBQVMsQ0FBQ2tQLEtBQUs7UUFDbEIsT0FBTy9ELElBQUksQ0FBQ0MsS0FBSztBQUNuQjtRQUNFLE9BQU9ELElBQUksQ0FBQ1QsT0FBTztBQUN2QjtBQUNGO0VBVGdCcEIsS0FBQSxDQUFBOEYsYUFBYSxnQkFTNUI7QUFFRDtFQUNBLFNBQWdCQyxhQUFhQSxDQUFDOWMsQ0FBUztBQUNyQyxZQUFRQSxDQUFDO01BQ1AsS0FBS2tZLE1BQU0sQ0FBQzZFLE1BQU07UUFDaEIsT0FBT3JQLFdBQVcsQ0FBQ3NQLE1BQU07TUFDM0IsS0FBSzlFLE1BQU0sQ0FBQytFLFVBQVU7UUFDcEIsT0FBT3ZQLFdBQVcsQ0FBQ3dQLFVBQVU7TUFDL0IsS0FBS2hGLE1BQU0sQ0FBQ2lGLFdBQVc7UUFDckIsT0FBT3pQLFdBQVcsQ0FBQzBQLFlBQVk7TUFDakMsS0FBS2xGLE1BQU0sQ0FBQ21GLGdCQUFnQjtRQUMxQixPQUFPM1AsV0FBVyxDQUFDNFAsa0JBQWtCO0FBQ3ZDO1FBQ0UsT0FBTzVQLFdBQVcsQ0FBQzZQLE9BQU87QUFDOUI7QUFDRjtFQWJnQnhHLEtBQUEsQ0FBQStGLGFBQWEsZ0JBYTVCO0FBRUQ7RUFDQSxTQUFnQlUsZUFBZUEsQ0FBQ3hkLENBQWM7QUFDNUMsWUFBUUEsQ0FBQztNQUNQLEtBQUswTixXQUFXLENBQUNzUCxNQUFNO1FBQ3JCLE9BQU85RSxNQUFNLENBQUM2RSxNQUFNO01BQ3RCLEtBQUtyUCxXQUFXLENBQUN3UCxVQUFVO1FBQ3pCLE9BQU9oRixNQUFNLENBQUMrRSxVQUFVO01BQzFCLEtBQUt2UCxXQUFXLENBQUMwUCxZQUFZO1FBQzNCLE9BQU9sRixNQUFNLENBQUNpRixXQUFXO01BQzNCLEtBQUt6UCxXQUFXLENBQUM0UCxrQkFBa0I7UUFDakMsT0FBT3BGLE1BQU0sQ0FBQ21GLGdCQUFnQjtBQUNoQztRQUNFLE9BQU9uRixNQUFNLENBQUNDLE9BQU87QUFDekI7QUFDRjtFQWJnQnBCLEtBQUEsQ0FBQXlHLGVBQWUsa0JBYTlCO0FBRUQ7RUFDQSxTQUFnQkMsb0JBQW9CQSxDQUFDemQsQ0FBbUI7QUFDdEQsWUFBUUEsQ0FBQztNQUNQLEtBQUswZCxXQUFnQixDQUFDQyxNQUFNO1FBQzFCLE9BQU9oUSxhQUFXLENBQUMwSixNQUFNO01BQzNCLEtBQUtxRyxXQUFnQixDQUFDRSxNQUFNO1FBQzFCLE9BQU9qUSxhQUFXLENBQUNrUSxNQUFNO0FBQzNCO1FBQ0UsT0FBT2xRLGFBQVcsQ0FBQ3dLLE9BQU87QUFDOUI7QUFDRjtFQVRnQnBCLEtBQUEsQ0FBQTBHLG9CQUFvQix1QkFTbkM7QUFDSCxDQUFDLEVBOUZnQjFHLEtBQUssS0FBTEEsS0FBSyxHQThGckI7O0FDbFNLLFNBQVVzQixzQkFBc0JBLENBQUNxRCxLQUErQjtFQUNwRSxJQUFJQSxLQUFLLFlBQVkzRSxLQUFLLEVBQUU7SUFDMUIsT0FBTztNQUNMK0csT0FBTyxFQUFFcEMsS0FBSyxDQUFDcUMsR0FBRztNQUNsQjdULE1BQU0sRUFBRXdSLEtBQUssQ0FBQ3hSLE1BQU07TUFDcEIrUCxLQUFLLEVBQUV5QixLQUFLLENBQUN2RSxPQUFPO0FBQ3BCMkQsTUFBQUEsT0FBTyxFQUFFWSxLQUFLLENBQUNuRCxnQkFBZ0IsQ0FBQ3VDLE9BQU87TUFDdkMzWixJQUFJLEVBQUV1YSxLQUFLLENBQUN2YSxJQUFJO01BQ2hCNmMsUUFBUSxFQUFFdEMsS0FBSyxDQUFDbEQsYUFBYTtBQUM3QnlGLE1BQUFBLGFBQWEsRUFBRXZDLEtBQUssQ0FBQ25ELGdCQUFnQixDQUFDM0osRUFBQUE7S0FDdkM7QUFDSCxHQUFDLE1BQU07SUFDTCxPQUFPO01BQ0xrUCxPQUFPLEVBQUVwQyxLQUFLLENBQUN3QyxRQUFRO01BQ3ZCcEQsT0FBTyxFQUFFWSxLQUFLLENBQUN5QyxTQUFTO01BQ3hCbEUsS0FBSyxFQUFFeUIsS0FBSyxDQUFDdkUsT0FBTztBQUNwQmlILE1BQUFBLFNBQVMsRUFBQTl0QixNQUFBLENBQUE2QyxNQUFBO1FBQ1BrckIsUUFBUSxFQUFFM0MsS0FBSyxDQUFDMkMsUUFBUTtRQUN4QnJ4QixJQUFJLEVBQUUwdUIsS0FBSyxDQUFDNEMsU0FBUztRQUNyQkMsU0FBUyxFQUFFN0MsS0FBSyxDQUFDOEMsV0FBVztRQUM1QnJkLElBQUksRUFBRXVhLEtBQUssQ0FBQ3ZhLElBQUk7UUFDaEIrSSxNQUFNLEVBQUV3UixLQUFLLENBQUN4UixNQUFBQTtTQUNWd1IsS0FBSyxDQUFDQSxLQUFLLEdBQUdyRCxzQkFBc0IsQ0FBQ3FELEtBQUssQ0FBQ0EsS0FBSyxDQUFDLEdBQUcsRUFBRztLQUU5RDtBQUNIO0FBQ0Y7O1NDeEhnQmEsU0FBU0EsR0FBQTs7RUFDdkIsT0FBTyxPQUFBek8sVUFBVSxFQUFFLDBDQUFFOWdCLElBQUksTUFBSyxTQUFTO0FBQ3pDO1NBTWdCbXZCLFFBQVFBLEdBQUE7O0VBQ3RCLE9BQU8sT0FBQXJPLFVBQVUsRUFBRSwwQ0FBRTlnQixJQUFJLE1BQUssUUFBUTtBQUN4QztTQXdDZ0J5dUIsS0FBS0EsR0FBQTtFQUNuQixPQUFPLE9BQU9wdEIsUUFBUSxLQUFLLFdBQVc7QUFDeEM7QUE0UkE7O0FBRUc7TUFDVW93QixLQUFLO0FBS2hCNW9CLEVBQUFBLFdBQUFBLEdBQUE7QUFDRSxRQUFJLENBQUM2b0IsUUFBUSxHQUFHN0ksT0FBTyxDQUFDQyxPQUFPLEVBQUU7SUFDakMsSUFBSSxDQUFDNkksTUFBTSxHQUFHLENBQUM7QUFDakI7QUFFQUMsRUFBQUEsUUFBUUEsR0FBQTtBQUNOLFdBQU8sSUFBSSxDQUFDRCxNQUFNLEdBQUcsQ0FBQztBQUN4QjtBQUVBRSxFQUFBQSxJQUFJQSxHQUFBO0lBQ0YsSUFBSSxDQUFDRixNQUFNLElBQUksQ0FBQztBQUVoQixRQUFJRyxVQUFzQjtJQUUxQixNQUFNQyxRQUFRLEdBQUcsSUFBSWxKLE9BQU8sQ0FDekJDLE9BQU8sSUFDTGdKLFVBQVUsR0FBR0EsTUFBSztNQUNqQixJQUFJLENBQUNILE1BQU0sSUFBSSxDQUFDO0FBQ2hCN0ksTUFBQUEsT0FBTyxFQUFFO0FBQ1gsS0FBRSxDQUNMO0lBRUQsTUFBTWtKLFVBQVUsR0FBRyxJQUFJLENBQUNOLFFBQVEsQ0FBQy9FLElBQUksQ0FBQyxNQUFNbUYsVUFBVSxDQUFDO0lBRXZELElBQUksQ0FBQ0osUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUSxDQUFDL0UsSUFBSSxDQUFDLE1BQU1vRixRQUFRLENBQUM7QUFFbEQsV0FBT0MsVUFBVTtBQUNuQjtBQUNEOztBQ3hlRCxJQUFLQyxlQUlKO0FBSkQsV0FBS0EsZUFBZTtFQUNsQkEsZUFBQSxDQUFBQSxlQUFBLDRCQUFTO0VBQ1RBLGVBQUEsQ0FBQUEsZUFBQSw0QkFBUztFQUNUQSxlQUFBLENBQUFBLGVBQUEsZ0NBQVc7QUFDYixDQUFDLEVBSklBLGVBQWUsS0FBZkEsZUFBZSxHQUluQjtNQVNZQyxVQUFVO0FBT3JCcnBCLEVBQUFBLFdBQUFBLEdBQUE7QUFDRSxRQUFJLENBQUNzcEIsWUFBWSxHQUFHLElBQUloYSxHQUFHLEVBQUU7QUFDN0IsUUFBSSxDQUFDaWEsU0FBUyxHQUFHLElBQUlYLEtBQUssRUFBRTtJQUM1QixJQUFJLENBQUNZLGFBQWEsR0FBRyxDQUFDO0FBQ3hCO0VBRU1DLEdBQUdBLENBQUlDLElBQWtCOztBQUM3QixZQUFNQyxRQUFRLEdBQWtCO0FBQzlCNVEsUUFBQUEsRUFBRSxFQUFFLElBQUksQ0FBQ3lRLGFBQWEsRUFBRTtBQUN4QkksUUFBQUEsVUFBVSxFQUFFQyxJQUFJLENBQUNDLEdBQUcsRUFBRTtRQUN0QkMsTUFBTSxFQUFFWCxlQUFlLENBQUNZLE9BQUFBO09BQ3pCO01BQ0QsSUFBSSxDQUFDVixZQUFZLENBQUNyaUIsR0FBRyxDQUFDMGlCLFFBQVEsQ0FBQzVRLEVBQUUsRUFBRTRRLFFBQVEsQ0FBQztNQUM1QyxNQUFNTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUNWLFNBQVMsQ0FBQ1AsSUFBSSxFQUFFO01BQzFDLElBQUk7QUFDRlcsUUFBQUEsUUFBUSxDQUFDTyxVQUFVLEdBQUdMLElBQUksQ0FBQ0MsR0FBRyxFQUFFO0FBQ2hDSCxRQUFBQSxRQUFRLENBQUNJLE1BQU0sR0FBR1gsZUFBZSxDQUFDZSxPQUFPO1FBQ3pDLE9BQU8sTUFBTVQsSUFBSSxFQUFFO0FBQ3JCLE9BQUMsU0FBUztBQUNSQyxRQUFBQSxRQUFRLENBQUNJLE1BQU0sR0FBR1gsZUFBZSxDQUFDZ0IsU0FBUztRQUMzQyxJQUFJLENBQUNkLFlBQVksQ0FBQ2UsTUFBTSxDQUFDVixRQUFRLENBQUM1USxFQUFFLENBQUM7QUFDckNrUixRQUFBQSxNQUFNLEVBQUU7QUFDVjtBQUNGLEtBQUM7QUFBQTtBQUVLSyxFQUFBQSxLQUFLQSxHQUFBOztBQUNULGFBQU8sSUFBSSxDQUFDYixHQUFHLENBQUMsTUFBYWMsU0FBQSxzQ0FBQyxFQUFDO0FBQ2pDLEtBQUM7QUFBQTtBQUVEQyxFQUFBQSxRQUFRQSxHQUFBO0lBQ04sT0FBT3RiLEtBQUssQ0FBQ3ViLElBQUksQ0FBQyxJQUFJLENBQUNuQixZQUFZLENBQUM1dUIsTUFBTSxFQUFFLENBQUM7QUFDL0M7QUFDRDs7QUN0RE0sTUFBTWd3QixvQkFBb0IsR0FBRyxTQUFTO0FBRTdDO0FBQ08sTUFBTUMsNEJBQTRCLEdBQUcsRUFBRTtBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU1DLGlCQUFpQixHQUFHO0FBQy9CNVosRUFBQUEsR0FBRyxFQUFFLEVBQUU7QUFDUDZaLEVBQUFBLEtBQUssRUFBRSxDQUFDO0FBQ1JDLEVBQUFBLEtBQUssRUFBRSxDQUFDO0FBQUU7QUFDVkMsRUFBQUEsS0FBSyxFQUFFO0NBQ0M7QUFFVjtBQUNnRztBQUN6RixNQUFNQyxTQUFTLEdBQUcsRUFBRTtBQUtwQixNQUFNQyxJQUFJLEdBQUcsc0JBQXNCO0FBRW5DLE1BQU1DLHFCQUFxQixHQUF1QjtBQUN2REMsRUFBQUEsU0FBUyxFQUFFLEtBQUs7QUFDaEJDLEVBQUFBLFdBQVcsRUFBRUgsSUFBSTtBQUNqQkksRUFBQUEsaUJBQWlCLEVBQUUsQ0FBQztBQUNwQkMsRUFBQUEsZ0JBQWdCLEVBQUVYLDRCQUE0QjtBQUM5Q1ksRUFBQUEsV0FBVyxFQUFFO0NBQ0w7QUFFSCxNQUFNQyxhQUFhLEdBQUcsR0FBRztBQUN6QixNQUFNQyxnQkFBZ0IsR0FBRyxJQUFJOztBQ3hDOUIsTUFBT0MsWUFBYSxTQUFRendCLEtBQUs7QUFHckMrRSxFQUFBQSxXQUFZQSxDQUFBMnJCLElBQVksRUFBRTNzQixPQUFnQjtBQUN4QyxTQUFLLENBQUNBLE9BQU8sSUFBSSxzQkFBc0IsQ0FBQztJQUN4QyxJQUFJLENBQUMyc0IsSUFBSSxHQUFHQSxJQUFJO0FBQ2xCO0FBQ0Q7QUFFRCxJQUFrQkMscUJBTWpCO0FBTkQsV0FBa0JBLHFCQUFxQjtFQUNyQ0EscUJBQUEsQ0FBQUEscUJBQUEsa0NBQVU7RUFDVkEscUJBQUEsQ0FBQUEscUJBQUEsZ0RBQWlCO0VBQ2pCQSxxQkFBQSxDQUFBQSxxQkFBQSx3Q0FBYTtFQUNiQSxxQkFBQSxDQUFBQSxxQkFBQSxnQ0FBUztFQUNUQSxxQkFBQSxDQUFBQSxxQkFBQSxzQ0FBWTtBQUNkLENBQUMsRUFOaUJBLHFCQUFxQixLQUFyQkEscUJBQXFCLEdBTXRDO0FBK0RELElBQVlDLGtCQVFYO0FBUkQsV0FBWUEsa0JBQWtCO0FBQzVCO0FBQ0FBLEVBQUFBLGtCQUFBLHlDQUFxQztBQUNyQztBQUNBQSxFQUFBQSxrQkFBQSx5QkFBcUI7QUFDckI7QUFDQUEsRUFBQUEsa0JBQUEsK0JBQTJCO0FBQzNCQSxFQUFBQSxrQkFBQSxtQkFBZTtBQUNqQixDQUFDLEVBUldBLGtCQUFrQixLQUFsQkEsa0JBQWtCLEdBUTdCO0FBRUQsV0FBaUJBLGtCQUFrQjtFQUNqQyxTQUFnQkMsVUFBVUEsQ0FBQ3ZPLEtBQVU7QUFDbkMsUUFBSUEsS0FBSyxJQUFJLE1BQU0sSUFBSUEsS0FBSyxFQUFFO01BQzVCLElBQUlBLEtBQUssQ0FBQ3BtQixJQUFJLEtBQUssZUFBZSxJQUFJb21CLEtBQUssQ0FBQ3BtQixJQUFJLEtBQUssc0JBQXNCLEVBQUU7UUFDM0UsT0FBTzAwQixrQkFBa0IsQ0FBQ0UsUUFBUTtBQUNwQztNQUNBLElBQUl4TyxLQUFLLENBQUNwbUIsSUFBSSxLQUFLLGlCQUFpQixJQUFJb21CLEtBQUssQ0FBQ3BtQixJQUFJLEtBQUssdUJBQXVCLEVBQUU7UUFDOUUsT0FBTzAwQixrQkFBa0IsQ0FBQ0csZ0JBQWdCO0FBQzVDO01BQ0EsSUFBSXpPLEtBQUssQ0FBQ3BtQixJQUFJLEtBQUssa0JBQWtCLElBQUlvbUIsS0FBSyxDQUFDcG1CLElBQUksS0FBSyxpQkFBaUIsRUFBRTtRQUN6RSxPQUFPMDBCLGtCQUFrQixDQUFDSSxXQUFXO0FBQ3ZDO01BQ0EsT0FBT0osa0JBQWtCLENBQUNLLEtBQUs7QUFDakM7QUFDRjtFQWJnQkwsa0JBQUEsQ0FBQUMsVUFBVSxhQWF6QjtBQUNILENBQUMsRUFmZ0JELGtCQUFrQixLQUFsQkEsa0JBQWtCLEdBZWxDOztBQ3ZHRCxJQUFZTSxrQkFJWDtBQUpELFdBQVlBLGtCQUFrQjtFQUM1QkEsa0JBQUEsQ0FBQUEsa0JBQUEsa0NBQWM7RUFDZEEsa0JBQUEsQ0FBQUEsa0JBQUEsa0NBQWM7RUFDZEEsa0JBQUEsQ0FBQUEsa0JBQUEsd0NBQWlCO0FBQ25CLENBQUMsRUFKV0Esa0JBQWtCLEtBQWxCQSxrQkFBa0IsR0FJN0I7QUFFSyxNQUFPQyxZQUFhLFNBQVFWLFlBQVk7RUFLNUMxckIsV0FBQUEsQ0FDRWhCLE9BQWdCLEVBRVk7QUFBQSxRQUQ1QnF0QixNQUFBLEdBQUE5MUIsU0FBQSxDQUFBVSxNQUFBLEdBQUFWLENBQUFBLElBQUFBLFNBQUEsQ0FBQUssQ0FBQUEsQ0FBQUEsS0FBQUEsU0FBQSxHQUFBTCxTQUFBLENBQTZCNDFCLENBQUFBLENBQUFBLEdBQUFBLGtCQUFrQixDQUFDRyxhQUFhO0lBQUEsSUFDN0RDLG1CQUE0QixHQUFBaDJCLFNBQUEsQ0FBQVUsTUFBQSxHQUFBVixDQUFBQSxHQUFBQSxTQUFBLE1BQUFLLFNBQUE7QUFFNUIsU0FBSyxDQUFDLEVBQUUsRUFBRW9JLE9BQU8sQ0FBQztJQUNsQixJQUFJLENBQUNxdEIsTUFBTSxHQUFHQSxNQUFNO0lBQ3BCLElBQUksQ0FBQ0UsbUJBQW1CLEdBQUdBLG1CQUFtQjtBQUNoRDtBQUNEOztBQ2xCRCxJQUFZQyxnQkFJWDtBQUpELFdBQVlBLGdCQUFnQjtBQUMxQkEsRUFBQUEsZ0JBQUEscUJBQWlCO0FBQ2pCQSxFQUFBQSxnQkFBQSxxQ0FBaUM7QUFDakNBLEVBQUFBLGdCQUFBLGlDQUE2QjtBQUMvQixDQUFDLEVBSldBLGdCQUFnQixLQUFoQkEsZ0JBQWdCLEdBSTNCO0FBUUQsSUFBWUMsZUFFWDtBQUZELFdBQVlBLGVBQWU7QUFDekJBLEVBQUFBLGVBQUEsaUNBQTZCO0FBQy9CLENBQUMsRUFGV0EsZUFBZSxLQUFmQSxlQUFlLEdBRTFCO0FBVUQsSUFBWUMsZUFHWDtBQUhELFdBQVlBLGVBQWU7QUFDekJBLEVBQUFBLGVBQUEsNkVBQXlFO0FBQ3pFQSxFQUFBQSxlQUFBLHVDQUFtQztBQUNyQyxDQUFDLEVBSFdBLGVBQWUsS0FBZkEsZUFBZSxHQUcxQjtBQWNELElBQVlDLFlBRVg7QUFGRCxXQUFZQSxZQUFZO0FBQ3RCQSxFQUFBQSxZQUFBLDBCQUFzQjtBQUN4QixDQUFDLEVBRldBLFlBQVksS0FBWkEsWUFBWSxHQUV2Qjs7QUM1QkssU0FBVUMsWUFBWUEsQ0FDMUJDLEtBQWtEO0VBRWxELE9BQU8sTUFBTSxJQUFJQSxLQUFLO0FBQ3hCO1NBRXNCQyxTQUFTQSxDQUFBQyxVQUFBO3NEQUM3QkMsUUFBa0M7SUFBQSxJQUNsQ0MsMkVBQXVDO0FBQUU5MUIsTUFBQUEsSUFBSSxFQUFFdXpCLG9CQUFBQTtLQUFzQjtBQUFBLFFBQ3JFd0MsS0FBQSxHQUFBMzJCLFNBQUEsQ0FBQVUsTUFBQSxRQUFBVixTQUFBLFFBQUFLLFNBQUEsR0FBQUwsU0FBQSxNQUE4QixTQUFTO0lBQUE7QUFFdkM7QUFDQSxhQUFPNDJCLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDTixTQUFTLENBQzVCLEtBQUssRUFDTEUsUUFBUSxFQUNSQyxTQUFTLEVBQ1QsS0FBSyxFQUNMQyxLQUFLLEtBQUssUUFBUSxHQUFHLENBQUMsWUFBWSxFQUFFLFdBQVcsQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUMxRTtLQUNGO0dBQUE7QUFBQTtBQTJCRCxTQUFTRyxjQUFjQSxDQUFDQyxhQUFxQixFQUFFQyxJQUFZO0FBQ3pELFFBQU01bUIsV0FBVyxHQUFHLElBQUlFLFdBQVcsRUFBRTtBQUNyQyxRQUFNMm1CLFdBQVcsR0FBRzdtQixXQUFXLENBQUNtQixNQUFNLENBQUN5bEIsSUFBSSxDQUFDO0FBQzVDLFVBQVFELGFBQWE7QUFDbkIsU0FBSyxNQUFNO01BQ1QsT0FBTztBQUNMbjJCLFFBQUFBLElBQUksRUFBRSxNQUFNO0FBQ1pvMkIsUUFBQUEsSUFBSSxFQUFFQyxXQUFXO0FBQ2pCQyxRQUFBQSxJQUFJLEVBQUUsU0FBUztBQUNmN3lCLFFBQUFBLElBQUksRUFBRSxJQUFJa0osV0FBVyxDQUFDLEdBQUc7T0FDMUI7QUFDSCxTQUFLLFFBQVE7QUFBRTtRQUNiLE9BQU87QUFDTDNNLFVBQUFBLElBQUksRUFBRSxRQUFRO0FBQ2RvMkIsVUFBQUEsSUFBSSxFQUFFQyxXQUFXO0FBQ2pCQyxVQUFBQSxJQUFJLEVBQUUsU0FBUztBQUNmQyxVQUFBQSxVQUFVLEVBQUU7U0FDYjtBQUNIO0FBQ0E7QUFDRSxZQUFNLElBQUl6eUIsS0FBSyxjQUFBOEQsTUFBQSxDQUFjdXVCLGFBQWEsOEJBQTJCLENBQUM7QUFDMUU7QUFDRjtBQUVBOzs7QUFHRztBQUNtQixTQUFBSyxVQUFVQSxDQUFDQyxRQUFtQixFQUFFTCxJQUFZOztJQUNoRSxNQUFNTSxnQkFBZ0IsR0FBR1IsY0FBYyxDQUFDTyxRQUFRLENBQUNYLFNBQVMsQ0FBQzkxQixJQUFJLEVBQUVvMkIsSUFBSSxDQUFDO0FBRXRFO0FBQ0E7QUFDQSxVQUFNTyxhQUFhLEdBQUcsTUFBTVgsTUFBTSxDQUFDQyxNQUFNLENBQUNXLFNBQVMsQ0FDakRGLGdCQUFnQixFQUNoQkQsUUFBUSxFQUNSO0FBQ0V6MkIsTUFBQUEsSUFBSSxFQUFFdXpCLG9CQUFvQjtBQUMxQnp6QixNQUFBQSxNQUFNLEVBQUU7S0FDVCxFQUNELEtBQUssRUFDTCxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FDdkI7SUFFRCxPQUFPO01BQUUyMkIsUUFBUTtBQUFFRSxNQUFBQSxhQUFBQTtLQUFlO0FBQ3BDLEdBQUM7QUFBQTtBQU1EOzs7QUFHRztBQUNtQixTQUFBRSxPQUFPQSxDQUFDSixRQUFtQixFQUFFTCxJQUFZOztJQUM3RCxNQUFNTSxnQkFBZ0IsR0FBR1IsY0FBYyxDQUFDTyxRQUFRLENBQUNYLFNBQVMsQ0FBQzkxQixJQUFJLEVBQUVvMkIsSUFBSSxDQUFDO0FBRXRFO0lBQ0EsT0FBT0osTUFBTSxDQUFDQyxNQUFNLENBQUNhLFVBQVUsQ0FBQ0osZ0JBQWdCLEVBQUVELFFBQVEsRUFBRSxHQUFHLENBQUM7QUFDbEUsR0FBQztBQUFBO0FBRUssU0FBVU0sbUJBQW1CQSxDQUFDQyxTQUFxQjtBQUN2RCxPQUFLLElBQUluM0IsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHbTNCLFNBQVMsQ0FBQ2wzQixNQUFNLEdBQUcsQ0FBQyxFQUFFRCxDQUFDLEVBQUUsRUFBRTtJQUM3QyxJQUFJbTNCLFNBQVMsQ0FBQ24zQixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUltM0IsU0FBUyxDQUFDbjNCLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUltM0IsU0FBUyxDQUFDbjNCLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsT0FBTyxJQUFJO0FBQ3RGO0FBQ0EsU0FBTyxLQUFLO0FBQ2Q7QUFFTSxTQUFVbzNCLFNBQVNBLENBQUNDLE1BQWtCO0VBQzFDLE1BQU1DLE9BQU8sR0FBYSxFQUFFO0FBQzVCLE1BQUlyM0IsTUFBTSxHQUFHbzNCLE1BQU0sQ0FBQ3AzQixNQUFNO0VBQzFCLEtBQUssSUFBSUQsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHcTNCLE1BQU0sQ0FBQ3AzQixNQUFNLEdBQUk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJQSxNQUFNLEdBQUdELENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQ3EzQixNQUFNLENBQUNyM0IsQ0FBQyxDQUFDLElBQUksQ0FBQ3EzQixNQUFNLENBQUNyM0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJcTNCLE1BQU0sQ0FBQ3IzQixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ3pFO01BQ0FzM0IsT0FBTyxDQUFDcHhCLElBQUksQ0FBQ214QixNQUFNLENBQUNyM0IsQ0FBQyxFQUFFLENBQUMsQ0FBQztNQUN6QnMzQixPQUFPLENBQUNweEIsSUFBSSxDQUFDbXhCLE1BQU0sQ0FBQ3IzQixDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3pCO0FBQ0FBLE1BQUFBLENBQUMsRUFBRTtBQUNMLEtBQUMsTUFBTTtBQUNMO01BQ0FzM0IsT0FBTyxDQUFDcHhCLElBQUksQ0FBQ214QixNQUFNLENBQUNyM0IsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUMzQjtBQUNGO0FBQ0EsU0FBTyxJQUFJNE8sVUFBVSxDQUFDMG9CLE9BQU8sQ0FBQztBQUNoQztBQUVBLE1BQU1DLHFCQUFxQixHQUFHLENBQUM7QUFDL0IsTUFBTUMsY0FBYyxHQUFHLENBQUM7QUFFbEIsU0FBVUMsU0FBU0EsQ0FBQ0MsT0FBbUI7RUFDM0MsTUFBTUosT0FBTyxHQUFhLEVBQUU7RUFDNUIsSUFBSUssbUJBQW1CLEdBQUcsQ0FBQztBQUMzQixPQUFLLElBQUkzM0IsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHMDNCLE9BQU8sQ0FBQ3ozQixNQUFNLEVBQUUsRUFBRUQsQ0FBQyxFQUFFO0FBQ3ZDLFFBQUl3SyxJQUFJLEdBQUdrdEIsT0FBTyxDQUFDMTNCLENBQUMsQ0FBQztBQUNyQixRQUFJd0ssSUFBSSxJQUFJZ3RCLGNBQWMsSUFBSUcsbUJBQW1CLElBQUlKLHFCQUFxQixFQUFFO0FBQzFFO0FBQ0FELE1BQUFBLE9BQU8sQ0FBQ3B4QixJQUFJLENBQUNzeEIsY0FBYyxDQUFDO0FBQzVCRyxNQUFBQSxtQkFBbUIsR0FBRyxDQUFDO0FBQ3pCO0FBQ0FMLElBQUFBLE9BQU8sQ0FBQ3B4QixJQUFJLENBQUNzRSxJQUFJLENBQUM7SUFDbEIsSUFBSUEsSUFBSSxJQUFJLENBQUMsRUFBRTtBQUNiLFFBQUVtdEIsbUJBQW1CO0FBQ3ZCLEtBQUMsTUFBTTtBQUNMQSxNQUFBQSxtQkFBbUIsR0FBRyxDQUFDO0FBQ3pCO0FBQ0Y7QUFDQSxTQUFPLElBQUkvb0IsVUFBVSxDQUFDMG9CLE9BQU8sQ0FBQztBQUNoQzs7TUMvS2FNLFFBQVE7QUFBckI1dUIsRUFBQUEsV0FBQUEsR0FBQTtJQUNVLElBQW1CLENBQUE2dUIsbUJBQUEsR0FBRyxDQUFDO0lBSXZCLElBQWlCLENBQUFDLGlCQUFBLEdBQVcsQ0FBQztJQUU3QixJQUFrQixDQUFBQyxrQkFBQSxHQUFXLENBQUM7QUFxQ3hDO0FBbkNFQyxFQUFBQSxTQUFTQSxHQUFBOztJQUNQLElBQUksQ0FBQ0gsbUJBQW1CLElBQUksQ0FBQztJQUM3QixDQUFBbnZCLEVBQUEsT0FBSSxDQUFDdXZCLG9CQUFvQixjQUFBdnZCLEVBQUEsY0FBQUEsRUFBQSxHQUF6QixJQUFJLENBQUN1dkIsb0JBQW9CLEdBQUtwRixJQUFJLENBQUNDLEdBQUcsRUFBRztBQUN6QyxRQUFJLENBQUNnRixpQkFBaUIsR0FBR2pGLElBQUksQ0FBQ0MsR0FBRyxFQUFFO0FBQ3JDO0FBRUFvRixFQUFBQSxlQUFlQSxHQUFBO0FBQ2IsUUFBSSxJQUFJLENBQUNELG9CQUFvQixLQUFLcjRCLFNBQVMsRUFBRTtBQUMzQztBQUNGLEtBQUMsTUFBTTtNQUNMLElBQUksQ0FBQ200QixrQkFBa0IsSUFBSSxDQUFDO0FBQzlCO0FBQ0E7QUFDRTtBQUNBLFFBQUksQ0FBQ0Esa0JBQWtCLEdBQUcsSUFBSSxDQUFDRixtQkFBbUI7QUFDbEQ7SUFDQWhGLElBQUksQ0FBQ0MsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDZ0YsaUJBQWlCLEdBQUdyRCxnQkFBZ0IsRUFDdEQ7TUFDQSxJQUFJLENBQUMwRCxLQUFLLEVBQUU7QUFDZDtBQUNGO0FBRUFDLEVBQUFBLFlBQVlBLEdBQUE7SUFDVixPQUNFLElBQUksQ0FBQ1AsbUJBQW1CLEdBQUdyRCxhQUFhLEtBQ3ZDLElBQUksQ0FBQ3lELG9CQUFvQixLQUFLcjRCLFNBQVMsSUFDdENpekIsSUFBSSxDQUFDQyxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUNtRixvQkFBb0IsR0FBR3hELGdCQUFnQixDQUFDO0FBRWhFO0FBRUEwRCxFQUFBQSxLQUFLQSxHQUFBO0lBQ0gsSUFBSSxDQUFDSixrQkFBa0IsR0FBRyxDQUFDO0lBQzNCLElBQUksQ0FBQ0YsbUJBQW1CLEdBQUcsQ0FBQztJQUM1QixJQUFJLENBQUNJLG9CQUFvQixHQUFHcjRCLFNBQVM7QUFDdkM7QUFDRDs7QUNoQ00sTUFBTXk0QixvQkFBb0IsR0FBeUIsSUFBSS9mLEdBQUcsRUFBRTtBQWE3RCxNQUFPZ2dCLGdCQUFpQixTQUFTbFQsMEJBQThEO0FBQ3pGbVQsRUFBQUEsY0FBY0EsQ0FDdEJDLFlBQXlELEVBQ3pEQyxVQUE0QztJQUU1QyxNQUFNeDBCLEtBQUssQ0FBQyw4QkFBOEIsQ0FBQztBQUM3QztBQUVVeTBCLEVBQUFBLGNBQWNBLENBQ3RCRixZQUF5RCxFQUN6REMsVUFBNEM7SUFFNUMsTUFBTXgwQixLQUFLLENBQUMsOEJBQThCLENBQUM7QUFDN0M7QUFDRDtBQUVEOzs7QUFHRztBQUNHLE1BQU8wMEIsWUFBYSxTQUFRTCxnQkFBZ0I7RUF3QmhEdHZCLFdBQUFBLENBQVk0dkIsSUFLWDs7QUFDQyxTQUFLLEVBQUU7QUFDUCxRQUFJLENBQUNDLFVBQVUsR0FBRyxJQUFJdmdCLEdBQUcsRUFBRTtBQUMzQixRQUFJLENBQUN2QixJQUFJLEdBQUc2aEIsSUFBSSxDQUFDN2hCLElBQUk7QUFDckIsUUFBSSxDQUFDd2UsbUJBQW1CLEdBQUdxRCxJQUFJLENBQUNyRCxtQkFBbUI7QUFDbkQsUUFBSSxDQUFDdUQsTUFBTSxHQUFHLElBQUl4Z0IsR0FBRyxFQUFFO0FBQ3ZCLFFBQUksQ0FBQ3lnQixrQkFBa0IsR0FBR0gsSUFBSSxDQUFDRyxrQkFBa0I7SUFDakQsSUFBSSxDQUFDQyxVQUFVLEdBQUcsQ0FBQXR3QixFQUFBLEdBQUFrd0IsSUFBSSxDQUFDSSxVQUFVLE1BQUksUUFBQXR3QixFQUFBLGNBQUFBLEVBQUEsR0FBQWtHLFVBQVUsQ0FBQzZrQixJQUFJLENBQUMsRUFBRSxDQUFDO0FBQ3hELFFBQUksQ0FBQ3dGLFFBQVEsR0FBRyxJQUFJckIsUUFBUSxFQUFFO0FBQ2hDO0VBRUEsSUFBWXJNLFVBQVVBLEdBQUE7SUFDcEIsT0FBTztNQUNMMk4sV0FBVyxFQUFFLElBQUksQ0FBQzNELG1CQUFtQjtNQUNyQzRELFlBQVksRUFBRSxJQUFJLENBQUNDLE9BQU87TUFDMUJDLGFBQWEsRUFBRSxJQUFJLENBQUNDLFVBQUFBO0tBQ3JCO0FBQ0g7QUFFQTs7Ozs7QUFLRztBQUNIQyxFQUFBQSxjQUFjQSxDQUFDeFgsRUFBVSxFQUFFaEwsSUFBMkI7SUFDcERsVCxZQUFZLENBQUN6RCxLQUFLLENBQUMsb0NBQW9DLEVBQ2xEcUQsTUFBQSxDQUFBNkMsTUFBQSxDQUFBN0MsTUFBQSxDQUFBNkMsTUFBQSxTQUFJLENBQUNpbEIsVUFBVSxDQUNsQjtBQUFBMk4sTUFBQUEsV0FBVyxFQUFFblgsRUFBQUE7T0FDYjtJQUNGLElBQUksSUFBSSxDQUFDd1QsbUJBQW1CLEVBQUU7QUFDNUIxeEIsTUFBQUEsWUFBWSxDQUFDMGlCLEtBQUssQ0FDaEIsa0ZBQWtGLG9CQUU3RSxJQUFJLENBQUNnRixVQUFVLEVBRXJCO0FBQ0g7SUFDQSxJQUFJLENBQUNnSyxtQkFBbUIsR0FBR3hULEVBQUU7SUFDN0IsSUFBSSxDQUFDaEwsSUFBSSxHQUFHQSxJQUFJO0FBQ2hCLFFBQUksQ0FBQ2tpQixRQUFRLENBQUNkLEtBQUssRUFBRTtBQUN2QjtBQUVBcUIsRUFBQUEsZ0JBQWdCQSxHQUFBO0lBQ2QzMUIsWUFBWSxDQUFDekQsS0FBSyxDQUFDLHVCQUF1QixFQUFFLElBQUksQ0FBQ21yQixVQUFVLENBQUM7SUFDNUQsSUFBSSxDQUFDZ0ssbUJBQW1CLEdBQUczMUIsU0FBUztBQUN0QztBQUVBMHhCLEVBQUFBLFNBQVNBLEdBQUE7SUFDUCxJQUFJLElBQUksQ0FBQ2lFLG1CQUFtQixFQUFFO0FBQzVCLGFBQU84QyxvQkFBb0IsQ0FBQ3hpQixHQUFHLENBQUMsSUFBSSxDQUFDMGYsbUJBQW1CLENBQUM7QUFDM0QsS0FBQyxNQUFNO0FBQ0wsYUFBTzMxQixTQUFTO0FBQ2xCO0FBQ0Y7QUFFQTY1QixFQUFBQSxzQkFBc0JBLEdBQUE7SUFDcEIsT0FBTyxJQUFJLENBQUNsRSxtQkFBbUI7QUFDakM7QUFFQW1FLEVBQUFBLFVBQVVBLEdBQUE7SUFDUixPQUFPLElBQUksQ0FBQ04sT0FBTztBQUNyQjtBQUVBOzs7QUFHRztFQUNITyxhQUFhQSxDQUFDQyxLQUFpQjtJQUM3QixJQUFJLENBQUNOLFVBQVUsR0FBR00sS0FBSztBQUN6QjtBQUVBOzs7QUFHRztFQUNIQyxTQUFTQSxDQUFDbDJCLEdBQTRCO0lBQ3BDLElBQUksQ0FBQ20xQixNQUFNLEdBQUduMUIsR0FBRztBQUNuQjtFQUVBbTJCLGNBQWNBLENBQ1pDLFNBQThCLEVBQzlCQyxRQUFxRSxFQUNyRUMsUUFBcUUsRUFDckViLE9BQWUsRUFDZlEsS0FBa0I7QUFFbEIsUUFBSUEsS0FBSyxFQUFFO0FBQ1QvMUIsTUFBQUEsWUFBWSxDQUFDRCxJQUFJLENBQUMsNkJBQTZCLEVBQUU7QUFBRWcyQixRQUFBQSxLQUFBQTtBQUFPLFFBQUM7TUFDM0QsSUFBSSxDQUFDTixVQUFVLEdBQUdNLEtBQUs7QUFDekI7SUFFQS8xQixZQUFZLENBQUN6RCxLQUFLLENBQUMsb0NBQW9DLEVBQUFxRCxNQUFBLENBQUE2QyxNQUFBO01BQ3JEeXpCLFNBQVM7QUFDVEcsTUFBQUEsYUFBYSxFQUFFZCxPQUFPO0FBQ3RCUSxNQUFBQSxLQUFBQTtBQUFLLE9BQ0YsSUFBSSxDQUFDck8sVUFBVSxFQUNsQjtBQUVGLFVBQU00TyxXQUFXLEdBQUdKLFNBQVMsS0FBSyxRQUFRLEdBQUcsSUFBSSxDQUFDeEIsY0FBYyxHQUFHLElBQUksQ0FBQ0csY0FBYztBQUN0RixVQUFNMEIsZUFBZSxHQUFHLElBQUlDLGVBQWUsQ0FBQztBQUMxQ0MsTUFBQUEsU0FBUyxFQUFFSCxXQUFXLENBQUNsN0IsSUFBSSxDQUFDLElBQUk7QUFDakMsTUFBQztBQUVGKzZCLElBQUFBLFFBQVEsQ0FDTE8sV0FBVyxDQUFDSCxlQUFlLENBQUMsQ0FDNUJJLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDLENBQ2hCaE4sS0FBSyxDQUFFNXRCLENBQUMsSUFBSTtBQUNYd0UsTUFBQUEsWUFBWSxDQUFDcWhCLElBQUksQ0FBQzdsQixDQUFDLENBQUM7TUFDcEIsSUFBSSxDQUFDK21CLElBQUksQ0FDUHVQLFlBQVksQ0FBQzF4QixLQUFLLEVBQ2xCNUUsQ0FBQyxZQUFZKzFCLFlBQVksR0FDckIvMUIsQ0FBQyxHQUNELElBQUkrMUIsWUFBWSxDQUFDLzFCLENBQUMsQ0FBQzJJLE9BQU8sRUFBRXBJLFNBQVMsRUFBRSxJQUFJLENBQUMyMUIsbUJBQW1CLENBQUMsQ0FDckU7QUFDSCxLQUFDLENBQUM7SUFDSixJQUFJLENBQUM2RCxPQUFPLEdBQUdBLE9BQU87QUFDeEI7RUFFQXFCLGFBQWFBLENBQUNDLE9BQW1CO0lBQy9CNzJCLFlBQVksQ0FBQ3pELEtBQUssQ0FBQyxxQkFBcUIsRUFBQXFELE1BQUEsQ0FBQTZDLE1BQUEsQ0FBQTdDLE1BQUEsQ0FBQTZDLE1BQUEsS0FBTyxJQUFJLENBQUNpbEIsVUFBVTtBQUFFbVAsTUFBQUEsT0FBQUE7QUFBTyxPQUFHO0lBQzFFLElBQUksQ0FBQzFCLFVBQVUsR0FBRzBCLE9BQU87QUFDM0I7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJHO0FBQ2FuQyxFQUFBQSxjQUFjQSxDQUM1QkMsWUFBeUQsRUFDekRDLFVBQTRDOzs7QUFFNUMsVUFDRSxDQUFDLElBQUksQ0FBQ25ILFNBQVMsRUFBRTtBQUNqQjtBQUNBa0gsTUFBQUEsWUFBWSxDQUFDbnZCLElBQUksQ0FBQzlCLFVBQVUsS0FBSyxDQUFDLEVBQ2xDO0FBQ0EsZUFBT2t4QixVQUFVLENBQUNrQyxPQUFPLENBQUNuQyxZQUFZLENBQUM7QUFDekM7TUFDQSxNQUFNb0MsTUFBTSxHQUFHLElBQUksQ0FBQzdqQixJQUFJLENBQUM4akIsU0FBUyxFQUFFO01BQ3BDLElBQUksQ0FBQ0QsTUFBTSxFQUFFO0FBQ1gsWUFBSSxDQUFDeFUsSUFBSSxDQUNQdVAsWUFBWSxDQUFDMXhCLEtBQUssRUFDbEIsSUFBSW14QixZQUFZLDBCQUFBcnRCLE1BQUEsQ0FFWixJQUFJLENBQUN3dEIsbUJBQ1AsRUFBQXh0QixZQUFBQSxDQUFBQSxDQUFBQSxNQUFBLENBQWEsSUFBSSxDQUFDZ1AsSUFBSSxDQUFDK2pCLGtCQUFrQixFQUFFLEdBQzNDM0Ysa0JBQWtCLENBQUM0RixVQUFVLEVBQzdCLElBQUksQ0FBQ3hGLG1CQUFtQixDQUN6QixDQUNGO0FBQ0Q7QUFDRjtNQUNBLE1BQU07QUFBRXVCLFFBQUFBLGFBQUFBO0FBQWUsVUFBRzhELE1BQU07TUFDaEMsTUFBTUksUUFBUSxHQUFHLElBQUksQ0FBQ2prQixJQUFJLENBQUMrakIsa0JBQWtCLEVBQUU7QUFFL0MsVUFBSWhFLGFBQWEsRUFBRTtBQUNqQixjQUFNbUUsRUFBRSxHQUFHLElBQUksQ0FBQ0MsTUFBTSxDQUNwQixDQUFBeHlCLEVBQUEsR0FBQTh2QixZQUFZLENBQUMyQyxXQUFXLEVBQUUsQ0FBQ0MscUJBQXFCLG1DQUFJLENBQUMsQ0FBQyxFQUN0RDVDLFlBQVksQ0FBQzZDLFNBQVMsQ0FDdkI7QUFDRCxZQUFJQyxTQUFTLEdBQUcsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQy9DLFlBQVksQ0FBQztBQUV0RDtBQUNBLGNBQU1nRCxXQUFXLEdBQUcsSUFBSTVzQixVQUFVLENBQUM0cEIsWUFBWSxDQUFDbnZCLElBQUksRUFBRSxDQUFDLEVBQUVpeUIsU0FBUyxDQUFDRyxnQkFBZ0IsQ0FBQztBQUVwRjtBQUNBLGNBQU1DLFlBQVksR0FBRyxJQUFJOXNCLFVBQVUsQ0FBQyxDQUFDLENBQUM7QUFFdEM4c0IsUUFBQUEsWUFBWSxDQUFDLENBQUMsQ0FBQyxHQUFHMUgsU0FBUztBQUMzQjBILFFBQUFBLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBR1YsUUFBUTtBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtRQUNBLElBQUk7VUFDRixNQUFNVyxVQUFVLEdBQUcsTUFBTXhGLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDd0YsT0FBTyxDQUM1QztBQUNFejdCLFlBQUFBLElBQUksRUFBRXV6QixvQkFBb0I7WUFDMUJ1SCxFQUFFO0FBQ0ZZLFlBQUFBLGNBQWMsRUFBRSxJQUFJanRCLFVBQVUsQ0FBQzRwQixZQUFZLENBQUNudkIsSUFBSSxFQUFFLENBQUMsRUFBRW15QixXQUFXLENBQUNqMEIsVUFBVTtBQUM1RSxhQUNEdXZCLGFBQWEsRUFDYixJQUFJbG9CLFVBQVUsQ0FBQzRwQixZQUFZLENBQUNudkIsSUFBSSxFQUFFaXlCLFNBQVMsQ0FBQ0csZ0JBQWdCLENBQUMsQ0FDOUQ7QUFFRCxjQUFJSyxvQkFBb0IsR0FBRyxJQUFJbHRCLFVBQVUsQ0FDdkMrc0IsVUFBVSxDQUFDcDBCLFVBQVUsR0FBRzB6QixFQUFFLENBQUMxekIsVUFBVSxHQUFHbTBCLFlBQVksQ0FBQ24wQixVQUFVLENBQ2hFO1VBQ0R1MEIsb0JBQW9CLENBQUM3ckIsR0FBRyxDQUFDLElBQUlyQixVQUFVLENBQUMrc0IsVUFBVSxDQUFDLENBQUMsQ0FBQztBQUNyREcsVUFBQUEsb0JBQW9CLENBQUM3ckIsR0FBRyxDQUFDLElBQUlyQixVQUFVLENBQUNxc0IsRUFBRSxDQUFDLEVBQUVVLFVBQVUsQ0FBQ3AwQixVQUFVLENBQUMsQ0FBQztBQUNwRXUwQixVQUFBQSxvQkFBb0IsQ0FBQzdyQixHQUFHLENBQUN5ckIsWUFBWSxFQUFFQyxVQUFVLENBQUNwMEIsVUFBVSxHQUFHMHpCLEVBQUUsQ0FBQzF6QixVQUFVLENBQUMsQ0FBQztVQUU5RSxJQUFJK3pCLFNBQVMsQ0FBQ1MsTUFBTSxFQUFFO0FBQ3BCRCxZQUFBQSxvQkFBb0IsR0FBR3JFLFNBQVMsQ0FBQ3FFLG9CQUFvQixDQUFDO0FBQ3hEO0FBRUEsY0FBSUUsT0FBTyxHQUFHLElBQUlwdEIsVUFBVSxDQUFDNHNCLFdBQVcsQ0FBQ2owQixVQUFVLEdBQUd1MEIsb0JBQW9CLENBQUN2MEIsVUFBVSxDQUFDO0FBQ3RGeTBCLFVBQUFBLE9BQU8sQ0FBQy9yQixHQUFHLENBQUN1ckIsV0FBVyxDQUFDO1VBQ3hCUSxPQUFPLENBQUMvckIsR0FBRyxDQUFDNnJCLG9CQUFvQixFQUFFTixXQUFXLENBQUNqMEIsVUFBVSxDQUFDO0FBRXpEaXhCLFVBQUFBLFlBQVksQ0FBQ252QixJQUFJLEdBQUcyeUIsT0FBTyxDQUFDaHJCLE1BQU07QUFFbEMsaUJBQU95bkIsVUFBVSxDQUFDa0MsT0FBTyxDQUFDbkMsWUFBWSxDQUFDO1NBQ3hDLENBQUMsT0FBT241QixDQUFNLEVBQUU7QUFDZjtBQUNBd0UsVUFBQUEsWUFBWSxDQUFDMGlCLEtBQUssQ0FBQ2xuQixDQUFDLENBQUM7QUFDdkI7QUFDRixPQUFDLE1BQU07UUFDTHdFLFlBQVksQ0FBQ3pELEtBQUssQ0FBQyxtQ0FBbUMsRUFBRSxJQUFJLENBQUNtckIsVUFBVSxDQUFDO0FBQ3hFLFlBQUksQ0FBQ25GLElBQUksQ0FDUHVQLFlBQVksQ0FBQzF4QixLQUFLLEVBQ2xCLElBQUlteEIsWUFBWSxDQUVkRCxxQ0FBQUEsRUFBQUEsa0JBQWtCLENBQUM0RixVQUFVLEVBQzdCLElBQUksQ0FBQ3hGLG1CQUFtQixDQUN6QixDQUNGO0FBQ0g7QUFDRixLQUFDO0FBQUE7QUFFRDs7Ozs7QUFLRztBQUNhbUQsRUFBQUEsY0FBY0EsQ0FDNUJGLFlBQXlELEVBQ3pEQyxVQUE0Qzs7QUFFNUMsVUFDRSxDQUFDLElBQUksQ0FBQ25ILFNBQVMsRUFBRTtBQUNqQjtBQUNBa0gsTUFBQUEsWUFBWSxDQUFDbnZCLElBQUksQ0FBQzlCLFVBQVUsS0FBSyxDQUFDLEVBQ2xDO1FBQ0ExRCxZQUFZLENBQUN6RCxLQUFLLENBQUMsc0JBQXNCLEVBQUUsSUFBSSxDQUFDbXJCLFVBQVUsQ0FBQztBQUMzRCxZQUFJLENBQUMwTixRQUFRLENBQUNmLGVBQWUsRUFBRTtBQUMvQixlQUFPTyxVQUFVLENBQUNrQyxPQUFPLENBQUNuQyxZQUFZLENBQUM7QUFDekM7TUFFQSxJQUFJeUQscUJBQXFCLENBQUN6RCxZQUFZLENBQUNudkIsSUFBSSxFQUFFLElBQUksQ0FBQzJ2QixVQUFVLENBQUMsRUFBRTtRQUM3RG4xQixZQUFZLENBQUN6RCxLQUFLLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQ21yQixVQUFVLENBQUM7QUFDbEQsWUFBSSxDQUFDME4sUUFBUSxDQUFDakIsU0FBUyxFQUFFO0FBRXpCLFlBQUksSUFBSSxDQUFDaUIsUUFBUSxDQUFDYixZQUFZLEVBQUUsRUFBRTtVQUNoQ0ksWUFBWSxDQUFDbnZCLElBQUksR0FBR212QixZQUFZLENBQUNudkIsSUFBSSxDQUFDcEgsS0FBSyxDQUN6QyxDQUFDLEVBQ0R1MkIsWUFBWSxDQUFDbnZCLElBQUksQ0FBQzlCLFVBQVUsR0FBRyxJQUFJLENBQUN5eEIsVUFBVSxDQUFDenhCLFVBQVUsQ0FDMUQ7QUFDRCxpQkFBT2t4QixVQUFVLENBQUNrQyxPQUFPLENBQUNuQyxZQUFZLENBQUM7QUFDekMsU0FBQyxNQUFNO0FBQ0wzMEIsVUFBQUEsWUFBWSxDQUFDcWhCLElBQUksQ0FBQyxtQ0FBbUMsQ0FBQztBQUN0RDtBQUNGO0FBQ0YsT0FBQyxNQUFNO0FBQ0wsWUFBSSxDQUFDK1QsUUFBUSxDQUFDZixlQUFlLEVBQUU7QUFDakM7TUFDQSxNQUFNN3VCLElBQUksR0FBRyxJQUFJdUYsVUFBVSxDQUFDNHBCLFlBQVksQ0FBQ252QixJQUFJLENBQUM7TUFDOUMsTUFBTTJ4QixRQUFRLEdBQUczeEIsSUFBSSxDQUFDbXZCLFlBQVksQ0FBQ252QixJQUFJLENBQUM5QixVQUFVLEdBQUcsQ0FBQyxDQUFDO01BRXZELElBQUksSUFBSSxDQUFDd1AsSUFBSSxDQUFDbWxCLG9CQUFvQixDQUFDbEIsUUFBUSxDQUFDLEVBQUU7QUFDNUM7QUFDQTtBQUNGO01BRUEsSUFBSSxJQUFJLENBQUNqa0IsSUFBSSxDQUFDOGpCLFNBQVMsQ0FBQ0csUUFBUSxDQUFDLEVBQUU7UUFDakMsSUFBSTtVQUNGLE1BQU1tQixZQUFZLEdBQUcsTUFBTSxJQUFJLENBQUNDLFlBQVksQ0FBQzVELFlBQVksRUFBRXdDLFFBQVEsQ0FBQztBQUNwRSxjQUFJLENBQUNqa0IsSUFBSSxDQUFDc2xCLGlCQUFpQixDQUFDckIsUUFBUSxDQUFDO0FBQ3JDLGNBQUltQixZQUFZLEVBQUU7QUFDaEIsbUJBQU8xRCxVQUFVLENBQUNrQyxPQUFPLENBQUN3QixZQUFZLENBQUM7QUFDekM7U0FDRCxDQUFDLE9BQU81VixLQUFLLEVBQUU7VUFDZCxJQUFJQSxLQUFLLFlBQVk2TyxZQUFZLElBQUk3TyxLQUFLLENBQUM4TyxNQUFNLEtBQUtGLGtCQUFrQixDQUFDbUgsVUFBVSxFQUFFO0FBQ25GO0FBQ0EsZ0JBQUksSUFBSSxDQUFDdmxCLElBQUksQ0FBQ3dsQixXQUFXLEVBQUU7Y0FDekIsSUFBSSxDQUFDblcsSUFBSSxDQUFDdVAsWUFBWSxDQUFDMXhCLEtBQUssRUFBRXNpQixLQUFLLENBQUM7QUFDcEMsa0JBQUksQ0FBQ3hQLElBQUksQ0FBQ3lsQixpQkFBaUIsQ0FBQ3hCLFFBQVEsQ0FBQztBQUN2QztBQUNGLFdBQUMsTUFBTTtBQUNMbjNCLFlBQUFBLFlBQVksQ0FBQ3FoQixJQUFJLENBQUMsdUJBQXVCLEVBQUU7QUFBRXFCLGNBQUFBLEtBQUFBO0FBQU8sY0FBQztBQUN2RDtBQUNGO0FBQ0YsT0FBQyxNQUFNO0FBQ0w7QUFDQTFpQixRQUFBQSxZQUFZLENBQUNxaEIsSUFBSSxvREFBQW5kLE1BQUEsQ0FBb0RpekIsUUFBUSxDQUFFLENBQUM7QUFDaEYsWUFBSSxDQUFDNVUsSUFBSSxDQUNQdVAsWUFBWSxDQUFDMXhCLEtBQUssRUFDbEIsSUFBSW14QixZQUFZLHlCQUFBcnRCLE1BQUEsQ0FDVWl6QixRQUFRLHVCQUFBanpCLE1BQUEsQ0FBb0IsSUFBSSxDQUFDd3RCLG1CQUFtQixHQUM1RUosa0JBQWtCLENBQUM0RixVQUFVLEVBQzdCLElBQUksQ0FBQ3hGLG1CQUFtQixDQUN6QixDQUNGO0FBQ0QsWUFBSSxDQUFDeGUsSUFBSSxDQUFDeWxCLGlCQUFpQixDQUFDeEIsUUFBUSxDQUFDO0FBQ3ZDO0FBQ0YsS0FBQztBQUFBO0FBRUQ7OztBQUdHO0FBQ1dvQixFQUFBQSxZQUFZQSxDQUFBSyxjQUFBLEVBQUFDLFVBQUE7d0RBQ3hCbEUsWUFBeUQsRUFDekR3QyxRQUFnQjtBQUFBLFVBQUEyQixLQUFBO0FBQUEsVUFDaEJDLGVBQXNDLEdBQUFyOUIsU0FBQSxDQUFBVSxNQUFBLFFBQUFWLFNBQUEsUUFBQUssU0FBQSxHQUFBTCxTQUFBLE1BQUFLLFNBQVM7TUFBQSxJQUMvQ2k5QixXQUFBLEdBQUF0OUIsU0FBQSxDQUFBVSxNQUFBLEdBQUFWLENBQUFBLElBQUFBLFNBQUEsQ0FBQUssQ0FBQUEsQ0FBQUEsS0FBQUEsU0FBQSxHQUFBTCxTQUFBLENBQW9DO0FBQUV1OUIsUUFBQUEsWUFBWSxFQUFFO09BQUc7TUFBQTs7UUFFdkQsTUFBTWxDLE1BQU0sR0FBRytCLEtBQUksQ0FBQzVsQixJQUFJLENBQUM4akIsU0FBUyxDQUFDRyxRQUFRLENBQUM7QUFDNUMsWUFBSSxDQUFDNkIsV0FBVyxDQUFDL0YsYUFBYSxJQUFJLENBQUM4RCxNQUFNLEVBQUU7VUFDekMsTUFBTSxJQUFJdDRCLFNBQVMsQ0FBQXlGLDRDQUFBQSxDQUFBQSxNQUFBLENBQThDNDBCLEtBQUksQ0FBQ3BILG1CQUFtQixDQUFFLENBQUM7QUFDOUY7QUFDQSxZQUFJK0YsU0FBUyxHQUFHcUIsS0FBSSxDQUFDcEIsbUJBQW1CLENBQUMvQyxZQUFZLENBQUM7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7UUFFQSxJQUFJO0FBQ0YsZ0JBQU1nRCxXQUFXLEdBQUcsSUFBSTVzQixVQUFVLENBQUM0cEIsWUFBWSxDQUFDbnZCLElBQUksRUFBRSxDQUFDLEVBQUVpeUIsU0FBUyxDQUFDRyxnQkFBZ0IsQ0FBQztVQUNwRixJQUFJc0IsYUFBYSxHQUFHLElBQUludUIsVUFBVSxDQUNoQzRwQixZQUFZLENBQUNudkIsSUFBSSxFQUNqQm15QixXQUFXLENBQUN2N0IsTUFBTSxFQUNsQnU0QixZQUFZLENBQUNudkIsSUFBSSxDQUFDOUIsVUFBVSxHQUFHaTBCLFdBQVcsQ0FBQ3Y3QixNQUFNLENBQ2xEO1VBQ0QsSUFBSXE3QixTQUFTLENBQUNTLE1BQU0sSUFBSTdFLG1CQUFtQixDQUFDNkYsYUFBYSxDQUFDLEVBQUU7QUFDMURBLFlBQUFBLGFBQWEsR0FBRzNGLFNBQVMsQ0FBQzJGLGFBQWEsQ0FBQztBQUN4QyxrQkFBTUMsUUFBUSxHQUFHLElBQUlwdUIsVUFBVSxDQUFDNHNCLFdBQVcsQ0FBQ2owQixVQUFVLEdBQUd3MUIsYUFBYSxDQUFDeDFCLFVBQVUsQ0FBQztBQUNsRnkxQixZQUFBQSxRQUFRLENBQUMvc0IsR0FBRyxDQUFDdXJCLFdBQVcsQ0FBQztZQUN6QndCLFFBQVEsQ0FBQy9zQixHQUFHLENBQUM4c0IsYUFBYSxFQUFFdkIsV0FBVyxDQUFDajBCLFVBQVUsQ0FBQztBQUNuRGl4QixZQUFBQSxZQUFZLENBQUNudkIsSUFBSSxHQUFHMnpCLFFBQVEsQ0FBQ2hzQixNQUFNO0FBQ3JDO0FBRUEsZ0JBQU0wcUIsWUFBWSxHQUFHLElBQUk5c0IsVUFBVSxDQUFDNHBCLFlBQVksQ0FBQ252QixJQUFJLEVBQUVtdkIsWUFBWSxDQUFDbnZCLElBQUksQ0FBQzlCLFVBQVUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBRTNGLGdCQUFNMDFCLFFBQVEsR0FBR3ZCLFlBQVksQ0FBQyxDQUFDLENBQUM7VUFDaEMsTUFBTVQsRUFBRSxHQUFHLElBQUlyc0IsVUFBVSxDQUN2QjRwQixZQUFZLENBQUNudkIsSUFBSSxFQUNqQm12QixZQUFZLENBQUNudkIsSUFBSSxDQUFDOUIsVUFBVSxHQUFHMDFCLFFBQVEsR0FBR3ZCLFlBQVksQ0FBQ24wQixVQUFVLEVBQ2pFMDFCLFFBQVEsQ0FDVDtBQUVELGdCQUFNQyxlQUFlLEdBQUcxQixXQUFXLENBQUNqMEIsVUFBVTtBQUM5QyxnQkFBTTQxQixnQkFBZ0IsR0FDcEIzRSxZQUFZLENBQUNudkIsSUFBSSxDQUFDOUIsVUFBVSxJQUMzQmkwQixXQUFXLENBQUNqMEIsVUFBVSxHQUFHMDFCLFFBQVEsR0FBR3ZCLFlBQVksQ0FBQ24wQixVQUFVLENBQUM7VUFFL0QsTUFBTTYxQixTQUFTLEdBQUcsTUFBTWpILE1BQU0sQ0FBQ0MsTUFBTSxDQUFDaUgsT0FBTyxDQUMzQztBQUNFbDlCLFlBQUFBLElBQUksRUFBRXV6QixvQkFBb0I7WUFDMUJ1SCxFQUFFO0FBQ0ZZLFlBQUFBLGNBQWMsRUFBRSxJQUFJanRCLFVBQVUsQ0FBQzRwQixZQUFZLENBQUNudkIsSUFBSSxFQUFFLENBQUMsRUFBRW15QixXQUFXLENBQUNqMEIsVUFBVTtXQUM1RSxFQUNELENBQUFtQixFQUFBLEdBQUFtMEIsV0FBVyxDQUFDL0YsYUFBYSxtQ0FBSThELE1BQU8sQ0FBQzlELGFBQWEsRUFDbEQsSUFBSWxvQixVQUFVLENBQUM0cEIsWUFBWSxDQUFDbnZCLElBQUksRUFBRTZ6QixlQUFlLEVBQUVDLGdCQUFnQixDQUFDLENBQ3JFO0FBRUQsZ0JBQU1uQixPQUFPLEdBQUcsSUFBSWx2QixXQUFXLENBQUMwdUIsV0FBVyxDQUFDajBCLFVBQVUsR0FBRzYxQixTQUFTLENBQUM3MUIsVUFBVSxDQUFDO0FBQzlFLGdCQUFNeTFCLFFBQVEsR0FBRyxJQUFJcHVCLFVBQVUsQ0FBQ290QixPQUFPLENBQUM7QUFFeENnQixVQUFBQSxRQUFRLENBQUMvc0IsR0FBRyxDQUFDLElBQUlyQixVQUFVLENBQUM0cEIsWUFBWSxDQUFDbnZCLElBQUksRUFBRSxDQUFDLEVBQUVteUIsV0FBVyxDQUFDajBCLFVBQVUsQ0FBQyxDQUFDO0FBQzFFeTFCLFVBQUFBLFFBQVEsQ0FBQy9zQixHQUFHLENBQUMsSUFBSXJCLFVBQVUsQ0FBQ3d1QixTQUFTLENBQUMsRUFBRTVCLFdBQVcsQ0FBQ2owQixVQUFVLENBQUM7VUFFL0RpeEIsWUFBWSxDQUFDbnZCLElBQUksR0FBRzJ5QixPQUFPO0FBRTNCLGlCQUFPeEQsWUFBWTtTQUNwQixDQUFDLE9BQU9qUyxLQUFVLEVBQUU7QUFDbkIsY0FBSW9XLEtBQUksQ0FBQzVELGtCQUFrQixDQUFDMUUsaUJBQWlCLEdBQUcsQ0FBQyxFQUFFO1lBQ2pELElBQUl3SSxXQUFXLENBQUNDLFlBQVksR0FBR0gsS0FBSSxDQUFDNUQsa0JBQWtCLENBQUMxRSxpQkFBaUIsRUFBRTtjQUN4RXh3QixZQUFZLENBQUN6RCxLQUFLLDJCQUFBMkgsTUFBQSxDQUNVODBCLFdBQVcsQ0FBQ0MsWUFBWSxVQUFBLzBCLE1BQUEsQ0FDaEQ0MEIsS0FBSSxDQUFDNUQsa0JBQWtCLENBQUMxRSxpQkFDMUIsaUJBQUF0c0IsTUFBQSxDQUFjeXdCLFlBQVksWUFBWThFLG9CQUFvQixHQUFHLE9BQU8sR0FBRyxPQUFPLENBQUUsQ0FDakY7QUFFRCxrQkFBSUMsZUFBbUM7Y0FDdkMsSUFBSSxDQUFDWCxlQUFlLGFBQWZBLGVBQWUsS0FBZixTQUFBQSxlQUFlLEdBQUloQyxNQUFNLE1BQU0rQixLQUFJLENBQUM1bEIsSUFBSSxDQUFDOGpCLFNBQVMsQ0FBQ0csUUFBUSxDQUFDLEVBQUU7QUFDakU7QUFDQTtBQUNBLHNCQUFNd0MsV0FBVyxHQUFHLE1BQU1iLEtBQUksQ0FBQzVsQixJQUFJLENBQUMwbUIsVUFBVSxDQUFDekMsUUFBUSxFQUFFLEtBQUssQ0FBQztnQkFFL0R1QyxlQUFlLEdBQUcsTUFBTTVHLFVBQVUsQ0FBQzZHLFdBQVcsRUFBRWIsS0FBSSxDQUFDNUQsa0JBQWtCLENBQUMzRSxXQUFXLENBQUM7QUFDdEY7QUFFQSxvQkFBTXlCLEtBQUssR0FBRyxNQUFNOEcsS0FBSSxDQUFDUCxZQUFZLENBQUM1RCxZQUFZLEVBQUV3QyxRQUFRLEVBQUU0QixlQUFlLElBQUloQyxNQUFNLEVBQUU7QUFDdkZrQyxnQkFBQUEsWUFBWSxFQUFFRCxXQUFXLENBQUNDLFlBQVksR0FBRyxDQUFDO0FBQzFDaEcsZ0JBQUFBLGFBQWEsRUFBRXlHLGVBQWUsYUFBZkEsZUFBZSxLQUFmLGtCQUFBQSxlQUFlLENBQUV6RyxhQUFBQTtBQUNqQyxnQkFBQztjQUNGLElBQUlqQixLQUFLLElBQUkwSCxlQUFlLEVBQUU7QUFDNUI7QUFDQTtnQkFDQSxJQUFJLENBQUNYLGVBQWUsYUFBZkEsZUFBZSxLQUFmLFNBQUFBLGVBQWUsR0FBSWhDLE1BQU0sTUFBTStCLEtBQUksQ0FBQzVsQixJQUFJLENBQUM4akIsU0FBUyxDQUFDRyxRQUFRLENBQUMsRUFBRTtrQkFDakUyQixLQUFJLENBQUM1bEIsSUFBSSxDQUFDMm1CLFNBQVMsQ0FBQ0gsZUFBZSxFQUFFdkMsUUFBUSxFQUFFLElBQUksQ0FBQztBQUNwRDtBQUNBMkIsa0JBQUFBLEtBQUksQ0FBQzVsQixJQUFJLENBQUM0bUIsa0JBQWtCLENBQUMzQyxRQUFRLENBQUM7QUFDeEM7QUFDRjtBQUNBLHFCQUFPbkYsS0FBSztBQUNkLGFBQUMsTUFBTTtBQUNMOzs7O0FBSUc7QUFFSGh5QixjQUFBQSxZQUFZLENBQUNxaEIsSUFBSSxDQUFDLG1DQUFtQyxDQUFDO0FBQ3RELG9CQUFNLElBQUlrUSxZQUFZLHNDQUFBcnRCLE1BQUEsQ0FDaUI0MEIsS0FBSSxDQUFDcEgsbUJBQW1CLENBQzdESixFQUFBQSxrQkFBa0IsQ0FBQ21ILFVBQVUsRUFDN0JLLEtBQUksQ0FBQ3BILG1CQUFtQixDQUN6QjtBQUNIO0FBQ0YsV0FBQyxNQUFNO0FBQ0wsa0JBQU0sSUFBSUgsWUFBWSx1QkFBQXJ0QixNQUFBLENBQ0V3ZSxLQUFLLENBQUN2ZSxPQUFPLENBQ25DbXRCLEVBQUFBLGtCQUFrQixDQUFDbUgsVUFBVSxFQUM3QkssS0FBSSxDQUFDcEgsbUJBQW1CLENBQ3pCO0FBQ0g7QUFDRjtPQUNEO0tBQUE7QUFBQTtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkc7QUFDSzJGLEVBQUFBLE1BQU1BLENBQUNFLHFCQUE2QixFQUFFQyxTQUFpQjs7QUFDN0QsVUFBTUosRUFBRSxHQUFHLElBQUludUIsV0FBVyxDQUFDa25CLFNBQVMsQ0FBQztBQUNyQyxVQUFNNEosTUFBTSxHQUFHLElBQUkvd0IsUUFBUSxDQUFDb3VCLEVBQUUsQ0FBQztBQUUvQjtJQUNBLElBQUksQ0FBQyxJQUFJLENBQUNwQyxVQUFVLENBQUMvWSxHQUFHLENBQUNzYixxQkFBcUIsQ0FBQyxFQUFFO0FBQy9DO0FBQ0EsVUFBSSxDQUFDdkMsVUFBVSxDQUFDNW9CLEdBQUcsQ0FBQ21yQixxQkFBcUIsRUFBRWx2QixJQUFJLENBQUNDLEtBQUssQ0FBQ0QsSUFBSSxDQUFDMnhCLE1BQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxDQUFDO0FBQ2hGO0lBRUEsTUFBTUMsU0FBUyxHQUFHLENBQUFwMUIsRUFBQSxPQUFJLENBQUNtd0IsVUFBVSxDQUFDaGpCLEdBQUcsQ0FBQ3VsQixxQkFBcUIsQ0FBQyxjQUFBMXlCLEVBQUEsY0FBQUEsRUFBQSxHQUFJLENBQUM7QUFFakVrMUIsSUFBQUEsTUFBTSxDQUFDdnNCLFNBQVMsQ0FBQyxDQUFDLEVBQUUrcEIscUJBQXFCLENBQUM7QUFDMUN3QyxJQUFBQSxNQUFNLENBQUN2c0IsU0FBUyxDQUFDLENBQUMsRUFBRWdxQixTQUFTLENBQUM7SUFDOUJ1QyxNQUFNLENBQUN2c0IsU0FBUyxDQUFDLENBQUMsRUFBRWdxQixTQUFTLEdBQUl5QyxTQUFTLEdBQUcsTUFBTyxDQUFDO0lBRXJELElBQUksQ0FBQ2pGLFVBQVUsQ0FBQzVvQixHQUFHLENBQUNtckIscUJBQXFCLEVBQUUwQyxTQUFTLEdBQUcsQ0FBQyxDQUFDO0FBRXpELFdBQU83QyxFQUFFO0FBQ1g7RUFFUU0sbUJBQW1CQSxDQUFDMUYsS0FBa0Q7O0FBSTVFLFFBQUl5RixTQUFTLEdBQUc7QUFBRUcsTUFBQUEsZ0JBQWdCLEVBQUUsQ0FBQztBQUFFTSxNQUFBQSxNQUFNLEVBQUU7S0FBTztBQUN0RCxRQUFJbkcsWUFBWSxDQUFDQyxLQUFLLENBQUMsRUFBRTtNQUN2QixJQUFJa0ksYUFBYSxHQUFHLENBQUFyMUIsRUFBQSxPQUFJLENBQUNzMUIsYUFBYSxDQUFDbkksS0FBSyxDQUFDLGNBQUFudEIsRUFBQSxjQUFBQSxFQUFBLEdBQUksSUFBSSxDQUFDNHdCLFVBQVU7QUFDaEUsVUFBSXlFLGFBQWEsS0FBSyxJQUFJLENBQUNBLGFBQWEsRUFBRTtRQUN4Q2w2QixZQUFZLENBQUN6RCxLQUFLLENBQUMsMEJBQTBCLEVBQUFxRCxNQUFBLENBQUE2QyxNQUFBO1VBQzNDeTNCLGFBQWE7VUFDYkUsUUFBUSxFQUFFLElBQUksQ0FBQ0YsYUFBQUE7QUFBYSxXQUN6QixJQUFJLENBQUN4UyxVQUFVLEVBQ2xCO1FBQ0YsSUFBSSxDQUFDd1MsYUFBYSxHQUFHQSxhQUFhO0FBQ3BDO01BRUEsSUFBSUEsYUFBYSxLQUFLLEtBQUssRUFBRTtBQUMzQixjQUFNLElBQUk5NUIsS0FBSyxJQUFBOEQsTUFBQSxDQUFJZzJCLGFBQWEsb0RBQWlELENBQUM7QUFDcEY7TUFFQSxJQUFJQSxhQUFhLEtBQUssS0FBSyxFQUFFO1FBQzNCekMsU0FBUyxDQUFDRyxnQkFBZ0IsR0FBRzdILGlCQUFpQixDQUFDaUMsS0FBSyxDQUFDNXVCLElBQUksQ0FBQztBQUM1RCxPQUFDLE1BQU0sSUFBSTgyQixhQUFhLEtBQUssS0FBSyxFQUFFO1FBQ2xDekMsU0FBUyxDQUFDRyxnQkFBZ0IsR0FBRyxDQUFDO0FBQzlCLGVBQU9ILFNBQVM7QUFDbEI7TUFFQSxNQUFNanlCLElBQUksR0FBRyxJQUFJdUYsVUFBVSxDQUFDaW5CLEtBQUssQ0FBQ3hzQixJQUFJLENBQUM7TUFDdkMsSUFBSTtBQUNGLGNBQU02MEIsV0FBVyxHQUFHQyxlQUFlLENBQUM5MEIsSUFBSSxDQUFDO0FBRXpDO0FBQ0FpeUIsUUFBQUEsU0FBUyxDQUFDUyxNQUFNLEdBQ2RnQyxhQUFhLEtBQUssTUFBTSxJQUN4QkcsV0FBVyxDQUFDdlIsSUFBSSxDQUFFeVIsU0FBUyxJQUN6QixDQUFDQyxRQUFRLENBQUNDLFNBQVMsRUFBRUQsUUFBUSxDQUFDRSxhQUFhLENBQUMsQ0FBQzVjLFFBQVEsQ0FBQzZjLGFBQWEsQ0FBQ24xQixJQUFJLENBQUMrMEIsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUN0RjtRQUVILElBQUk5QyxTQUFTLENBQUNTLE1BQU0sRUFBRTtBQUNwQixlQUFLLE1BQU1qVCxLQUFLLElBQUlvVixXQUFXLEVBQUU7WUFDL0IsSUFBSWozQixJQUFJLEdBQUd1M0IsYUFBYSxDQUFDbjFCLElBQUksQ0FBQ3lmLEtBQUssQ0FBQyxDQUFDO0FBQ3JDLG9CQUFRN2hCLElBQUk7Y0FDVixLQUFLbzNCLFFBQVEsQ0FBQ0MsU0FBUztjQUN2QixLQUFLRCxRQUFRLENBQUNFLGFBQWE7QUFDekJqRCxnQkFBQUEsU0FBUyxDQUFDRyxnQkFBZ0IsR0FBRzNTLEtBQUssR0FBRyxDQUFDO0FBQ3RDLHVCQUFPd1MsU0FBUztBQUNsQjtBQUNFO0FBQ0o7QUFDRjtBQUNBLGdCQUFNLElBQUloNUIsU0FBUyxDQUFDLHFCQUFxQixDQUFDO0FBQzVDO09BQ0QsQ0FBQyxPQUFPakQsQ0FBQyxFQUFFO0FBQ1Y7QUFBQTtNQUdGaThCLFNBQVMsQ0FBQ0csZ0JBQWdCLEdBQUc3SCxpQkFBaUIsQ0FBQ2lDLEtBQUssQ0FBQzV1QixJQUFJLENBQUM7QUFDMUQsYUFBT3EwQixTQUFTO0FBQ2xCLEtBQUMsTUFBTTtBQUNMQSxNQUFBQSxTQUFTLENBQUNHLGdCQUFnQixHQUFHN0gsaUJBQWlCLENBQUNFLEtBQUs7QUFDcEQsYUFBT3dILFNBQVM7QUFDbEI7QUFDRjtBQUVBOztBQUVHO0VBQ0swQyxhQUFhQSxDQUFDbkksS0FBMkI7QUFDL0MsUUFBSSxJQUFJLENBQUNpRCxNQUFNLENBQUMyRixJQUFJLEtBQUssQ0FBQyxFQUFFO0FBQzFCLGFBQU83K0IsU0FBUztBQUNsQjtJQUNBLE1BQU04K0IsV0FBVyxHQUFHN0ksS0FBSyxDQUFDc0YsV0FBVyxFQUFFLENBQUN1RCxXQUFXO0FBQ25ELFVBQU05RSxLQUFLLEdBQUc4RSxXQUFXLEdBQUcsSUFBSSxDQUFDNUYsTUFBTSxDQUFDampCLEdBQUcsQ0FBQzZvQixXQUFXLENBQUMsR0FBRzkrQixTQUFTO0FBQ3BFLFdBQU9nNkIsS0FBSztBQUNkO0FBQ0Q7QUFFRDs7O0FBR0c7QUFDRyxTQUFVdUUsZUFBZUEsQ0FBQzlHLE1BQWtCO0VBQ2hELE1BQU01ckIsTUFBTSxHQUFhLEVBQUU7RUFDM0IsSUFBSThHLEtBQUssR0FBRyxDQUFDO0FBQ1h0SSxJQUFBQSxHQUFHLEdBQUcsQ0FBQztBQUNQMDBCLElBQUFBLFlBQVksR0FBR3RILE1BQU0sQ0FBQ3AzQixNQUFNLEdBQUcsQ0FBQztFQUNsQyxPQUFPZ0ssR0FBRyxHQUFHMDBCLFlBQVksRUFBRTtBQUN6QjtBQUNBLFdBQ0UxMEIsR0FBRyxHQUFHMDBCLFlBQVksSUFDbEIsRUFBRXRILE1BQU0sQ0FBQ3B0QixHQUFHLENBQUMsS0FBSyxDQUFDLElBQUlvdEIsTUFBTSxDQUFDcHRCLEdBQUcsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUlvdEIsTUFBTSxDQUFDcHRCLEdBQUcsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFFdEVBLEdBQUcsRUFBRTtJQUNQLElBQUlBLEdBQUcsSUFBSTAwQixZQUFZLEVBQUUxMEIsR0FBRyxHQUFHb3RCLE1BQU0sQ0FBQ3AzQixNQUFNO0FBQzVDO0lBQ0EsSUFBSWlMLEdBQUcsR0FBR2pCLEdBQUc7QUFDYixXQUFPaUIsR0FBRyxHQUFHcUgsS0FBSyxJQUFJOGtCLE1BQU0sQ0FBQ25zQixHQUFHLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFQSxHQUFHLEVBQUU7QUFDbEQ7SUFDQSxJQUFJcUgsS0FBSyxLQUFLLENBQUMsRUFBRTtNQUNmLElBQUlySCxHQUFHLEtBQUtxSCxLQUFLLEVBQUUsTUFBTWpRLFNBQVMsQ0FBQyxtQ0FBbUMsQ0FBQztBQUN6RSxLQUFDLE1BQU07QUFDTG1KLE1BQUFBLE1BQU0sQ0FBQ3ZGLElBQUksQ0FBQ3FNLEtBQUssQ0FBQztBQUNwQjtBQUNBO0FBQ0FBLElBQUFBLEtBQUssR0FBR3RJLEdBQUcsR0FBR0EsR0FBRyxHQUFHLENBQUM7QUFDdkI7QUFDQSxTQUFPd0IsTUFBTTtBQUNmO0FBRU0sU0FBVSt5QixhQUFhQSxDQUFDSSxTQUFpQjtFQUM3QyxPQUFPQSxTQUFTLEdBQUdDLGFBQWE7QUFDbEM7QUFFQSxNQUFNQSxhQUFhLEdBQUcsSUFBSTtBQUUxQixJQUFZUixRQTRDWDtBQTVDRCxXQUFZQSxRQUFRO0FBQ2xCO0VBQ0FBLFFBQUEsQ0FBQUEsUUFBQSx3Q0FBaUI7QUFDakI7RUFDQUEsUUFBQSxDQUFBQSxRQUFBLGdEQUFxQjtBQUNyQjtFQUNBQSxRQUFBLENBQUFBLFFBQUEsZ0RBQXFCO0FBQ3JCO0VBQ0FBLFFBQUEsQ0FBQUEsUUFBQSxnREFBcUI7QUFDckI7RUFDQUEsUUFBQSxDQUFBQSxRQUFBLGdDQUFhO0FBQ2I7RUFDQUEsUUFBQSxDQUFBQSxRQUFBLG9CQUFPO0FBQ1A7RUFDQUEsUUFBQSxDQUFBQSxRQUFBLG9CQUFPO0FBQ1A7RUFDQUEsUUFBQSxDQUFBQSxRQUFBLG9CQUFPO0FBQ1A7RUFDQUEsUUFBQSxDQUFBQSxRQUFBLG9CQUFPO0FBQ1A7RUFDQUEsUUFBQSxDQUFBQSxRQUFBLDZCQUFZO0FBQ1o7RUFDQUEsUUFBQSxDQUFBQSxRQUFBLG1DQUFlO0FBQ2Y7RUFDQUEsUUFBQSxDQUFBQSxRQUFBLHFDQUFnQjtBQUNoQjtFQUNBQSxRQUFBLENBQUFBLFFBQUEsNkJBQVk7QUFDWjtFQUNBQSxRQUFBLENBQUFBLFFBQUEscUNBQWdCO0FBQ2hCO0VBQ0FBLFFBQUEsQ0FBQUEsUUFBQSxtQ0FBZTtBQUNmO0VBQ0FBLFFBQUEsQ0FBQUEsUUFBQSxxQkFBUTtBQUVSO0FBRUE7RUFDQUEsUUFBQSxDQUFBQSxRQUFBLGlDQUFjO0FBQ2Q7RUFDQUEsUUFBQSxDQUFBQSxRQUFBLGlDQUFjO0FBQ2Q7RUFDQUEsUUFBQSxDQUFBQSxRQUFBLDZDQUFvQjtBQUVwQjtBQUNGLENBQUMsRUE1Q1dBLFFBQVEsS0FBUkEsUUFBUSxHQTRDbkI7QUFFRDs7OztBQUlHO0FBQ2EsU0FBQXBDLHFCQUFxQkEsQ0FBQzlFLFNBQXNCLEVBQUUySCxZQUF3QjtBQUNwRixNQUFJQSxZQUFZLENBQUN2M0IsVUFBVSxLQUFLLENBQUMsRUFBRTtBQUNqQyxXQUFPLEtBQUs7QUFDZDtBQUNBLFFBQU1tMEIsWUFBWSxHQUFHLElBQUk5c0IsVUFBVSxDQUNqQ3VvQixTQUFTLENBQUNsMUIsS0FBSyxDQUFDazFCLFNBQVMsQ0FBQzV2QixVQUFVLEdBQUd1M0IsWUFBWSxDQUFDdjNCLFVBQVUsQ0FBQyxDQUNoRTtBQUNELFNBQU91M0IsWUFBWSxDQUFDMW5CLEtBQUssQ0FBQyxDQUFDclIsS0FBSyxFQUFFK2lCLEtBQUssS0FBSy9pQixLQUFLLEtBQUsyMUIsWUFBWSxDQUFDNVMsS0FBSyxDQUFDLENBQUM7QUFDNUU7O0FDNXRCQTtBQUNBO0FBRUE7Ozs7Ozs7QUFPRztBQUNHLE1BQU9pVyxxQkFBc0IsU0FBUzNaLDBCQUE0RTtBQWF0SDs7QUFFRztFQUNILElBQUltWCxXQUFXQSxHQUFBO0lBQ2IsT0FBTyxDQUFDLElBQUksQ0FBQ0wsb0JBQW9CLENBQUMsSUFBSSxDQUFDOEMsZUFBZSxDQUFDO0FBQ3pEO0FBRUFoMkIsRUFBQUEsV0FBWUEsQ0FBQXVzQixtQkFBMkIsRUFBRXdELGtCQUFzQztBQUM3RSxTQUFLLEVBQUU7SUFDUCxJQUFJLENBQUNpRyxlQUFlLEdBQUcsQ0FBQztJQUN4QixJQUFJakcsa0JBQWtCLENBQUN4RSxXQUFXLEdBQUcsQ0FBQyxJQUFJd0Usa0JBQWtCLENBQUN4RSxXQUFXLEdBQUcsR0FBRyxFQUFFO0FBQzlFLFlBQU0sSUFBSWp5QixTQUFTLENBQUMsNENBQTRDLENBQUM7QUFDbkU7QUFDQSxRQUFJLENBQUMyOEIsYUFBYSxHQUFHLElBQUkvbUIsS0FBSyxDQUFDNmdCLGtCQUFrQixDQUFDeEUsV0FBVyxDQUFDLENBQUMySyxJQUFJLENBQUN0L0IsU0FBUyxDQUFDO0FBQzlFLFFBQUksQ0FBQ3UvQix1QkFBdUIsR0FBRyxJQUFJam5CLEtBQUssQ0FBQzZnQixrQkFBa0IsQ0FBQ3hFLFdBQVcsQ0FBQyxDQUFDMkssSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNoRixJQUFJLENBQUNuRyxrQkFBa0IsR0FBR0Esa0JBQWtCO0FBQzVDLFFBQUksQ0FBQ3FHLGlCQUFpQixHQUFHLElBQUk5bUIsR0FBRyxFQUFFO0lBQ2xDLElBQUksQ0FBQ2lkLG1CQUFtQixHQUFHQSxtQkFBbUI7QUFDaEQ7QUFFQTs7OztBQUlHO0VBQ0gyRyxvQkFBb0JBLENBQUNsQixRQUFnQjtBQUNuQyxXQUNFLElBQUksQ0FBQ2pDLGtCQUFrQixDQUFDekUsZ0JBQWdCLElBQUksQ0FBQyxJQUM3QyxJQUFJLENBQUM2Syx1QkFBdUIsQ0FBQ25FLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQ2pDLGtCQUFrQixDQUFDekUsZ0JBQWdCO0FBRXJGO0FBRUE7Ozs7QUFJRztBQUNIa0ksRUFBQUEsaUJBQWlCQSxHQUF3QztBQUFBLFFBQXZDeEIsUUFBQSxHQUFBejdCLFNBQUEsQ0FBQVUsTUFBQSxHQUFBVixDQUFBQSxJQUFBQSxTQUFBLENBQUFLLENBQUFBLENBQUFBLEtBQUFBLFNBQUEsR0FBQUwsU0FBQSxDQUFtQixTQUFJLENBQUN5L0IsZUFBZTtBQUN2RCxRQUFJLElBQUksQ0FBQ2pHLGtCQUFrQixDQUFDekUsZ0JBQWdCLEdBQUcsQ0FBQyxFQUFFO0FBQ2hEO0FBQ0Y7QUFFQSxRQUFJLENBQUM2Syx1QkFBdUIsQ0FBQ25FLFFBQVEsQ0FBQyxJQUFJLENBQUM7QUFFM0MsUUFBSSxJQUFJLENBQUNtRSx1QkFBdUIsQ0FBQ25FLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQ2pDLGtCQUFrQixDQUFDekUsZ0JBQWdCLEVBQUU7QUFDckZ6d0IsTUFBQUEsWUFBWSxDQUFDcWhCLElBQUksQ0FBQW5kLFVBQUFBLENBQUFBLE1BQUEsQ0FDSixJQUFJLENBQUN3dEIsbUJBQW1CLEVBQUF4dEIsWUFBQUEsQ0FBQUEsQ0FBQUEsTUFBQSxDQUFhaXpCLFFBQVEsZ0NBQTZCLENBQ3RGO0FBQ0g7QUFDRjtBQUVBOzs7O0FBSUc7QUFDSHFCLEVBQUFBLGlCQUFpQkEsR0FBd0M7QUFBQSxRQUF2Q3JCLFFBQUEsR0FBQXo3QixTQUFBLENBQUFVLE1BQUEsR0FBQVYsQ0FBQUEsSUFBQUEsU0FBQSxDQUFBSyxDQUFBQSxDQUFBQSxLQUFBQSxTQUFBLEdBQUFMLFNBQUEsQ0FBbUIsU0FBSSxDQUFDeS9CLGVBQWU7QUFDdkQsUUFBSSxDQUFDSyxjQUFjLENBQUNyRSxRQUFRLENBQUM7QUFDL0I7QUFFQTs7Ozs7QUFLRztFQUNIcUUsY0FBY0EsQ0FBQ3JFLFFBQWlCO0lBQzlCLElBQUlBLFFBQVEsS0FBS3A3QixTQUFTLEVBQUU7QUFDMUIsVUFBSSxDQUFDdS9CLHVCQUF1QixDQUFDRCxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3RDLEtBQUMsTUFBTTtBQUNMLFVBQUksQ0FBQ0MsdUJBQXVCLENBQUNuRSxRQUFRLENBQUMsR0FBRyxDQUFDO0FBQzVDO0FBQ0Y7QUFFQTs7Ozs7O0FBTUc7RUFDSHlDLFVBQVVBLENBQUN6QyxRQUFpQixFQUFlO0FBQUEsUUFBYnNFLE1BQU0sR0FBQS8vQixTQUFBLENBQUFVLE1BQUEsUUFBQVYsU0FBQSxRQUFBSyxTQUFBLEdBQUFMLFNBQUEsTUFBRyxJQUFJO0FBQ3pDLFVBQU15L0IsZUFBZSxHQUFHaEUsUUFBUSxhQUFSQSxRQUFRLGNBQVJBLFFBQVEsR0FBSSxJQUFJLENBQUNGLGtCQUFrQixFQUFFO0lBRTdELE1BQU15RSxlQUFlLEdBQUcsSUFBSSxDQUFDSCxpQkFBaUIsQ0FBQ3ZwQixHQUFHLENBQUNtcEIsZUFBZSxDQUFDO0FBQ25FLFFBQUksT0FBT08sZUFBZSxLQUFLLFdBQVcsRUFBRTtBQUMxQyxhQUFPQSxlQUFlO0FBQ3hCO0lBQ0EsTUFBTUMsY0FBYyxHQUFHLElBQUl4VyxPQUFPLENBQVksQ0FBT0MsT0FBTyxFQUFFQyxNQUFNLEtBQUlxSyxTQUFBO01BQ3RFLElBQUk7QUFDRixjQUFNcUgsTUFBTSxHQUFHLElBQUksQ0FBQ0MsU0FBUyxDQUFDbUUsZUFBZSxDQUFDO1FBQzlDLElBQUksQ0FBQ3BFLE1BQU0sRUFBRTtVQUNYLE1BQU0sSUFBSXQ0QixTQUFTLENBQUF5RiwyREFBQUEsQ0FBQUEsTUFBQSxDQUMyQyxJQUFJLENBQUN3dEIsbUJBQW1CLENBQUUsQ0FDdkY7QUFDSDtBQUNBLGNBQU1rSyxlQUFlLEdBQUc3RSxNQUFNLENBQUNoRSxRQUFRO1FBQ3ZDLE1BQU00RyxXQUFXLEdBQUcsTUFBTTFILFNBQVMsQ0FDakMsTUFBTWtCLE9BQU8sQ0FBQ3lJLGVBQWUsRUFBRSxJQUFJLENBQUMxRyxrQkFBa0IsQ0FBQzNFLFdBQVcsQ0FBQyxFQUNuRXFMLGVBQWUsQ0FBQ3hKLFNBQVMsQ0FBQzkxQixJQUFJLEVBQzlCLFFBQVEsQ0FDVDtBQUVELFlBQUltL0IsTUFBTSxFQUFFO1VBQ1YsTUFBTSxJQUFJLENBQUNJLGtCQUFrQixDQUFDbEMsV0FBVyxFQUFFd0IsZUFBZSxFQUFFLElBQUksQ0FBQztBQUNqRSxjQUFJLENBQUM1WSxJQUFJLENBQ1BxUCxlQUFlLENBQUNrSyxZQUFZLEVBQzVCbkMsV0FBVyxFQUNYLElBQUksQ0FBQ2pJLG1CQUFtQixFQUN4QnlKLGVBQWUsQ0FDaEI7QUFDSDtRQUNBL1YsT0FBTyxDQUFDdVUsV0FBVyxDQUFDO09BQ3JCLENBQUMsT0FBT24rQixDQUFDLEVBQUU7UUFDVjZwQixNQUFNLENBQUM3cEIsQ0FBQyxDQUFDO0FBQ1gsT0FBQyxTQUFTO0FBQ1IsWUFBSSxDQUFDKy9CLGlCQUFpQixDQUFDL0wsTUFBTSxDQUFDMkwsZUFBZSxDQUFDO0FBQ2hEO0FBQ0YsS0FBQyxFQUFDO0lBQ0YsSUFBSSxDQUFDSSxpQkFBaUIsQ0FBQ252QixHQUFHLENBQUMrdUIsZUFBZSxFQUFFUSxjQUFjLENBQUM7QUFDM0QsV0FBT0EsY0FBYztBQUN2QjtBQUVBOzs7OztBQUtHO0VBQ0dGLE1BQU1BLENBQUFNLFVBQUE7d0RBQUNoSixRQUFtQjtBQUFBLFVBQUErRixLQUFBO0FBQUEsVUFBRTNCLFFBQVEsR0FBQXo3QixTQUFBLENBQUFVLE1BQUEsUUFBQVYsU0FBQSxRQUFBSyxTQUFBLEdBQUFMLFNBQUEsTUFBRyxDQUFDO01BQUE7QUFDNUMsY0FBTW85QixLQUFJLENBQUMrQyxrQkFBa0IsQ0FBQzlJLFFBQVEsRUFBRW9FLFFBQVEsQ0FBQztBQUNqRDJCLFFBQUFBLEtBQUksQ0FBQzBDLGNBQWMsQ0FBQ3JFLFFBQVEsQ0FBQztPQUM5QjtLQUFBO0FBQUE7QUFFRDs7Ozs7QUFLRztBQUNHMEUsRUFBQUEsa0JBQWtCQSxDQUFBRSxVQUFBLEVBQUFsRCxVQUFBO0FBQUMsV0FBQW5KLFNBQUEsT0FBQWgwQixTQUFBLG9CQUFBcTNCLFFBQW1CLEVBQUVvRSxRQUFnQjtBQUFBLFVBQUE2RSxNQUFBO0FBQUEsVUFBRUMsZ0JBQWdCLEdBQUF2Z0MsU0FBQSxDQUFBVSxNQUFBLFFBQUFWLFNBQUEsUUFBQUssU0FBQSxHQUFBTCxTQUFBLE1BQUcsS0FBSztNQUFBO0FBQ3RGLGNBQU1xN0IsTUFBTSxHQUFHLE1BQU1qRSxVQUFVLENBQUNDLFFBQVEsRUFBRWlKLE1BQUksQ0FBQzlHLGtCQUFrQixDQUFDM0UsV0FBVyxDQUFDO0FBQzlFLGNBQU0yTCxRQUFRLEdBQUcvRSxRQUFRLElBQUksQ0FBQyxHQUFHQSxRQUFRLEdBQUc2RSxNQUFJLENBQUNaLGFBQWEsQ0FBQ2gvQixNQUFNLEdBQUc0L0IsTUFBSSxDQUFDYixlQUFlO0FBQzVGbjdCLFFBQUFBLFlBQVksQ0FBQ3pELEtBQUssK0JBQUEySCxNQUFBLENBQStCaXpCLFFBQVEsQ0FBSTtVQUMzRDlFLEtBQUssRUFBRVUsUUFBUSxDQUFDb0osTUFBTTtVQUN0Qi9KLFNBQVMsRUFBRVcsUUFBUSxDQUFDWCxTQUFTO0FBQzdCN0IsVUFBQUEsV0FBVyxFQUFFeUwsTUFBSSxDQUFDOUcsa0JBQWtCLENBQUMzRSxXQUFBQTtBQUN0QyxVQUFDO1FBQ0Z5TCxNQUFJLENBQUNuQyxTQUFTLENBQUM5QyxNQUFNLEVBQUVtRixRQUFRLEVBQUVELGdCQUFnQixDQUFDO1FBQ2xELElBQUlDLFFBQVEsSUFBSSxDQUFDLEVBQUVGLE1BQUksQ0FBQ2IsZUFBZSxHQUFHZSxRQUFRO09BQ25EO0tBQUE7QUFBQTtBQUVEckMsRUFBQUEsU0FBU0EsQ0FBQzlDLE1BQWMsRUFBRUksUUFBZ0IsRUFBMEI7QUFBQSxRQUF4QjhFLGdCQUFnQixHQUFBdmdDLFNBQUEsQ0FBQVUsTUFBQSxRQUFBVixTQUFBLFFBQUFLLFNBQUEsR0FBQUwsU0FBQSxNQUFHLEtBQUs7QUFDbEUsUUFBSSxDQUFDMC9CLGFBQWEsQ0FBQ2pFLFFBQVEsR0FBRyxJQUFJLENBQUNpRSxhQUFhLENBQUNoL0IsTUFBTSxDQUFDLEdBQUcyNkIsTUFBTTtBQUVqRSxRQUFJa0YsZ0JBQWdCLEVBQUU7QUFDcEIsVUFBSSxDQUFDMVosSUFBSSxDQUFDcVAsZUFBZSxDQUFDa0ssWUFBWSxFQUFFL0UsTUFBTSxDQUFDaEUsUUFBUSxFQUFFLElBQUksQ0FBQ3JCLG1CQUFtQixFQUFFeUYsUUFBUSxDQUFDO0FBQzlGO0FBQ0Y7RUFFTTJDLGtCQUFrQkEsQ0FBQzdVLEtBQWE7O01BQ3BDLElBQUksQ0FBQ2tXLGVBQWUsR0FBR2xXLEtBQUssR0FBRyxJQUFJLENBQUNtVyxhQUFhLENBQUNoL0IsTUFBTTtBQUN4RCxVQUFJLENBQUNvL0IsY0FBYyxDQUFDdlcsS0FBSyxDQUFDO0FBQzVCLEtBQUM7QUFBQTtBQUVEZ1MsRUFBQUEsa0JBQWtCQSxHQUFBO0lBQ2hCLE9BQU8sSUFBSSxDQUFDa0UsZUFBZTtBQUM3QjtBQUVBOzs7O0FBSUc7RUFDSG5FLFNBQVNBLENBQUNHLFFBQWlCO0FBQ3pCLFdBQU8sSUFBSSxDQUFDaUUsYUFBYSxDQUFDakUsUUFBUSxLQUFSLFFBQUFBLFFBQVEsS0FBUixTQUFBQSxRQUFRLEdBQUksSUFBSSxDQUFDZ0UsZUFBZSxDQUFDO0FBQzdEO0FBQ0Q7O0FDL0xELE1BQU1pQixtQkFBbUIsR0FBbUIsRUFBRTtBQUM5QyxNQUFNQyxlQUFlLEdBQXVDLElBQUk1bkIsR0FBRyxFQUFFO0FBQ3JFLElBQUk2bkIsZ0JBQW1EO0FBQ3ZELElBQUlDLFlBQVksR0FBRyxJQUFJL04sVUFBVSxFQUFFO0FBRW5DLElBQUlnTyxtQkFBbUIsR0FBWSxLQUFLO0FBRXhDLElBQUlDLFlBQVksR0FBWSxLQUFLO0FBRWpDLElBQUl0SCxVQUFrQztBQUV0QyxJQUFJRCxrQkFBa0IsR0FBdUI3RSxxQkFBcUI7QUFFbEUsSUFBSTRFLE1BQU0sR0FBNEIsSUFBSXhnQixHQUFHLEVBQUU7QUFFL0N6VSxZQUFZLENBQUNwQixlQUFlLENBQUMsTUFBTSxDQUFDO0FBRXBDODlCLFNBQVMsR0FBSUMsRUFBRSxJQUFJO0FBQ2pCSixFQUFBQSxZQUFZLENBQUMzTixHQUFHLENBQUMsTUFBV2MsU0FBQTtJQUMxQixNQUFNO01BQUVqZixJQUFJO0FBQUVqTCxNQUFBQSxJQUFBQTtLQUFNLEdBQXNCbTNCLEVBQUUsQ0FBQ24zQixJQUFJO0FBRWpELFlBQVFpTCxJQUFJO0FBQ1YsV0FBSyxNQUFNO0FBQ1R6USxRQUFBQSxZQUFZLENBQUN0QixRQUFRLENBQUM4RyxJQUFJLENBQUNvM0IsUUFBUSxDQUFDO0FBQ3BDNThCLFFBQUFBLFlBQVksQ0FBQ0QsSUFBSSxDQUFDLG9CQUFvQixDQUFDO1FBQ3ZDbTFCLGtCQUFrQixHQUFHMXZCLElBQUksQ0FBQzB2QixrQkFBa0I7QUFDNUN1SCxRQUFBQSxZQUFZLEdBQUcsQ0FBQyxDQUFDajNCLElBQUksQ0FBQzB2QixrQkFBa0IsQ0FBQzVFLFNBQVM7QUFDbEQ7QUFDQSxjQUFNdU0sTUFBTSxHQUFZO0FBQ3RCcHNCLFVBQUFBLElBQUksRUFBRSxTQUFTO0FBQ2ZqTCxVQUFBQSxJQUFJLEVBQUU7QUFBRTRrQixZQUFBQSxPQUFPLEVBQUVvUyxtQkFBQUE7QUFBcUI7U0FDdkM7UUFDRE0sV0FBVyxDQUFDRCxNQUFNLENBQUM7QUFDbkI7QUFDRixXQUFLLFFBQVE7UUFDWEUsb0JBQW9CLENBQUN2M0IsSUFBSSxDQUFDNGtCLE9BQU8sRUFBRTVrQixJQUFJLENBQUNrc0IsbUJBQW1CLENBQUM7QUFDNUQxeEIsUUFBQUEsWUFBWSxDQUFDRCxJQUFJLENBQUFtRSxrQ0FBQUEsQ0FBQUEsTUFBQSxDQUNvQnNCLElBQUksQ0FBQ2tzQixtQkFBbUIsVUFBQXh0QixNQUFBLENBQU9zQixJQUFJLENBQUM0a0IsT0FBTyxDQUFFLENBQ2pGO0FBQ0Q7QUFDQTBTLFFBQUFBLFdBQVcsQ0FBQ0gsRUFBRSxDQUFDbjNCLElBQUksQ0FBQztBQUNwQjtBQUNGLFdBQUssUUFBUTtRQUNYLElBQUl3M0IsT0FBTyxHQUFHQyxlQUFlLENBQUN6M0IsSUFBSSxDQUFDa3NCLG1CQUFtQixFQUFFbHNCLElBQUksQ0FBQyt2QixPQUFPLENBQUM7UUFDckV5SCxPQUFPLENBQUMvRyxjQUFjLENBQ3BCeGxCLElBQUksRUFDSmpMLElBQUksQ0FBQzAzQixjQUFjLEVBQ25CMTNCLElBQUksQ0FBQzIzQixjQUFjLEVBQ25CMzNCLElBQUksQ0FBQyt2QixPQUFPLEVBQ1ovdkIsSUFBSSxDQUFDdXdCLEtBQUssQ0FDWDtBQUNEO0FBQ0YsV0FBSyxRQUFRO1FBQ1gsSUFBSXFILFVBQVUsR0FBR0gsZUFBZSxDQUFDejNCLElBQUksQ0FBQ2tzQixtQkFBbUIsRUFBRWxzQixJQUFJLENBQUMrdkIsT0FBTyxDQUFDO1FBQ3hFNkgsVUFBVSxDQUFDbkgsY0FBYyxDQUN2QnhsQixJQUFJLEVBQ0pqTCxJQUFJLENBQUMwM0IsY0FBYyxFQUNuQjEzQixJQUFJLENBQUMyM0IsY0FBYyxFQUNuQjMzQixJQUFJLENBQUMrdkIsT0FBTyxFQUNaL3ZCLElBQUksQ0FBQ3V3QixLQUFLLENBQ1g7QUFDRDtBQUNGLFdBQUssUUFBUTtBQUNYLFlBQUkwRyxZQUFZLEVBQUU7VUFDaEIsTUFBTVksWUFBWSxDQUFDNzNCLElBQUksQ0FBQzJRLEdBQUcsRUFBRTNRLElBQUksQ0FBQzJ4QixRQUFRLENBQUM7QUFDN0MsU0FBQyxNQUFNLElBQUkzeEIsSUFBSSxDQUFDa3NCLG1CQUFtQixFQUFFO0FBQ25DMXhCLFVBQUFBLFlBQVksQ0FBQ0QsSUFBSSxDQUFBbUUsNkJBQUFBLENBQUFBLE1BQUEsQ0FDZXNCLElBQUksQ0FBQ2tzQixtQkFBbUIsYUFBQXh0QixNQUFBLENBQVVzQixJQUFJLENBQUMyeEIsUUFBUSxDQUFFLENBQ2hGO0FBQ0QsZ0JBQU1tRyx3QkFBd0IsQ0FBQzkzQixJQUFJLENBQUNrc0IsbUJBQW1CLENBQUMsQ0FBQytKLE1BQU0sQ0FBQ2oyQixJQUFJLENBQUMyUSxHQUFHLEVBQUUzUSxJQUFJLENBQUMyeEIsUUFBUSxDQUFDO0FBQzFGLFNBQUMsTUFBTTtBQUNMbjNCLFVBQUFBLFlBQVksQ0FBQzBpQixLQUFLLENBQUMsaUVBQWlFLENBQUM7QUFDdkY7QUFDQTtBQUNGLFdBQUssaUJBQWlCO1FBQ3BCNmEsdUJBQXVCLENBQUMvM0IsSUFBSSxDQUFDK3ZCLE9BQU8sRUFBRS92QixJQUFJLENBQUNrc0IsbUJBQW1CLENBQUM7QUFDL0Q7QUFDRixXQUFLLGFBQWE7QUFDaEJ1TCxRQUFBQSxlQUFlLENBQUN6M0IsSUFBSSxDQUFDa3NCLG1CQUFtQixFQUFFbHNCLElBQUksQ0FBQyt2QixPQUFPLENBQUMsQ0FBQ08sYUFBYSxDQUFDdHdCLElBQUksQ0FBQ3V3QixLQUFLLENBQUM7QUFDakY7QUFDRixXQUFLLFdBQVc7QUFDZDtRQUNBZCxNQUFNLEdBQUd6dkIsSUFBSSxDQUFDMUYsR0FBRztBQUNqQnM4QixRQUFBQSxtQkFBbUIsQ0FBQy9ULE9BQU8sQ0FBRW1WLEVBQUUsSUFBSTtVQUNqQyxJQUFJQSxFQUFFLENBQUM1SCxzQkFBc0IsRUFBRSxLQUFLcHdCLElBQUksQ0FBQ2tzQixtQkFBbUIsRUFBRTtBQUM1RDhMLFlBQUFBLEVBQUUsQ0FBQ3hILFNBQVMsQ0FBQ3h3QixJQUFJLENBQUMxRixHQUFHLENBQUM7QUFDeEI7QUFDRixTQUFDLENBQUM7QUFDRjtBQUNGLFdBQUssZ0JBQWdCO1FBQ25CMjlCLG9CQUFvQixDQUFDajRCLElBQUksQ0FBQztBQUMxQjtBQUNGLFdBQUssZUFBZTtBQUNsQms0QixRQUFBQSxnQkFBZ0IsQ0FBQ2w0QixJQUFJLENBQUNxeEIsT0FBTyxDQUFDO0FBQzlCO0FBR0o7QUFDRixHQUFDLEVBQUM7QUFDSixDQUFDO0FBRUQsU0FBZTRHLG9CQUFvQkEsQ0FBQ2o0QixJQUFtQzs7QUFDckUsUUFBSWkzQixZQUFZLEVBQUU7QUFDaEIsWUFBTWtCLFVBQVUsR0FBR0MsbUJBQW1CLEVBQUU7QUFDeEMsWUFBTUQsVUFBVSxDQUFDL0QsVUFBVSxDQUFDcDBCLElBQUksQ0FBQzJ4QixRQUFRLENBQUM7TUFDMUN3RyxVQUFVLENBQUNuQyxjQUFjLEVBQUU7QUFDN0IsS0FBQyxNQUFNLElBQUloMkIsSUFBSSxDQUFDa3NCLG1CQUFtQixFQUFFO0FBQ25DLFlBQU1pTSxVQUFVLEdBQUdMLHdCQUF3QixDQUFDOTNCLElBQUksQ0FBQ2tzQixtQkFBbUIsQ0FBQztBQUNyRSxZQUFNaU0sVUFBVSxDQUFDL0QsVUFBVSxDQUFDcDBCLElBQUksQ0FBQzJ4QixRQUFRLENBQUM7TUFDMUN3RyxVQUFVLENBQUNuQyxjQUFjLEVBQUU7QUFDN0IsS0FBQyxNQUFNO0FBQ0x4N0IsTUFBQUEsWUFBWSxDQUFDMGlCLEtBQUssQ0FDaEIscUZBQXFGLENBQ3RGO0FBQ0g7QUFDRixHQUFDO0FBQUE7QUFFRCxTQUFTdWEsZUFBZUEsQ0FBQ3ZMLG1CQUEyQixFQUFFNkQsT0FBZTtBQUNuRSxNQUFJc0ksUUFBUSxHQUFHekIsbUJBQW1CLENBQUNwckIsTUFBTSxDQUFFaUgsQ0FBQyxJQUFLQSxDQUFDLENBQUM0ZCxVQUFVLEVBQUUsS0FBS04sT0FBTyxDQUFDO0FBQzVFLE1BQUlzSSxRQUFRLENBQUN6aEMsTUFBTSxHQUFHLENBQUMsRUFBRTtBQUN2QixVQUFNMGhDLFNBQVMsR0FBR0QsUUFBUSxDQUN2Qi85QixHQUFHLENBQUVtWSxDQUFDLElBQUk7TUFDVCxPQUFPO0FBQUVvZCxRQUFBQSxXQUFXLEVBQUVwZCxDQUFDLENBQUMyZCxzQkFBc0I7T0FBSTtBQUNwRCxLQUFDLENBQUMsQ0FDRHRwQixJQUFJLENBQUMsR0FBRyxDQUFDO0lBQ1p0TSxZQUFZLENBQUMwaUIsS0FBSyxpREFBQXhlLE1BQUEsQ0FDZ0NxeEIsT0FBTyxFQUFBcnhCLHdCQUFBQSxDQUFBQSxDQUFBQSxNQUFBLENBQXlCd3RCLG1CQUFtQixFQUNuRztBQUFFcU0sTUFBQUEsWUFBWSxFQUFFRCxTQUFBQTtBQUFTLEtBQUUsQ0FDNUI7QUFDSDtBQUNBLE1BQUlkLE9BQU8sR0FBR2EsUUFBUSxDQUFDLENBQUMsQ0FBQztFQUN6QixJQUFJLENBQUNiLE9BQU8sRUFBRTtBQUNaaDlCLElBQUFBLFlBQVksQ0FBQ0QsSUFBSSxDQUFDLDBCQUEwQixFQUFFO0FBQUUyeEIsTUFBQUEsbUJBQUFBO0FBQXFCLE1BQUM7SUFDdEUsSUFBSSxDQUFDd0Qsa0JBQWtCLEVBQUU7TUFDdkIsTUFBTTkwQixLQUFLLENBQUMsNkJBQTZCLENBQUM7QUFDNUM7SUFDQTQ4QixPQUFPLEdBQUcsSUFBSWxJLFlBQVksQ0FBQztNQUN6QnBELG1CQUFtQjtBQUNuQnhlLE1BQUFBLElBQUksRUFBRW9xQix3QkFBd0IsQ0FBQzVMLG1CQUFtQixDQUFDO01BQ25Ed0Qsa0JBQWtCO0FBQ2xCQyxNQUFBQSxVQUFBQTtBQUNELE1BQUM7QUFDRjZILElBQUFBLE9BQU8sQ0FBQ2hILFNBQVMsQ0FBQ2YsTUFBTSxDQUFDO0lBQ3pCK0ksdUJBQXVCLENBQUNoQixPQUFPLENBQUM7QUFDaENaLElBQUFBLG1CQUFtQixDQUFDLzVCLElBQUksQ0FBQzI2QixPQUFPLENBQUM7R0FDbEMsTUFBTSxJQUFJdEwsbUJBQW1CLEtBQUtzTCxPQUFPLENBQUNwSCxzQkFBc0IsRUFBRSxFQUFFO0FBQ25FO0lBQ0FvSCxPQUFPLENBQUN0SCxjQUFjLENBQUNoRSxtQkFBbUIsRUFBRTRMLHdCQUF3QixDQUFDNUwsbUJBQW1CLENBQUMsQ0FBQztBQUM1RjtBQUVBLFNBQU9zTCxPQUFPO0FBQ2hCO0FBRUEsU0FBU00sd0JBQXdCQSxDQUFDNUwsbUJBQTJCO0FBQzNELE1BQUkrSyxZQUFZLEVBQUU7SUFDaEIsT0FBT21CLG1CQUFtQixFQUFFO0FBQzlCO0FBQ0EsTUFBSTFxQixJQUFJLEdBQUdtcEIsZUFBZSxDQUFDcnFCLEdBQUcsQ0FBQzBmLG1CQUFtQixDQUFDO0VBQ25ELElBQUksQ0FBQ3hlLElBQUksRUFBRTtBQUNUQSxJQUFBQSxJQUFJLEdBQUcsSUFBSWdvQixxQkFBcUIsQ0FBQ3hKLG1CQUFtQixFQUFFd0Qsa0JBQWtCLENBQUM7SUFDekVoaUIsSUFBSSxDQUFDeVEsRUFBRSxDQUFDaU8sZUFBZSxDQUFDa0ssWUFBWSxFQUFFbUMsaUJBQWlCLENBQUM7QUFDeEQ1QixJQUFBQSxlQUFlLENBQUNqd0IsR0FBRyxDQUFDc2xCLG1CQUFtQixFQUFFeGUsSUFBSSxDQUFDO0FBQ2hEO0FBQ0EsU0FBT0EsSUFBSTtBQUNiO0FBRUEsU0FBUzBxQixtQkFBbUJBLEdBQUE7RUFDMUIsSUFBSSxDQUFDdEIsZ0JBQWdCLEVBQUU7QUFDckJ0OEIsSUFBQUEsWUFBWSxDQUFDekQsS0FBSyxDQUFDLGlDQUFpQyxDQUFDO0FBQ3JEKy9CLElBQUFBLGdCQUFnQixHQUFHLElBQUlwQixxQkFBcUIsQ0FBQyxZQUFZLEVBQUVoRyxrQkFBa0IsQ0FBQztBQUNoRjtBQUNBLFNBQU9vSCxnQkFBZ0I7QUFDekI7QUFFQSxTQUFTaUIsdUJBQXVCQSxDQUFDaEksT0FBZSxFQUFFN0QsbUJBQTJCO0VBQzNFLE1BQU1tTSxRQUFRLEdBQUd6QixtQkFBbUIsQ0FBQ3ByQixNQUFNLENBQ3hDaUgsQ0FBQyxJQUFLQSxDQUFDLENBQUMyZCxzQkFBc0IsRUFBRSxLQUFLbEUsbUJBQW1CLElBQUl6WixDQUFDLENBQUM0ZCxVQUFVLEVBQUUsS0FBS04sT0FBTyxDQUN4RjtBQUNELE1BQUlzSSxRQUFRLENBQUN6aEMsTUFBTSxHQUFHLENBQUMsRUFBRTtBQUN2QjRELElBQUFBLFlBQVksQ0FBQzBpQixLQUFLLENBQUMsMEVBQTBFLEVBQUU7TUFDN0Y2UyxPQUFPO0FBQ1A3RCxNQUFBQSxtQkFBQUE7QUFDRCxNQUFDO0FBQ0o7QUFDQSxRQUFNc0wsT0FBTyxHQUFHYSxRQUFRLENBQUMsQ0FBQyxDQUFDO0VBQzNCLElBQUksQ0FBQ2IsT0FBTyxFQUFFO0FBQ1poOUIsSUFBQUEsWUFBWSxDQUFDcWhCLElBQUksQ0FBQyx3Q0FBd0MsRUFBRTtNQUFFa1UsT0FBTztBQUFFN0QsTUFBQUEsbUJBQUFBO0FBQXFCLE1BQUM7QUFDL0YsR0FBQyxNQUFNO0lBQ0xzTCxPQUFPLENBQUNySCxnQkFBZ0IsRUFBRTtBQUM1QjtBQUNGO0FBRUEsU0FBU29ILG9CQUFvQkEsQ0FBQzVTLE1BQWUsRUFBRXVILG1CQUEyQjtBQUN4RTF4QixFQUFBQSxZQUFZLENBQUN6RCxLQUFLLGlEQUFBMkgsTUFBQSxDQUFpRHd0QixtQkFBbUIsQ0FBSTtBQUN4RnZILElBQUFBLE1BQUFBO0FBQ0QsSUFBQztBQUNGcUssRUFBQUEsb0JBQW9CLENBQUNwb0IsR0FBRyxDQUFDc2xCLG1CQUFtQixFQUFFdkgsTUFBTSxDQUFDO0FBQ3ZEO0FBRUEsU0FBZWtULFlBQVlBLENBQUNsbkIsR0FBYyxFQUFFOE8sS0FBYzs7QUFDeERqbEIsSUFBQUEsWUFBWSxDQUFDRCxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7QUFBRWtsQixNQUFBQSxLQUFBQTtBQUFPLE1BQUM7SUFDOUMsTUFBTTJZLG1CQUFtQixFQUFFLENBQUNuQyxNQUFNLENBQUN0bEIsR0FBRyxFQUFFOE8sS0FBSyxDQUFDO0FBQ2hELEdBQUM7QUFBQTtBQUVELFNBQVMrWSx1QkFBdUJBLENBQUNoQixPQUFxQjtFQUNwREEsT0FBTyxDQUFDclosRUFBRSxDQUFDbU8sWUFBWSxDQUFDMXhCLEtBQUssRUFBR3NpQixLQUFLLElBQUk7QUFDdkMsVUFBTXZpQixHQUFHLEdBQWlCO0FBQ3hCc1EsTUFBQUEsSUFBSSxFQUFFLE9BQU87QUFDYmpMLE1BQUFBLElBQUksRUFBRTtBQUFFa2QsUUFBQUEsS0FBSyxFQUFFLElBQUl0aUIsS0FBSyxJQUFBOEQsTUFBQSxDQUFJb3RCLGtCQUFrQixDQUFDNU8sS0FBSyxDQUFDOE8sTUFBTSxDQUFDLEVBQUF0dEIsSUFBQUEsQ0FBQUEsQ0FBQUEsTUFBQSxDQUFLd2UsS0FBSyxDQUFDdmUsT0FBTyxDQUFFO0FBQUc7S0FDcEY7SUFDRDI0QixXQUFXLENBQUMzOEIsR0FBRyxDQUFDO0FBQ2xCLEdBQUMsQ0FBQztBQUNKO0FBRUEsU0FBUzg5QixpQkFBaUJBLENBQUNsTCxRQUFtQixFQUFFckIsbUJBQTJCLEVBQUV5RixRQUFpQjtBQUM1RixRQUFNaDNCLEdBQUcsR0FBbUI7QUFDMUJzUSxJQUFBQSxJQUFJLEVBQWM7QUFDbEJqTCxJQUFBQSxJQUFJLEVBQUU7TUFDSmtzQixtQkFBbUI7TUFDbkJ5RixRQUFRO0FBQ1JwRSxNQUFBQSxRQUFBQTtBQUNEO0dBQ0Y7RUFDRCtKLFdBQVcsQ0FBQzM4QixHQUFHLENBQUM7QUFDbEI7QUFFQSxTQUFTdTlCLGdCQUFnQkEsQ0FBQzdHLE9BQW1CO0FBQzNDMUIsRUFBQUEsVUFBVSxHQUFHMEIsT0FBTztBQUNwQnVGLEVBQUFBLG1CQUFtQixDQUFDL1QsT0FBTyxDQUFFcFEsQ0FBQyxJQUFJO0FBQ2hDQSxJQUFBQSxDQUFDLENBQUMyZSxhQUFhLENBQUNDLE9BQU8sQ0FBQztBQUMxQixHQUFDLENBQUM7QUFDSjtBQUVBO0FBQ0E7QUFDQSxJQUFJNzVCLElBQUksQ0FBQ2toQyxpQkFBaUIsRUFBRTtBQUMxQmwrQixFQUFBQSxZQUFZLENBQUN6RCxLQUFLLENBQUMsdUJBQXVCLENBQUM7QUFDM0M7QUFDQVMsRUFBQUEsSUFBSSxDQUFDbWhDLGNBQWMsR0FBSUMsS0FBd0IsSUFBSTtBQUNqRDtBQUNBLFVBQU1DLFdBQVcsR0FBR0QsS0FBSyxDQUFDQyxXQUFXO0FBQ3JDcitCLElBQUFBLFlBQVksQ0FBQ3pELEtBQUssQ0FBQyxhQUFhLEVBQUU4aEMsV0FBVyxDQUFDO0FBQzlDO0lBQ0FBLFdBQVcsQ0FBQ0MsT0FBTyxHQUFHLElBQUk7SUFDMUIsTUFBTTtNQUFFN3RCLElBQUk7TUFBRWloQixtQkFBbUI7TUFBRTZELE9BQU87QUFBRVEsTUFBQUEsS0FBQUE7S0FBTyxHQUFHc0ksV0FBVyxDQUFDbDdCLE9BQU87QUFDekUsVUFBTTY1QixPQUFPLEdBQUdDLGVBQWUsQ0FBQ3ZMLG1CQUFtQixFQUFFNkQsT0FBTyxDQUFDO0FBQzdEdjFCLElBQUFBLFlBQVksQ0FBQ3pELEtBQUssQ0FBQyxXQUFXLEVBQUU7QUFBRXc1QixNQUFBQSxLQUFBQTtBQUFPLE1BQUM7QUFDMUNpSCxJQUFBQSxPQUFPLENBQUMvRyxjQUFjLENBQUN4bEIsSUFBSSxFQUFFNHRCLFdBQVcsQ0FBQ2xJLFFBQVEsRUFBRWtJLFdBQVcsQ0FBQ2pJLFFBQVEsRUFBRWIsT0FBTyxFQUFFUSxLQUFLLENBQUM7R0FDekY7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi41Ljkvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9sb2dsZXZlbEAxLjkuMS9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzPzZiNGUiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjUuOS9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL2xvZ2dlci50cz9jNWU1Iiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi41Ljkvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9hc3NlcnQuanM/OGVkOCIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuNS45L25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuMTAuMC9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvZW51bS5qcz9kNzIyIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi41Ljkvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vbWVzc2FnZS5qcz83YjFjIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi41Ljkvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9tZXNzYWdlLXR5cGUuanM/NTI1MCIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuNS45L25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuMTAuMC9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL2dvb2dsZS92YXJpbnQuanM/YjhiMSIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuNS45L25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuMTAuMC9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3Byb3RvLWludDY0LmpzPzY3N2YiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjUuOS9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjEwLjAvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9zY2FsYXIuanM/YzljZiIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuNS45L25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuMTAuMC9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvc2NhbGFycy5qcz8xMTgwIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi41Ljkvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vYmluYXJ5LWVuY29kaW5nLmpzPzQ0ZDYiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjUuOS9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjEwLjAvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL2V4dGVuc2lvbnMuanM/ZGQwMiIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuNS45L25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuMTAuMC9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3Byb3RvLWJhc2U2NC5qcz83MWJmIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi41Ljkvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vZXh0ZW5zaW9uLWFjY2Vzc29yLmpzP2RhODUiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjUuOS9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjEwLjAvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL3JlZmxlY3QuanM/NTRmNCIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuNS45L25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuMTAuMC9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL2lzLW1lc3NhZ2UuanM/MTA4NyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuNS45L25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuMTAuMC9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvZmllbGQtd3JhcHBlci5qcz84ZWM0Iiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi41Ljkvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9qc29uLWZvcm1hdC5qcz8wMTU1Iiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi41Ljkvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9iaW5hcnktZm9ybWF0LmpzPzEzNjUiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjUuOS9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjEwLjAvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL3V0aWwtY29tbW9uLmpzPzhiNTYiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjUuOS9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjEwLjAvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL3Byb3RvLXJ1bnRpbWUuanM/ZjZkNSIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuNS45L25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuMTAuMC9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvZmllbGQtbGlzdC5qcz84Mjg0Iiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi41Ljkvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9uYW1lcy5qcz82YWJiIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi41Ljkvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9maWVsZC5qcz9hZDhjIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi41Ljkvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9maWVsZC1ub3JtYWxpemUuanM/ZWJkYiIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuNS45L25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuMTAuMC9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3Byb3RvMy5qcz8xZjNjIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi41Ljkvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AbGl2ZWtpdCtwcm90b2NvbEAxLjI0LjAvbm9kZV9tb2R1bGVzL0BsaXZla2l0L3Byb3RvY29sL3NyYy9nZW4vbGl2ZWtpdF9tb2RlbHNfcGIuanM/YmFkMiIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuNS45L25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vQGxpdmVraXQrcHJvdG9jb2xAMS4yNC4wL25vZGVfbW9kdWxlcy9AbGl2ZWtpdC9wcm90b2NvbC9zcmMvZ2VuL2xpdmVraXRfcnRjX3BiLmpzPzExN2EiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjUuOS9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3V0aWxzL2Jyb3dzZXJQYXJzZXIudHM/Y2U4YiIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuNS45L25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvcm9vbS90cmFjay9vcHRpb25zLnRzPzI1NjYiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjUuOS9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL2V2ZW50c0AzLjMuMC9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcz8xYTYyIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi41Ljkvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9yb29tL2V2ZW50cy50cz9iMDU0Iiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi41Ljkvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9yb29tL3RyYWNrL1RyYWNrLnRzPzNlZDYiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjUuOS9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3Jvb20vdHJhY2svdXRpbHMudHM/NTU3ZCIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuNS45L25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvcm9vbS91dGlscy50cz8yMDQ3Iiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi41Ljkvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy91dGlscy9Bc3luY1F1ZXVlLnRzPzc1ZjEiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjUuOS9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL2UyZWUvY29uc3RhbnRzLnRzP2QxMmMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjUuOS9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3Jvb20vZXJyb3JzLnRzPzAyMDkiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjUuOS9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL2UyZWUvZXJyb3JzLnRzP2UyNzgiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjUuOS9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL2UyZWUvZXZlbnRzLnRzPzQ1NzUiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjUuOS9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL2UyZWUvdXRpbHMudHM/OGQyOSIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuNS45L25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvZTJlZS93b3JrZXIvU2lmR3VhcmQudHM/ZjgzZSIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuNS45L25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvZTJlZS93b3JrZXIvRnJhbWVDcnlwdG9yLnRzP2NlMzQiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjUuOS9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL2UyZWUvd29ya2VyL1BhcnRpY2lwYW50S2V5SGFuZGxlci50cz84YjAyIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi41Ljkvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9lMmVlL3dvcmtlci9lMmVlLndvcmtlci50cz8xMTQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcbiAgICB2YXIgaXNJRSA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSAmJiAodHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3IgIT09IHVuZGVmaW5lZFR5cGUpICYmIChcbiAgICAgICAgL1RyaWRlbnRcXC98TVNJRSAvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgKTtcblxuICAgIHZhciBsb2dNZXRob2RzID0gW1xuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwid2FyblwiLFxuICAgICAgICBcImVycm9yXCJcbiAgICBdO1xuXG4gICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBudWxsO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcmFjZSgpIGRvZXNuJ3QgcHJpbnQgdGhlIG1lc3NhZ2UgaW4gSUUsIHNvIGZvciB0aGF0IGNhc2Ugd2UgbmVlZCB0byB3cmFwIGl0XG4gICAgZnVuY3Rpb24gdHJhY2VGb3JJRSgpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUubG9nKSB7XG4gICAgICAgICAgICBpZiAoY29uc29sZS5sb2cuYXBwbHkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBvbGQgSUUsIG5hdGl2ZSBjb25zb2xlIG1ldGhvZHMgdGhlbXNlbHZlcyBkb24ndCBoYXZlIGFwcGx5KCkuXG4gICAgICAgICAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KGNvbnNvbGUubG9nLCBbY29uc29sZSwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnNvbGUudHJhY2UpIGNvbnNvbGUudHJhY2UoKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gJ3RyYWNlJyAmJiBpc0lFKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2VGb3JJRTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKCkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmdldExldmVsKCk7XG5cbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgYWN0dWFsIG1ldGhvZHMuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID9cbiAgICAgICAgICAgICAgICBub29wIDpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIHRoaXMubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcblxuICAgICAgICAvLyBSZXR1cm4gYW55IGltcG9ydGFudCB3YXJuaW5ncy5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgdGhpcy5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LlxuICAgIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXG4gICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIF9sZXZlbCwgX2xvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZmFjdG9yeSkge1xuICAgICAgLy8gUHJpdmF0ZSBpbnN0YW5jZSB2YXJpYWJsZXMuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBsZXZlbCBpbmhlcml0ZWQgZnJvbSBhIHBhcmVudCBsb2dnZXIgKG9yIGEgZ2xvYmFsIGRlZmF1bHQpLiBXZVxuICAgICAgICogY2FjaGUgdGhpcyBoZXJlIHJhdGhlciB0aGFuIGRlbGVnYXRpbmcgdG8gdGhlIHBhcmVudCBzbyB0aGF0IGl0IHN0YXlzXG4gICAgICAgKiBpbiBzeW5jIHdpdGggdGhlIGFjdHVhbCBsb2dnaW5nIG1ldGhvZHMgdGhhdCB3ZSBoYXZlIGluc3RhbGxlZCAodGhlXG4gICAgICAgKiBwYXJlbnQgY291bGQgY2hhbmdlIGxldmVscyBidXQgd2UgbWlnaHQgbm90IGhhdmUgcmVidWlsdCB0aGUgbG9nZ2Vyc1xuICAgICAgICogaW4gdGhpcyBjaGlsZCB5ZXQpLlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgdmFyIGluaGVyaXRlZExldmVsO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZGVmYXVsdCBsZXZlbCBmb3IgdGhpcyBsb2dnZXIsIGlmIGFueS4gSWYgc2V0LCB0aGlzIG92ZXJyaWRlc1xuICAgICAgICogYGluaGVyaXRlZExldmVsYC5cbiAgICAgICAqIEB0eXBlIHtudW1iZXJ8bnVsbH1cbiAgICAgICAqL1xuICAgICAgdmFyIGRlZmF1bHRMZXZlbDtcbiAgICAgIC8qKlxuICAgICAgICogQSB1c2VyLXNwZWNpZmljIGxldmVsIGZvciB0aGlzIGxvZ2dlci4gSWYgc2V0LCB0aGlzIG92ZXJyaWRlc1xuICAgICAgICogYGRlZmF1bHRMZXZlbGAuXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfG51bGx9XG4gICAgICAgKi9cbiAgICAgIHZhciB1c2VyTGV2ZWw7XG5cbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICBzdG9yYWdlS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZU5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihjb29raWVOYW1lICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb29raWUuc2xpY2UobG9jYXRpb24gKyBjb29raWVOYW1lLmxlbmd0aCArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgKVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2xlYXJQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgVVRDXCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBub3JtYWxpemVMZXZlbChpbnB1dCkge1xuICAgICAgICAgIHZhciBsZXZlbCA9IGlucHV0O1xuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsZXZlbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBpbnB1dCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xuXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuXG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh1c2VyTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZXJMZXZlbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRlZmF1bHRMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdExldmVsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5oZXJpdGVkTGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkge1xuICAgICAgICAgIHVzZXJMZXZlbCA9IG5vcm1hbGl6ZUxldmVsKGxldmVsKTtcbiAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHsgIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZSh1c2VyTGV2ZWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE5PVEU6IGluIHYyLCB0aGlzIHNob3VsZCBjYWxsIHJlYnVpbGQoKSwgd2hpY2ggdXBkYXRlcyBjaGlsZHJlbi5cbiAgICAgICAgICByZXR1cm4gcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGRlZmF1bHRMZXZlbCA9IG5vcm1hbGl6ZUxldmVsKGxldmVsKTtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYucmVzZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB1c2VyTGV2ZWwgPSBudWxsO1xuICAgICAgICAgIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmKTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYucmVidWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdExvZ2dlciAhPT0gc2VsZikge1xuICAgICAgICAgICAgICBpbmhlcml0ZWRMZXZlbCA9IG5vcm1hbGl6ZUxldmVsKGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYpO1xuXG4gICAgICAgICAgaWYgKGRlZmF1bHRMb2dnZXIgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgY2hpbGROYW1lIGluIF9sb2dnZXJzQnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgX2xvZ2dlcnNCeU5hbWVbY2hpbGROYW1lXS5yZWJ1aWxkKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIGFsbCB0aGUgaW50ZXJuYWwgbGV2ZWxzLlxuICAgICAgaW5oZXJpdGVkTGV2ZWwgPSBub3JtYWxpemVMZXZlbChcbiAgICAgICAgICBkZWZhdWx0TG9nZ2VyID8gZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpIDogXCJXQVJOXCJcbiAgICAgICk7XG4gICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgIGlmIChpbml0aWFsTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICAgIHVzZXJMZXZlbCA9IG5vcm1hbGl6ZUxldmVsKGluaXRpYWxMZXZlbCk7XG4gICAgICB9XG4gICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgICBpZiAoKHR5cGVvZiBuYW1lICE9PSBcInN5bWJvbFwiICYmIHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIH07XG5cbiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XG4gICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xuICAgIH07XG5cbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlcnMgPSBmdW5jdGlvbiBnZXRMb2dnZXJzKCkge1xuICAgICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XG4gICAgfTtcblxuICAgIC8vIEVTNiBkZWZhdWx0IGV4cG9ydCwgZm9yIGNvbXBhdGliaWxpdHlcbiAgICBkZWZhdWx0TG9nZ2VyWydkZWZhdWx0J10gPSBkZWZhdWx0TG9nZ2VyO1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5leHBvcnQgZW51bSBMb2dMZXZlbCB7XG4gIHRyYWNlID0gMCxcbiAgZGVidWcgPSAxLFxuICBpbmZvID0gMixcbiAgd2FybiA9IDMsXG4gIGVycm9yID0gNCxcbiAgc2lsZW50ID0gNSxcbn1cblxuZXhwb3J0IGVudW0gTG9nZ2VyTmFtZXMge1xuICBEZWZhdWx0ID0gJ2xpdmVraXQnLFxuICBSb29tID0gJ2xpdmVraXQtcm9vbScsXG4gIFBhcnRpY2lwYW50ID0gJ2xpdmVraXQtcGFydGljaXBhbnQnLFxuICBUcmFjayA9ICdsaXZla2l0LXRyYWNrJyxcbiAgUHVibGljYXRpb24gPSAnbGl2ZWtpdC10cmFjay1wdWJsaWNhdGlvbicsXG4gIEVuZ2luZSA9ICdsaXZla2l0LWVuZ2luZScsXG4gIFNpZ25hbCA9ICdsaXZla2l0LXNpZ25hbCcsXG4gIFBDTWFuYWdlciA9ICdsaXZla2l0LXBjLW1hbmFnZXInLFxuICBQQ1RyYW5zcG9ydCA9ICdsaXZla2l0LXBjLXRyYW5zcG9ydCcsXG4gIEUyRUUgPSAnbGstZTJlZScsXG59XG5cbnR5cGUgTG9nTGV2ZWxTdHJpbmcgPSBrZXlvZiB0eXBlb2YgTG9nTGV2ZWw7XG5cbmV4cG9ydCB0eXBlIFN0cnVjdHVyZWRMb2dnZXIgPSBsb2cuTG9nZ2VyICYge1xuICB0cmFjZTogKG1zZzogc3RyaW5nLCBjb250ZXh0Pzogb2JqZWN0KSA9PiB2b2lkO1xuICBkZWJ1ZzogKG1zZzogc3RyaW5nLCBjb250ZXh0Pzogb2JqZWN0KSA9PiB2b2lkO1xuICBpbmZvOiAobXNnOiBzdHJpbmcsIGNvbnRleHQ/OiBvYmplY3QpID0+IHZvaWQ7XG4gIHdhcm46IChtc2c6IHN0cmluZywgY29udGV4dD86IG9iamVjdCkgPT4gdm9pZDtcbiAgZXJyb3I6IChtc2c6IHN0cmluZywgY29udGV4dD86IG9iamVjdCkgPT4gdm9pZDtcbiAgc2V0RGVmYXVsdExldmVsOiAobGV2ZWw6IGxvZy5Mb2dMZXZlbERlc2MpID0+IHZvaWQ7XG4gIHNldExldmVsOiAobGV2ZWw6IGxvZy5Mb2dMZXZlbERlc2MpID0+IHZvaWQ7XG4gIGdldExldmVsOiAoKSA9PiBudW1iZXI7XG59O1xuXG5sZXQgbGl2ZWtpdExvZ2dlciA9IGxvZy5nZXRMb2dnZXIoJ2xpdmVraXQnKTtcbmNvbnN0IGxpdmVraXRMb2dnZXJzID0gT2JqZWN0LnZhbHVlcyhMb2dnZXJOYW1lcykubWFwKChuYW1lKSA9PiBsb2cuZ2V0TG9nZ2VyKG5hbWUpKTtcblxubGl2ZWtpdExvZ2dlci5zZXREZWZhdWx0TGV2ZWwoTG9nTGV2ZWwuaW5mbyk7XG5cbmV4cG9ydCBkZWZhdWx0IGxpdmVraXRMb2dnZXIgYXMgU3RydWN0dXJlZExvZ2dlcjtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lOiBzdHJpbmcpIHtcbiAgY29uc3QgbG9nZ2VyID0gbG9nLmdldExvZ2dlcihuYW1lKTtcbiAgbG9nZ2VyLnNldERlZmF1bHRMZXZlbChsaXZla2l0TG9nZ2VyLmdldExldmVsKCkpO1xuICByZXR1cm4gbG9nZ2VyIGFzIFN0cnVjdHVyZWRMb2dnZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbDogTG9nTGV2ZWwgfCBMb2dMZXZlbFN0cmluZywgbG9nZ2VyTmFtZT86IExvZ2dlck5hbWVzKSB7XG4gIGlmIChsb2dnZXJOYW1lKSB7XG4gICAgbG9nLmdldExvZ2dlcihsb2dnZXJOYW1lKS5zZXRMZXZlbChsZXZlbCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBsb2dnZXIgb2YgbGl2ZWtpdExvZ2dlcnMpIHtcbiAgICAgIGxvZ2dlci5zZXRMZXZlbChsZXZlbCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB0eXBlIExvZ0V4dGVuc2lvbiA9IChsZXZlbDogTG9nTGV2ZWwsIG1zZzogc3RyaW5nLCBjb250ZXh0Pzogb2JqZWN0KSA9PiB2b2lkO1xuXG4vKipcbiAqIHVzZSB0aGlzIHRvIGhvb2sgaW50byB0aGUgbG9nZ2luZyBmdW5jdGlvbiB0byBhbGxvdyBzZW5kaW5nIGludGVybmFsIGxpdmVraXQgbG9ncyB0byB0aGlyZCBwYXJ0eSBzZXJ2aWNlc1xuICogaWYgc2V0LCB0aGUgYnJvd3NlciBsb2dzIHdpbGwgbG9zZSB0aGVpciBzdGFja3RyYWNlIGluZm9ybWF0aW9uIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsI3dyaXRpbmctcGx1Z2lucylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldExvZ0V4dGVuc2lvbihleHRlbnNpb246IExvZ0V4dGVuc2lvbiwgbG9nZ2VyPzogU3RydWN0dXJlZExvZ2dlcikge1xuICBjb25zdCBsb2dnZXJzID0gbG9nZ2VyID8gW2xvZ2dlcl0gOiBsaXZla2l0TG9nZ2VycztcblxuICBsb2dnZXJzLmZvckVhY2goKGxvZ1IpID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbEZhY3RvcnkgPSBsb2dSLm1ldGhvZEZhY3Rvcnk7XG5cbiAgICBsb2dSLm1ldGhvZEZhY3RvcnkgPSAobWV0aG9kTmFtZSwgY29uZmlnTGV2ZWwsIGxvZ2dlck5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHJhd01ldGhvZCA9IG9yaWdpbmFsRmFjdG9yeShtZXRob2ROYW1lLCBjb25maWdMZXZlbCwgbG9nZ2VyTmFtZSk7XG5cbiAgICAgIGNvbnN0IGxvZ0xldmVsID0gTG9nTGV2ZWxbbWV0aG9kTmFtZSBhcyBMb2dMZXZlbFN0cmluZ107XG4gICAgICBjb25zdCBuZWVkTG9nID0gbG9nTGV2ZWwgPj0gY29uZmlnTGV2ZWwgJiYgbG9nTGV2ZWwgPCBMb2dMZXZlbC5zaWxlbnQ7XG5cbiAgICAgIHJldHVybiAobXNnLCBjb250ZXh0PzogW21zZzogc3RyaW5nLCBjb250ZXh0OiBvYmplY3RdKSA9PiB7XG4gICAgICAgIGlmIChjb250ZXh0KSByYXdNZXRob2QobXNnLCBjb250ZXh0KTtcbiAgICAgICAgZWxzZSByYXdNZXRob2QobXNnKTtcbiAgICAgICAgaWYgKG5lZWRMb2cpIHtcbiAgICAgICAgICBleHRlbnNpb24obG9nTGV2ZWwsIG1zZywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBsb2dSLnNldExldmVsKGxvZ1IuZ2V0TGV2ZWwoKSk7XG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3Qgd29ya2VyTG9nZ2VyID0gbG9nLmdldExvZ2dlcignbGstZTJlZScpIGFzIFN0cnVjdHVyZWRMb2dnZXI7XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBBc3NlcnQgdGhhdCBjb25kaXRpb24gaXMgdHJ1dGh5IG9yIHRocm93IGVycm9yICh3aXRoIG1lc3NhZ2UpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtc2cpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gYm9vbGVhblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn1cbmNvbnN0IEZMT0FUMzJfTUFYID0gMy40MDI4MjM0NjYzODUyODg2ZTM4LCBGTE9BVDMyX01JTiA9IC0zLjQwMjgyMzQ2NjM4NTI4ODZlMzgsIFVJTlQzMl9NQVggPSAweGZmZmZmZmZmLCBJTlQzMl9NQVggPSAweDdmZmZmZmZmLCBJTlQzMl9NSU4gPSAtMHg4MDAwMDAwMDtcbi8qKlxuICogQXNzZXJ0IGEgdmFsaWQgc2lnbmVkIHByb3RvYnVmIDMyLWJpdCBpbnRlZ2VyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SW50MzIoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50IDMyOiBcIiArIHR5cGVvZiBhcmcpO1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihhcmcpIHx8IGFyZyA+IElOVDMyX01BWCB8fCBhcmcgPCBJTlQzMl9NSU4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcbn1cbi8qKlxuICogQXNzZXJ0IGEgdmFsaWQgdW5zaWduZWQgcHJvdG9idWYgMzItYml0IGludGVnZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRVSW50MzIoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJnKSB8fCBhcmcgPiBVSU5UMzJfTUFYIHx8IGFyZyA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludCAzMjogXCIgKyBhcmcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gc3RyaW5nXG59XG4vKipcbiAqIEFzc2VydCBhIHZhbGlkIHByb3RvYnVmIGZsb2F0IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RmxvYXQzMihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmbG9hdCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShhcmcpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGFyZyA+IEZMT0FUMzJfTUFYIHx8IGFyZyA8IEZMT0FUMzJfTUlOKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZsb2F0IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi9hc3NlcnQuanNcIjtcbmNvbnN0IGVudW1UeXBlU3ltYm9sID0gU3ltYm9sKFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmL2VudW0tdHlwZVwiKTtcbi8qKlxuICogR2V0IHJlZmxlY3Rpb24gaW5mb3JtYXRpb24gZnJvbSBhIGdlbmVyYXRlZCBlbnVtLlxuICogSWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gc29tZXRoaW5nIG90aGVyIHRoYW4gYSBnZW5lcmF0ZWRcbiAqIGVudW0sIGl0IHJhaXNlcyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVudW1UeXBlKGVudW1PYmplY3QpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3QgdCA9IGVudW1PYmplY3RbZW51bVR5cGVTeW1ib2xdO1xuICAgIGFzc2VydCh0LCBcIm1pc3NpbmcgZW51bSB0eXBlIG9uIGVudW0gb2JqZWN0XCIpO1xuICAgIHJldHVybiB0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG59XG4vKipcbiAqIFNldHMgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiBvbiBhIGdlbmVyYXRlZCBlbnVtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RW51bVR5cGUoZW51bU9iamVjdCwgdHlwZU5hbWUsIHZhbHVlcywgb3B0KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGVudW1PYmplY3RbZW51bVR5cGVTeW1ib2xdID0gbWFrZUVudW1UeXBlKHR5cGVOYW1lLCB2YWx1ZXMubWFwKCh2KSA9PiAoe1xuICAgICAgICBubzogdi5ubyxcbiAgICAgICAgbmFtZTogdi5uYW1lLFxuICAgICAgICBsb2NhbE5hbWU6IGVudW1PYmplY3Rbdi5ub10sXG4gICAgfSkpLCBvcHQpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgRW51bVR5cGUgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUVudW1UeXBlKHR5cGVOYW1lLCB2YWx1ZXMsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuX29wdCkge1xuICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBudW1iZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBub3JtYWxWYWx1ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAvLyBXZSBkbyBub3Qgc3VyZmFjZSBvcHRpb25zIGF0IHRoaXMgdGltZVxuICAgICAgICAvLyBjb25zdCB2YWx1ZTogRW51bVZhbHVlSW5mbyA9IHsuLi52LCBvcHRpb25zOiB2Lm9wdGlvbnMgPz8gZW1wdHlSZWFkb25seU9iamVjdH07XG4gICAgICAgIGNvbnN0IG4gPSBub3JtYWxpemVFbnVtVmFsdWUodmFsdWUpO1xuICAgICAgICBub3JtYWxWYWx1ZXMucHVzaChuKTtcbiAgICAgICAgbmFtZXNbdmFsdWUubmFtZV0gPSBuO1xuICAgICAgICBudW1iZXJzW3ZhbHVlLm5vXSA9IG47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lLFxuICAgICAgICB2YWx1ZXM6IG5vcm1hbFZhbHVlcyxcbiAgICAgICAgLy8gV2UgZG8gbm90IHN1cmZhY2Ugb3B0aW9ucyBhdCB0aGlzIHRpbWVcbiAgICAgICAgLy8gb3B0aW9uczogb3B0Py5vcHRpb25zID8/IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIGZpbmROYW1lKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lc1tuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZE51bWJlcihubykge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcnNbbm9dO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBlbnVtIG9iamVjdCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXMuXG4gKiBTZXRzIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRW51bSh0eXBlTmFtZSwgdmFsdWVzLCBvcHQpIHtcbiAgICBjb25zdCBlbnVtT2JqZWN0ID0ge307XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgbiA9IG5vcm1hbGl6ZUVudW1WYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGVudW1PYmplY3Rbbi5sb2NhbE5hbWVdID0gbi5ubztcbiAgICAgICAgZW51bU9iamVjdFtuLm5vXSA9IG4ubG9jYWxOYW1lO1xuICAgIH1cbiAgICBzZXRFbnVtVHlwZShlbnVtT2JqZWN0LCB0eXBlTmFtZSwgdmFsdWVzLCBvcHQpO1xuICAgIHJldHVybiBlbnVtT2JqZWN0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplRW51bVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKFwibG9jYWxOYW1lXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSksIHsgbG9jYWxOYW1lOiB2YWx1ZS5uYW1lIH0pO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogTWVzc2FnZSBpcyB0aGUgYmFzZSBjbGFzcyBvZiBldmVyeSBtZXNzYWdlLCBnZW5lcmF0ZWQsIG9yIGNyZWF0ZWQgYXRcbiAqIHJ1bnRpbWUuXG4gKlxuICogSXQgaXMgX25vdF8gc2FmZSB0byBleHRlbmQgdGhpcyBjbGFzcy4gSWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgbWVzc2FnZSBhdFxuICogcnVuIHRpbWUsIHVzZSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKCkuXG4gKi9cbmV4cG9ydCBjbGFzcyBNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHdpdGggYSBtZXNzYWdlIG9mIHRoZSBzYW1lIHR5cGUuXG4gICAgICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gZGlzcmVnYXJkcyBleHRlbnNpb25zIGFuZCB1bmtub3duIGZpZWxkcy5cbiAgICAgKi9cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpLnJ1bnRpbWUudXRpbC5lcXVhbHModGhpcy5nZXRUeXBlKCksIHRoaXMsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZGVlcCBjb3B5LlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkucnVudGltZS51dGlsLmNsb25lKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBmcm9tIGJpbmFyeSBkYXRhLCBtZXJnaW5nIGZpZWxkcy5cbiAgICAgKlxuICAgICAqIFJlcGVhdGVkIGZpZWxkcyBhcmUgYXBwZW5kZWQuIE1hcCBlbnRyaWVzIGFyZSBhZGRlZCwgb3ZlcndyaXRpbmdcbiAgICAgKiBleGlzdGluZyBrZXlzLlxuICAgICAqXG4gICAgICogSWYgYSBtZXNzYWdlIGZpZWxkIGlzIGFscmVhZHkgcHJlc2VudCwgaXQgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGVcbiAgICAgKiBuZXcgZGF0YS5cbiAgICAgKi9cbiAgICBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSwgZm9ybWF0ID0gdHlwZS5ydW50aW1lLmJpbiwgb3B0ID0gZm9ybWF0Lm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgZm9ybWF0LnJlYWRNZXNzYWdlKHRoaXMsIG9wdC5yZWFkZXJGYWN0b3J5KGJ5dGVzKSwgYnl0ZXMuYnl0ZUxlbmd0aCwgb3B0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgbWVzc2FnZSBmcm9tIGEgSlNPTiB2YWx1ZS5cbiAgICAgKi9cbiAgICBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLCBmb3JtYXQgPSB0eXBlLnJ1bnRpbWUuanNvbiwgb3B0ID0gZm9ybWF0Lm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgZm9ybWF0LnJlYWRNZXNzYWdlKHR5cGUsIGpzb25WYWx1ZSwgb3B0LCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgbWVzc2FnZSBmcm9tIGEgSlNPTiBzdHJpbmcuXG4gICAgICovXG4gICAgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICBsZXQganNvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKGpzb25TdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgJHt0aGlzLmdldFR5cGUoKS50eXBlTmFtZX0gZnJvbSBKU09OOiAke2UgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tSnNvbihqc29uLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBtZXNzYWdlIHRvIGJpbmFyeSBkYXRhLlxuICAgICAqL1xuICAgIHRvQmluYXJ5KG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLCBiaW4gPSB0eXBlLnJ1bnRpbWUuYmluLCBvcHQgPSBiaW4ubWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKSwgd3JpdGVyID0gb3B0LndyaXRlckZhY3RvcnkoKTtcbiAgICAgICAgYmluLndyaXRlTWVzc2FnZSh0aGlzLCB3cml0ZXIsIG9wdCk7XG4gICAgICAgIHJldHVybiB3cml0ZXIuZmluaXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBhIEpTT04gdmFsdWUsIGEgSmF2YVNjcmlwdCB2YWx1ZSB0aGF0IGNhbiBiZVxuICAgICAqIHBhc3NlZCB0byBKU09OLnN0cmluZ2lmeSgpLlxuICAgICAqL1xuICAgIHRvSnNvbihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSwganNvbiA9IHR5cGUucnVudGltZS5qc29uLCBvcHQgPSBqc29uLm1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBqc29uLndyaXRlTWVzc2FnZSh0aGlzLCBvcHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIG1lc3NhZ2UgdG8gYSBKU09OIHN0cmluZy5cbiAgICAgKi9cbiAgICB0b0pzb25TdHJpbmcob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy50b0pzb24ob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXR0eVNwYWNlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGZvciBzZXJpYWxpemF0aW9uIGJlaGF2aW9yLiBUaGlzIHdpbGwgYmUgaW52b2tlZCB3aGVuIGNhbGxpbmdcbiAgICAgKiBKU09OLnN0cmluZ2lmeSBvbiB0aGlzIG1lc3NhZ2UgKGkuZS4gSlNPTi5zdHJpbmdpZnkobXNnKSkuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBzZXJpYWxpemUgZ29vZ2xlLnByb3RvYnVmLkFueSB3aXRoIGEgcGFja2VkXG4gICAgICogbWVzc2FnZSBiZWNhdXNlIHRoZSBwcm90b2J1ZiBKU09OIGZvcm1hdCBzcGVjaWZpZXMgdGhhdCBpdCBuZWVkcyB0byBiZVxuICAgICAqIHVucGFja2VkLCBhbmQgdGhpcyBpcyBvbmx5IHBvc3NpYmxlIHdpdGggYSB0eXBlIHJlZ2lzdHJ5IHRvIGxvb2sgdXAgdGhlXG4gICAgICogbWVzc2FnZSB0eXBlLiAgQXMgYSByZXN1bHQsIGF0dGVtcHRpbmcgdG8gc2VyaWFsaXplIGEgbWVzc2FnZSB3aXRoIHRoaXNcbiAgICAgKiB0eXBlIHdpbGwgdGhyb3cgYW4gRXJyb3IuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBwcm90ZWN0ZWQgYmVjYXVzZSB5b3Ugc2hvdWxkIG5vdCBuZWVkIHRvIGludm9rZSBpdFxuICAgICAqIGRpcmVjdGx5IC0tIGluc3RlYWQgdXNlIEpTT04uc3RyaW5naWZ5IG9yIHRvSnNvblN0cmluZyBmb3JcbiAgICAgKiBzdHJpbmdpZmllZCBKU09OLiAgQWx0ZXJuYXRpdmVseSwgaWYgYWN0dWFsIEpTT04gaXMgZGVzaXJlZCwgeW91IHNob3VsZFxuICAgICAqIHVzZSB0b0pzb24uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0pzb24oe1xuICAgICAgICAgICAgZW1pdERlZmF1bHRWYWx1ZXM6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgTWVzc2FnZVR5cGUgb2YgdGhpcyBtZXNzYWdlIC0gYSBzaW5nbGV0b24gdGhhdCByZXByZXNlbnRzXG4gICAgICogdGhlIHByb3RvYnVmIG1lc3NhZ2UgZGVjbGFyYXRpb24gYW5kIHByb3ZpZGVzIG1ldGFkYXRhIGZvciByZWZsZWN0aW9uLVxuICAgICAqIGJhc2VkIG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgZ2V0VHlwZSgpIHtcbiAgICAgICAgLy8gQW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBNZXNzYWdlIF9tdXN0XyBwcm92aWRlIGEgY29tcGxldGUgc3RhdGljXG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9uIG9mIE1lc3NhZ2VUeXBlLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IE1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZS5qc1wiO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWVzc2FnZSB0eXBlIHVzaW5nIHRoZSBnaXZlbiBydW50aW1lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZU1lc3NhZ2VUeXBlKHJ1bnRpbWUsIHR5cGVOYW1lLCBmaWVsZHMsIG9wdCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsb2NhbE5hbWUgPSAoX2EgPSBvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQubG9jYWxOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0eXBlTmFtZS5zdWJzdHJpbmcodHlwZU5hbWUubGFzdEluZGV4T2YoXCIuXCIpICsgMSk7XG4gICAgY29uc3QgdHlwZSA9IHtcbiAgICAgICAgW2xvY2FsTmFtZV06IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBydW50aW1lLnV0aWwuaW5pdEZpZWxkcyh0aGlzKTtcbiAgICAgICAgICAgIHJ1bnRpbWUudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICAgICAgfSxcbiAgICB9W2xvY2FsTmFtZV07XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHR5cGUucHJvdG90eXBlLCBuZXcgTWVzc2FnZSgpKTtcbiAgICBPYmplY3QuYXNzaWduKHR5cGUsIHtcbiAgICAgICAgcnVudGltZSxcbiAgICAgICAgdHlwZU5hbWUsXG4gICAgICAgIGZpZWxkczogcnVudGltZS51dGlsLm5ld0ZpZWxkTGlzdChmaWVsZHMpLFxuICAgICAgICBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBydW50aW1lLnV0aWwuZXF1YWxzKHR5cGUsIGEsIGIpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiB0eXBlO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyBkaXN0cmlidXRpb24uXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgUHJvdG9jb2wgQnVmZmVyIGNvbXBpbGVyIGlzIG93bmVkIGJ5IHRoZSBvd25lclxuLy8gb2YgdGhlIGlucHV0IGZpbGUgdXNlZCB3aGVuIGdlbmVyYXRpbmcgaXQuICBUaGlzIGNvZGUgaXMgbm90XG4vLyBzdGFuZGFsb25lIGFuZCByZXF1aXJlcyBhIHN1cHBvcnQgbGlicmFyeSB0byBiZSBsaW5rZWQgd2l0aCBpdC4gIFRoaXNcbi8vIHN1cHBvcnQgbGlicmFyeSBpcyBpdHNlbGYgY292ZXJlZCBieSB0aGUgYWJvdmUgbGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAqL1xuLyoqXG4gKiBSZWFkIGEgNjQgYml0IHZhcmludCBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBSZXR1cm5zIHR1cGxlOlxuICogWzBdOiBsb3cgYml0c1xuICogWzFdOiBoaWdoIGJpdHNcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL2J1ZmZlcl9kZWNvZGVyLmpzI0wxNzVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhcmludDY0cmVhZCgpIHtcbiAgICBsZXQgbG93Qml0cyA9IDA7XG4gICAgbGV0IGhpZ2hCaXRzID0gMDtcbiAgICBmb3IgKGxldCBzaGlmdCA9IDA7IHNoaWZ0IDwgMjg7IHNoaWZ0ICs9IDcpIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICAgICAgbG93Qml0cyB8PSAoYiAmIDB4N2YpIDw8IHNoaWZ0O1xuICAgICAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICAgICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1pZGRsZUJ5dGUgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICAvLyBsYXN0IGZvdXIgYml0cyBvZiB0aGUgZmlyc3QgMzIgYml0IG51bWJlclxuICAgIGxvd0JpdHMgfD0gKG1pZGRsZUJ5dGUgJiAweDBmKSA8PCAyODtcbiAgICAvLyAzIHVwcGVyIGJpdHMgYXJlIHBhcnQgb2YgdGhlIG5leHQgMzIgYml0IG51bWJlclxuICAgIGhpZ2hCaXRzID0gKG1pZGRsZUJ5dGUgJiAweDcwKSA+PiA0O1xuICAgIGlmICgobWlkZGxlQnl0ZSAmIDB4ODApID09IDApIHtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gICAgfVxuICAgIGZvciAobGV0IHNoaWZ0ID0gMzsgc2hpZnQgPD0gMzE7IHNoaWZ0ICs9IDcpIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICAgICAgaGlnaEJpdHMgfD0gKGIgJiAweDdmKSA8PCBzaGlmdDtcbiAgICAgICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFyaW50XCIpO1xufVxuLyoqXG4gKiBXcml0ZSBhIDY0IGJpdCB2YXJpbnQsIGdpdmVuIGFzIHR3byBKUyBudW1iZXJzLCB0byB0aGUgZ2l2ZW4gYnl0ZXMgYXJyYXkuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC93cml0ZXIuanMjTDM0NFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFyaW50NjR3cml0ZShsbywgaGksIGJ5dGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyODsgaSA9IGkgKyA3KSB7XG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gbG8gPj4+IGk7XG4gICAgICAgIGNvbnN0IGhhc05leHQgPSAhKHNoaWZ0ID4+PiA3ID09IDAgJiYgaGkgPT0gMCk7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSAoaGFzTmV4dCA/IHNoaWZ0IHwgMHg4MCA6IHNoaWZ0KSAmIDB4ZmY7XG4gICAgICAgIGJ5dGVzLnB1c2goYnl0ZSk7XG4gICAgICAgIGlmICghaGFzTmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNwbGl0Qml0cyA9ICgobG8gPj4+IDI4KSAmIDB4MGYpIHwgKChoaSAmIDB4MDcpIDw8IDQpO1xuICAgIGNvbnN0IGhhc01vcmVCaXRzID0gIShoaSA+PiAzID09IDApO1xuICAgIGJ5dGVzLnB1c2goKGhhc01vcmVCaXRzID8gc3BsaXRCaXRzIHwgMHg4MCA6IHNwbGl0Qml0cykgJiAweGZmKTtcbiAgICBpZiAoIWhhc01vcmVCaXRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDM7IGkgPCAzMTsgaSA9IGkgKyA3KSB7XG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gaGkgPj4+IGk7XG4gICAgICAgIGNvbnN0IGhhc05leHQgPSAhKHNoaWZ0ID4+PiA3ID09IDApO1xuICAgICAgICBjb25zdCBieXRlID0gKGhhc05leHQgPyBzaGlmdCB8IDB4ODAgOiBzaGlmdCkgJiAweGZmO1xuICAgICAgICBieXRlcy5wdXNoKGJ5dGUpO1xuICAgICAgICBpZiAoIWhhc05leHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBieXRlcy5wdXNoKChoaSA+Pj4gMzEpICYgMHgwMSk7XG59XG4vLyBjb25zdGFudHMgZm9yIGJpbmFyeSBtYXRoXG5jb25zdCBUV09fUFdSXzMyX0RCTCA9IDB4MTAwMDAwMDAwO1xuLyoqXG4gKiBQYXJzZSBkZWNpbWFsIHN0cmluZyBvZiA2NCBiaXQgaW50ZWdlciB2YWx1ZSBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludDY0RnJvbVN0cmluZyhkZWMpIHtcbiAgICAvLyBDaGVjayBmb3IgbWludXMgc2lnbi5cbiAgICBjb25zdCBtaW51cyA9IGRlY1swXSA9PT0gXCItXCI7XG4gICAgaWYgKG1pbnVzKSB7XG4gICAgICAgIGRlYyA9IGRlYy5zbGljZSgxKTtcbiAgICB9XG4gICAgLy8gV29yayA2IGRlY2ltYWwgZGlnaXRzIGF0IGEgdGltZSwgYWN0aW5nIGxpa2Ugd2UncmUgY29udmVydGluZyBiYXNlIDFlNlxuICAgIC8vIGRpZ2l0cyB0byBiaW5hcnkuIFRoaXMgaXMgc2FmZSB0byBkbyB3aXRoIGZsb2F0aW5nIHBvaW50IG1hdGggYmVjYXVzZVxuICAgIC8vIE51bWJlci5pc1NhZmVJbnRlZ2VyKEFMTF8zMl9CSVRTICogMWU2KSA9PSB0cnVlLlxuICAgIGNvbnN0IGJhc2UgPSAxZTY7XG4gICAgbGV0IGxvd0JpdHMgPSAwO1xuICAgIGxldCBoaWdoQml0cyA9IDA7XG4gICAgZnVuY3Rpb24gYWRkMWU2ZGlnaXQoYmVnaW4sIGVuZCkge1xuICAgICAgICAvLyBOb3RlOiBOdW1iZXIoJycpIGlzIDAuXG4gICAgICAgIGNvbnN0IGRpZ2l0MWU2ID0gTnVtYmVyKGRlYy5zbGljZShiZWdpbiwgZW5kKSk7XG4gICAgICAgIGhpZ2hCaXRzICo9IGJhc2U7XG4gICAgICAgIGxvd0JpdHMgPSBsb3dCaXRzICogYmFzZSArIGRpZ2l0MWU2O1xuICAgICAgICAvLyBDYXJyeSBiaXRzIGZyb20gbG93Qml0cyB0b1xuICAgICAgICBpZiAobG93Qml0cyA+PSBUV09fUFdSXzMyX0RCTCkge1xuICAgICAgICAgICAgaGlnaEJpdHMgPSBoaWdoQml0cyArICgobG93Qml0cyAvIFRXT19QV1JfMzJfREJMKSB8IDApO1xuICAgICAgICAgICAgbG93Qml0cyA9IGxvd0JpdHMgJSBUV09fUFdSXzMyX0RCTDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGQxZTZkaWdpdCgtMjQsIC0xOCk7XG4gICAgYWRkMWU2ZGlnaXQoLTE4LCAtMTIpO1xuICAgIGFkZDFlNmRpZ2l0KC0xMiwgLTYpO1xuICAgIGFkZDFlNmRpZ2l0KC02KTtcbiAgICByZXR1cm4gbWludXMgPyBuZWdhdGUobG93Qml0cywgaGlnaEJpdHMpIDogbmV3Qml0cyhsb3dCaXRzLCBoaWdoQml0cyk7XG59XG4vKipcbiAqIExvc3NsZXNzbHkgY29udmVydHMgYSA2NC1iaXQgc2lnbmVkIGludGVnZXIgaW4gMzI6MzIgc3BsaXQgcmVwcmVzZW50YXRpb25cbiAqIGludG8gYSBkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludDY0VG9TdHJpbmcobG8sIGhpKSB7XG4gICAgbGV0IGJpdHMgPSBuZXdCaXRzKGxvLCBoaSk7XG4gICAgLy8gSWYgd2UncmUgdHJlYXRpbmcgdGhlIGlucHV0IGFzIGEgc2lnbmVkIHZhbHVlIGFuZCB0aGUgaGlnaCBiaXQgaXMgc2V0LCBkb1xuICAgIC8vIGEgbWFudWFsIHR3bydzIGNvbXBsZW1lbnQgY29udmVyc2lvbiBiZWZvcmUgdGhlIGRlY2ltYWwgY29udmVyc2lvbi5cbiAgICBjb25zdCBuZWdhdGl2ZSA9IChiaXRzLmhpICYgMHg4MDAwMDAwMCk7XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIGJpdHMgPSBuZWdhdGUoYml0cy5sbywgYml0cy5oaSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHVJbnQ2NFRvU3RyaW5nKGJpdHMubG8sIGJpdHMuaGkpO1xuICAgIHJldHVybiBuZWdhdGl2ZSA/IFwiLVwiICsgcmVzdWx0IDogcmVzdWx0O1xufVxuLyoqXG4gKiBMb3NzbGVzc2x5IGNvbnZlcnRzIGEgNjQtYml0IHVuc2lnbmVkIGludGVnZXIgaW4gMzI6MzIgc3BsaXQgcmVwcmVzZW50YXRpb25cbiAqIGludG8gYSBkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVJbnQ2NFRvU3RyaW5nKGxvLCBoaSkge1xuICAgICh7IGxvLCBoaSB9ID0gdG9VbnNpZ25lZChsbywgaGkpKTtcbiAgICAvLyBTa2lwIHRoZSBleHBlbnNpdmUgY29udmVyc2lvbiBpZiB0aGUgbnVtYmVyIGlzIHNtYWxsIGVub3VnaCB0byB1c2UgdGhlXG4gICAgLy8gYnVpbHQtaW4gY29udmVyc2lvbnMuXG4gICAgLy8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgPSAweDAwMUZGRkZGIEZGRkZGRkZGLCB0aHVzIGFueSBudW1iZXIgd2l0aFxuICAgIC8vIGhpZ2hCaXRzIDw9IDB4MUZGRkZGIGNhbiBiZSBzYWZlbHkgZXhwcmVzc2VkIHdpdGggYSBkb3VibGUgYW5kIHJldGFpblxuICAgIC8vIGludGVnZXIgcHJlY2lzaW9uLlxuICAgIC8vIFByb3ZlbiBieTogTnVtYmVyLmlzU2FmZUludGVnZXIoMHgxRkZGRkYgKiAyKiozMiArIDB4RkZGRkZGRkYpID09IHRydWUuXG4gICAgaWYgKGhpIDw9IDB4MUZGRkZGKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoVFdPX1BXUl8zMl9EQkwgKiBoaSArIGxvKTtcbiAgICB9XG4gICAgLy8gV2hhdCB0aGlzIGNvZGUgaXMgZG9pbmcgaXMgZXNzZW50aWFsbHkgY29udmVydGluZyB0aGUgaW5wdXQgbnVtYmVyIGZyb21cbiAgICAvLyBiYXNlLTIgdG8gYmFzZS0xZTcsIHdoaWNoIGFsbG93cyB1cyB0byByZXByZXNlbnQgdGhlIDY0LWJpdCByYW5nZSB3aXRoXG4gICAgLy8gb25seSAzICh2ZXJ5IGxhcmdlKSBkaWdpdHMuIFRob3NlIGRpZ2l0cyBhcmUgdGhlbiB0cml2aWFsIHRvIGNvbnZlcnQgdG9cbiAgICAvLyBhIGJhc2UtMTAgc3RyaW5nLlxuICAgIC8vIFRoZSBtYWdpYyBudW1iZXJzIHVzZWQgaGVyZSBhcmUgLVxuICAgIC8vIDJeMjQgPSAxNjc3NzIxNiA9ICgxLDY3NzcyMTYpIGluIGJhc2UtMWU3LlxuICAgIC8vIDJeNDggPSAyODE0NzQ5NzY3MTA2NTYgPSAoMiw4MTQ3NDk3LDY3MTA2NTYpIGluIGJhc2UtMWU3LlxuICAgIC8vIFNwbGl0IDMyOjMyIHJlcHJlc2VudGF0aW9uIGludG8gMTY6MjQ6MjQgcmVwcmVzZW50YXRpb24gc28gb3VyXG4gICAgLy8gaW50ZXJtZWRpYXRlIGRpZ2l0cyBkb24ndCBvdmVyZmxvdy5cbiAgICBjb25zdCBsb3cgPSBsbyAmIDB4RkZGRkZGO1xuICAgIGNvbnN0IG1pZCA9ICgobG8gPj4+IDI0KSB8IChoaSA8PCA4KSkgJiAweEZGRkZGRjtcbiAgICBjb25zdCBoaWdoID0gKGhpID4+IDE2KSAmIDB4RkZGRjtcbiAgICAvLyBBc3NlbWJsZSBvdXIgdGhyZWUgYmFzZS0xZTcgZGlnaXRzLCBpZ25vcmluZyBjYXJyaWVzLiBUaGUgbWF4aW11bVxuICAgIC8vIHZhbHVlIGluIGEgZGlnaXQgYXQgdGhpcyBzdGVwIGlzIHJlcHJlc2VudGFibGUgYXMgYSA0OC1iaXQgaW50ZWdlciwgd2hpY2hcbiAgICAvLyBjYW4gYmUgc3RvcmVkIGluIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICBsZXQgZGlnaXRBID0gbG93ICsgKG1pZCAqIDY3NzcyMTYpICsgKGhpZ2ggKiA2NzEwNjU2KTtcbiAgICBsZXQgZGlnaXRCID0gbWlkICsgKGhpZ2ggKiA4MTQ3NDk3KTtcbiAgICBsZXQgZGlnaXRDID0gKGhpZ2ggKiAyKTtcbiAgICAvLyBBcHBseSBjYXJyaWVzIGZyb20gQSB0byBCIGFuZCBmcm9tIEIgdG8gQy5cbiAgICBjb25zdCBiYXNlID0gMTAwMDAwMDA7XG4gICAgaWYgKGRpZ2l0QSA+PSBiYXNlKSB7XG4gICAgICAgIGRpZ2l0QiArPSBNYXRoLmZsb29yKGRpZ2l0QSAvIGJhc2UpO1xuICAgICAgICBkaWdpdEEgJT0gYmFzZTtcbiAgICB9XG4gICAgaWYgKGRpZ2l0QiA+PSBiYXNlKSB7XG4gICAgICAgIGRpZ2l0QyArPSBNYXRoLmZsb29yKGRpZ2l0QiAvIGJhc2UpO1xuICAgICAgICBkaWdpdEIgJT0gYmFzZTtcbiAgICB9XG4gICAgLy8gSWYgZGlnaXRDIGlzIDAsIHRoZW4gd2Ugc2hvdWxkIGhhdmUgcmV0dXJuZWQgaW4gdGhlIHRyaXZpYWwgY29kZSBwYXRoXG4gICAgLy8gYXQgdGhlIHRvcCBmb3Igbm9uLXNhZmUgaW50ZWdlcnMuIEdpdmVuIHRoaXMsIHdlIGNhbiBhc3N1bWUgYm90aCBkaWdpdEJcbiAgICAvLyBhbmQgZGlnaXRBIG5lZWQgbGVhZGluZyB6ZXJvcy5cbiAgICByZXR1cm4gZGlnaXRDLnRvU3RyaW5nKCkgKyBkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MoZGlnaXRCKSArXG4gICAgICAgIGRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyhkaWdpdEEpO1xufVxuZnVuY3Rpb24gdG9VbnNpZ25lZChsbywgaGkpIHtcbiAgICByZXR1cm4geyBsbzogbG8gPj4+IDAsIGhpOiBoaSA+Pj4gMCB9O1xufVxuZnVuY3Rpb24gbmV3Qml0cyhsbywgaGkpIHtcbiAgICByZXR1cm4geyBsbzogbG8gfCAwLCBoaTogaGkgfCAwIH07XG59XG4vKipcbiAqIFJldHVybnMgdHdvJ3MgY29tcGxpbWVudCBuZWdhdGlvbiBvZiBpbnB1dC5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0JpdHdpc2VfT3BlcmF0b3JzI1NpZ25lZF8zMi1iaXRfaW50ZWdlcnNcbiAqL1xuZnVuY3Rpb24gbmVnYXRlKGxvd0JpdHMsIGhpZ2hCaXRzKSB7XG4gICAgaGlnaEJpdHMgPSB+aGlnaEJpdHM7XG4gICAgaWYgKGxvd0JpdHMpIHtcbiAgICAgICAgbG93Qml0cyA9IH5sb3dCaXRzICsgMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIGxvd0JpdHMgaXMgMCwgdGhlbiBiaXR3aXNlLW5vdCBpcyAweEZGRkZGRkZGLFxuICAgICAgICAvLyBhZGRpbmcgMSB0byB0aGF0LCByZXN1bHRzIGluIDB4MTAwMDAwMDAwLCB3aGljaCBsZWF2ZXNcbiAgICAgICAgLy8gdGhlIGxvdyBiaXRzIDB4MCBhbmQgc2ltcGx5IGFkZHMgb25lIHRvIHRoZSBoaWdoIGJpdHMuXG4gICAgICAgIGhpZ2hCaXRzICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBuZXdCaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKTtcbn1cbi8qKlxuICogUmV0dXJucyBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGRpZ2l0MWU3IHdpdGggbGVhZGluZyB6ZXJvcy5cbiAqL1xuY29uc3QgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zID0gKGRpZ2l0MWU3KSA9PiB7XG4gICAgY29uc3QgcGFydGlhbCA9IFN0cmluZyhkaWdpdDFlNyk7XG4gICAgcmV0dXJuIFwiMDAwMDAwMFwiLnNsaWNlKHBhcnRpYWwubGVuZ3RoKSArIHBhcnRpYWw7XG59O1xuLyoqXG4gKiBXcml0ZSBhIDMyIGJpdCB2YXJpbnQsIHNpZ25lZCBvciB1bnNpZ25lZC4gU2FtZSBhcyBgdmFyaW50NjR3cml0ZSgwLCB2YWx1ZSwgYnl0ZXMpYFxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvMWIxODgzM2Y0ZjJhMmY2ODFmNGU0YTI1Y2RmM2IwYTQzMTE1ZWMyNi9qcy9iaW5hcnkvZW5jb2Rlci5qcyNMMTQ0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YXJpbnQzMndyaXRlKHZhbHVlLCBieXRlcykge1xuICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICAgIC8vIHdyaXRlIHZhbHVlIGFzIHZhcmludCAzMlxuICAgICAgICB3aGlsZSAodmFsdWUgPiAweDdmKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKCh2YWx1ZSAmIDB4N2YpIHwgMHg4MCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goKHZhbHVlICYgMTI3KSB8IDEyOCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDc7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXMucHVzaCgxKTtcbiAgICB9XG59XG4vKipcbiAqIFJlYWQgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL2J1ZmZlcl9kZWNvZGVyLmpzI0wyMjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhcmludDMycmVhZCgpIHtcbiAgICBsZXQgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIGxldCByZXN1bHQgPSBiICYgMHg3ZjtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDdmKSA8PCA3O1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IDE0O1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IDIxO1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRXh0cmFjdCBvbmx5IGxhc3QgNCBiaXRzXG4gICAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIHJlc3VsdCB8PSAoYiAmIDB4MGYpIDw8IDI4O1xuICAgIGZvciAobGV0IHJlYWRCeXRlcyA9IDU7IChiICYgMHg4MCkgIT09IDAgJiYgcmVhZEJ5dGVzIDwgMTA7IHJlYWRCeXRlcysrKVxuICAgICAgICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgaWYgKChiICYgMHg4MCkgIT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB2YXJpbnRcIik7XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAvLyBSZXN1bHQgY2FuIGhhdmUgMzIgYml0cywgY29udmVydCBpdCB0byB1bnNpZ25lZFxuICAgIHJldHVybiByZXN1bHQgPj4+IDA7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4vcHJpdmF0ZS9hc3NlcnQuanNcIjtcbmltcG9ydCB7IGludDY0RnJvbVN0cmluZywgaW50NjRUb1N0cmluZywgdUludDY0VG9TdHJpbmcsIH0gZnJvbSBcIi4vZ29vZ2xlL3ZhcmludC5qc1wiO1xuZnVuY3Rpb24gbWFrZUludDY0U3VwcG9ydCgpIHtcbiAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoOCkpO1xuICAgIC8vIG5vdGUgdGhhdCBTYWZhcmkgMTQgaW1wbGVtZW50cyBCaWdJbnQsIGJ1dCBub3QgdGhlIERhdGFWaWV3IG1ldGhvZHNcbiAgICBjb25zdCBvayA9IHR5cGVvZiBCaWdJbnQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgZHYuZ2V0QmlnSW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgZHYuZ2V0QmlnVWludDY0ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIGR2LnNldEJpZ0ludDY0ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIGR2LnNldEJpZ1VpbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICh0eXBlb2YgcHJvY2VzcyAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgcHJvY2Vzcy5lbnYgIT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuQlVGX0JJR0lOVF9ESVNBQkxFICE9PSBcIjFcIik7XG4gICAgaWYgKG9rKSB7XG4gICAgICAgIGNvbnN0IE1JTiA9IEJpZ0ludChcIi05MjIzMzcyMDM2ODU0Nzc1ODA4XCIpLCBNQVggPSBCaWdJbnQoXCI5MjIzMzcyMDM2ODU0Nzc1ODA3XCIpLCBVTUlOID0gQmlnSW50KFwiMFwiKSwgVU1BWCA9IEJpZ0ludChcIjE4NDQ2NzQ0MDczNzA5NTUxNjE1XCIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgemVybzogQmlnSW50KDApLFxuICAgICAgICAgICAgc3VwcG9ydGVkOiB0cnVlLFxuICAgICAgICAgICAgcGFyc2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaSA9IHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiID8gdmFsdWUgOiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChiaSA+IE1BWCB8fCBiaSA8IE1JTikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludDY0IGludmFsaWQ6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiaTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1UGFyc2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaSA9IHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiID8gdmFsdWUgOiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChiaSA+IFVNQVggfHwgYmkgPCBVTUlOKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdWludDY0IGludmFsaWQ6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiaTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkdi5zZXRCaWdJbnQ2NCgwLCB0aGlzLnBhcnNlKHZhbHVlKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbG86IGR2LmdldEludDMyKDAsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICBoaTogZHYuZ2V0SW50MzIoNCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1RW5jKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZHYuc2V0QmlnSW50NjQoMCwgdGhpcy51UGFyc2UodmFsdWUpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBsbzogZHYuZ2V0SW50MzIoMCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIGhpOiBkdi5nZXRJbnQzMig0LCB0cnVlKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYyhsbywgaGkpIHtcbiAgICAgICAgICAgICAgICBkdi5zZXRJbnQzMigwLCBsbywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZHYuc2V0SW50MzIoNCwgaGksIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkdi5nZXRCaWdJbnQ2NCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1RGVjKGxvLCBoaSkge1xuICAgICAgICAgICAgICAgIGR2LnNldEludDMyKDAsIGxvLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkdi5zZXRJbnQzMig0LCBoaSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGR2LmdldEJpZ1VpbnQ2NCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGFzc2VydEludDY0U3RyaW5nID0gKHZhbHVlKSA9PiBhc3NlcnQoL14tP1swLTldKyQvLnRlc3QodmFsdWUpLCBgaW50NjQgaW52YWxpZDogJHt2YWx1ZX1gKTtcbiAgICBjb25zdCBhc3NlcnRVSW50NjRTdHJpbmcgPSAodmFsdWUpID0+IGFzc2VydCgvXlswLTldKyQvLnRlc3QodmFsdWUpLCBgdWludDY0IGludmFsaWQ6ICR7dmFsdWV9YCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgemVybzogXCIwXCIsXG4gICAgICAgIHN1cHBvcnRlZDogZmFsc2UsXG4gICAgICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHVQYXJzZSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0VUludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5jKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gaW50NjRGcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdUVuYyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0VUludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBpbnQ2NEZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBkZWMobG8sIGhpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50NjRUb1N0cmluZyhsbywgaGkpO1xuICAgICAgICB9LFxuICAgICAgICB1RGVjKGxvLCBoaSkge1xuICAgICAgICAgICAgcmV0dXJuIHVJbnQ2NFRvU3RyaW5nKGxvLCBoaSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBwcm90b0ludDY0ID0gbWFrZUludDY0U3VwcG9ydCgpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogU2NhbGFyIHZhbHVlIHR5cGVzLiBUaGlzIGlzIGEgc3Vic2V0IG9mIGZpZWxkIHR5cGVzIGRlY2xhcmVkIGJ5IHByb3RvYnVmXG4gKiBlbnVtIGdvb2dsZS5wcm90b2J1Zi5GaWVsZERlc2NyaXB0b3JQcm90by5UeXBlIFRoZSB0eXBlcyBHUk9VUCBhbmQgTUVTU0FHRVxuICogYXJlIG9taXR0ZWQsIGJ1dCB0aGUgbnVtZXJpY2FsIHZhbHVlcyBhcmUgaWRlbnRpY2FsLlxuICovXG5leHBvcnQgdmFyIFNjYWxhclR5cGU7XG4oZnVuY3Rpb24gKFNjYWxhclR5cGUpIHtcbiAgICAvLyAwIGlzIHJlc2VydmVkIGZvciBlcnJvcnMuXG4gICAgLy8gT3JkZXIgaXMgd2VpcmQgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJET1VCTEVcIl0gPSAxXSA9IFwiRE9VQkxFXCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRkxPQVRcIl0gPSAyXSA9IFwiRkxPQVRcIjtcbiAgICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UNjQgaWZcbiAgICAvLyBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJJTlQ2NFwiXSA9IDNdID0gXCJJTlQ2NFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQ2NFwiXSA9IDRdID0gXCJVSU5UNjRcIjtcbiAgICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UMzIgaWZcbiAgICAvLyBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJJTlQzMlwiXSA9IDVdID0gXCJJTlQzMlwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZJWEVENjRcIl0gPSA2XSA9IFwiRklYRUQ2NFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZJWEVEMzJcIl0gPSA3XSA9IFwiRklYRUQzMlwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkJPT0xcIl0gPSA4XSA9IFwiQk9PTFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNUUklOR1wiXSA9IDldID0gXCJTVFJJTkdcIjtcbiAgICAvLyBUYWctZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cbiAgICAvLyBHcm91cCB0eXBlIGlzIGRlcHJlY2F0ZWQgYW5kIG5vdCBzdXBwb3J0ZWQgaW4gcHJvdG8zLiBIb3dldmVyLCBQcm90bzNcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHN0aWxsIGJlIGFibGUgdG8gcGFyc2UgdGhlIGdyb3VwIHdpcmUgZm9ybWF0IGFuZFxuICAgIC8vIHRyZWF0IGdyb3VwIGZpZWxkcyBhcyB1bmtub3duIGZpZWxkcy5cbiAgICAvLyBUWVBFX0dST1VQID0gMTAsXG4gICAgLy8gVFlQRV9NRVNTQUdFID0gMTEsICAvLyBMZW5ndGgtZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cbiAgICAvLyBOZXcgaW4gdmVyc2lvbiAyLlxuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkJZVEVTXCJdID0gMTJdID0gXCJCWVRFU1wiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQzMlwiXSA9IDEzXSA9IFwiVUlOVDMyXCI7XG4gICAgLy8gVFlQRV9FTlVNID0gMTQsXG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVEMzJcIl0gPSAxNV0gPSBcIlNGSVhFRDMyXCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVENjRcIl0gPSAxNl0gPSBcIlNGSVhFRDY0XCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0lOVDMyXCJdID0gMTddID0gXCJTSU5UMzJcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTSU5UNjRcIl0gPSAxOF0gPSBcIlNJTlQ2NFwiO1xufSkoU2NhbGFyVHlwZSB8fCAoU2NhbGFyVHlwZSA9IHt9KSk7XG4vKipcbiAqIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgZmllbGRzIHdpdGggNjQgYml0IGludGVncmFsIHR5cGVzIChpbnQ2NCwgdWludDY0LFxuICogc2ludDY0LCBmaXhlZDY0LCBzZml4ZWQ2NCkuXG4gKlxuICogVGhpcyBpcyBhIHN1YnNldCBvZiBnb29nbGUucHJvdG9idWYuRmllbGRPcHRpb25zLkpTVHlwZSwgd2hpY2ggZGVmaW5lcyBKU19OT1JNQUwsXG4gKiBKU19TVFJJTkcsIGFuZCBKU19OVU1CRVIuIFByb3RvYnVmLUVTIHVzZXMgQmlnSW50IGJ5IGRlZmF1bHQsIGJ1dCB3aWxsIHVzZVxuICogU3RyaW5nIGlmIGBbanN0eXBlID0gSlNfU1RSSU5HXWAgaXMgc3BlY2lmaWVkLlxuICpcbiAqIGBgYHByb3RvYnVmXG4gKiB1aW50NjQgZmllbGRfYSA9IDE7IC8vIEJpZ0ludFxuICogdWludDY0IGZpZWxkX2IgPSAyIFtqc3R5cGUgPSBKU19OT1JNQUxdOyAvLyBCaWdJbnRcbiAqIHVpbnQ2NCBmaWVsZF9iID0gMiBbanN0eXBlID0gSlNfTlVNQkVSXTsgLy8gQmlnSW50XG4gKiB1aW50NjQgZmllbGRfYiA9IDIgW2pzdHlwZSA9IEpTX1NUUklOR107IC8vIFN0cmluZ1xuICogYGBgXG4gKi9cbmV4cG9ydCB2YXIgTG9uZ1R5cGU7XG4oZnVuY3Rpb24gKExvbmdUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVXNlIEphdmFTY3JpcHQgQmlnSW50LlxuICAgICAqL1xuICAgIExvbmdUeXBlW0xvbmdUeXBlW1wiQklHSU5UXCJdID0gMF0gPSBcIkJJR0lOVFwiO1xuICAgIC8qKlxuICAgICAqIFVzZSBKYXZhU2NyaXB0IFN0cmluZy5cbiAgICAgKlxuICAgICAqIEZpZWxkIG9wdGlvbiBgW2pzdHlwZSA9IEpTX1NUUklOR11gLlxuICAgICAqL1xuICAgIExvbmdUeXBlW0xvbmdUeXBlW1wiU1RSSU5HXCJdID0gMV0gPSBcIlNUUklOR1wiO1xufSkoTG9uZ1R5cGUgfHwgKExvbmdUeXBlID0ge30pKTtcbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBwcm90b0ludDY0IH0gZnJvbSBcIi4uL3Byb3RvLWludDY0LmpzXCI7XG5pbXBvcnQgeyBMb25nVHlwZSwgU2NhbGFyVHlwZSB9IGZyb20gXCIuLi9zY2FsYXIuanNcIjtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJvdGggc2NhbGFyIHZhbHVlcyBhcmUgZXF1YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsYXJFcXVhbHModHlwZSwgYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIC8vIFRoaXMgY29ycmVjdGx5IG1hdGNoZXMgZXF1YWwgdmFsdWVzIGV4Y2VwdCBCWVRFUyBhbmQgKHBvc3NpYmx5KSA2NC1iaXQgaW50ZWdlcnMuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBTcGVjaWFsIGNhc2UgQllURVMgLSB3ZSBuZWVkIHRvIGNvbXBhcmUgZWFjaCBieXRlIGluZGl2aWR1YWxseVxuICAgIGlmICh0eXBlID09IFNjYWxhclR5cGUuQllURVMpIHtcbiAgICAgICAgaWYgKCEoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHx8ICEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFNwZWNpYWwgY2FzZSA2NC1iaXQgaW50ZWdlcnMgLSB3ZSBzdXBwb3J0IG51bWJlciwgc3RyaW5nIGFuZCBiaWdpbnQgcmVwcmVzZW50YXRpb24uXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2tcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgICAgICAgLy8gTG9vc2UgY29tcGFyaXNvbiB3aWxsIG1hdGNoIGJldHdlZW4gMG4sIDAgYW5kIFwiMFwiLlxuICAgICAgICAgICAgcmV0dXJuIGEgPT0gYjtcbiAgICB9XG4gICAgLy8gQW55dGhpbmcgdGhhdCBoYXNuJ3QgYmVlbiBjYXVnaHQgYnkgc3RyaWN0IGNvbXBhcmlzb24gb3Igc3BlY2lhbCBjYXNlZFxuICAgIC8vIEJZVEVTIGFuZCA2NC1iaXQgaW50ZWdlcnMgaXMgbm90IGVxdWFsLlxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgemVybyB2YWx1ZSBmb3IgdGhlIGdpdmVuIHNjYWxhciB0eXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGFyWmVyb1ZhbHVlKHR5cGUsIGxvbmdUeXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb24gLS0gYWNjZXB0YWJsZSBzaW5jZSBpdCdzIGNvdmVyZWQgYnkgdGVzdHNcbiAgICAgICAgICAgIHJldHVybiAobG9uZ1R5cGUgPT0gMCA/IHByb3RvSW50NjQuemVybyA6IFwiMFwiKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBIYW5kbGVzIElOVDMyLCBVSU5UMzIsIFNJTlQzMiwgRklYRUQzMiwgU0ZJWEVEMzIuXG4gICAgICAgICAgICAvLyBXZSBkbyBub3QgdXNlIGluZGl2aWR1YWwgY2FzZXMgdG8gc2F2ZSBhIGZldyBieXRlcyBjb2RlIHNpemUuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBmb3IgYSB6ZXJvLXZhbHVlLiBGb3IgZXhhbXBsZSwgYW4gaW50ZWdlciBoYXMgdGhlIHplcm8tdmFsdWUgYDBgLFxuICogYSBib29sZWFuIGlzIGBmYWxzZWAsIGEgc3RyaW5nIGlzIGBcIlwiYCwgYW5kIGJ5dGVzIGlzIGFuIGVtcHR5IFVpbnQ4QXJyYXkuXG4gKlxuICogSW4gcHJvdG8zLCB6ZXJvLXZhbHVlcyBhcmUgbm90IHdyaXR0ZW4gdG8gdGhlIHdpcmUsIHVubGVzcyB0aGUgZmllbGQgaXNcbiAqIG9wdGlvbmFsIG9yIHJlcGVhdGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTY2FsYXJaZXJvVmFsdWUodHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IGZhbHNlO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBcIlwiO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmICF2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09IDA7IC8vIExvb3NlIGNvbXBhcmlzb24gbWF0Y2hlcyAwbiwgMCBhbmQgXCIwXCJcbiAgICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgdmFyaW50MzJyZWFkLCB2YXJpbnQzMndyaXRlLCB2YXJpbnQ2NHJlYWQsIHZhcmludDY0d3JpdGUsIH0gZnJvbSBcIi4vZ29vZ2xlL3ZhcmludC5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0RmxvYXQzMiwgYXNzZXJ0SW50MzIsIGFzc2VydFVJbnQzMiB9IGZyb20gXCIuL3ByaXZhdGUvYXNzZXJ0LmpzXCI7XG5pbXBvcnQgeyBwcm90b0ludDY0IH0gZnJvbSBcIi4vcHJvdG8taW50NjQuanNcIjtcbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxuby1jYXNlLWRlY2xhcmF0aW9ucyxAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAqL1xuLyoqXG4gKiBQcm90b2J1ZiBiaW5hcnkgZm9ybWF0IHdpcmUgdHlwZXMuXG4gKlxuICogQSB3aXJlIHR5cGUgcHJvdmlkZXMganVzdCBlbm91Z2ggaW5mb3JtYXRpb24gdG8gZmluZCB0aGUgbGVuZ3RoIG9mIHRoZVxuICogZm9sbG93aW5nIHZhbHVlLlxuICpcbiAqIFNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvZW5jb2Rpbmcjc3RydWN0dXJlXG4gKi9cbmV4cG9ydCB2YXIgV2lyZVR5cGU7XG4oZnVuY3Rpb24gKFdpcmVUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgaW50MzIsIGludDY0LCB1aW50MzIsIHVpbnQ2NCwgc2ludDMyLCBzaW50NjQsIGJvb2wsIGVudW1cbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIlZhcmludFwiXSA9IDBdID0gXCJWYXJpbnRcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBmaXhlZDY0LCBzZml4ZWQ2NCwgZG91YmxlLlxuICAgICAqIEFsd2F5cyA4IGJ5dGVzIHdpdGggbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICAgICAqL1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiQml0NjRcIl0gPSAxXSA9IFwiQml0NjRcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBzdHJpbmcsIGJ5dGVzLCBlbWJlZGRlZCBtZXNzYWdlcywgcGFja2VkIHJlcGVhdGVkIGZpZWxkc1xuICAgICAqXG4gICAgICogT25seSByZXBlYXRlZCBudW1lcmljIHR5cGVzICh0eXBlcyB3aGljaCB1c2UgdGhlIHZhcmludCwgMzItYml0LFxuICAgICAqIG9yIDY0LWJpdCB3aXJlIHR5cGVzKSBjYW4gYmUgcGFja2VkLiBJbiBwcm90bzMsIHN1Y2ggZmllbGRzIGFyZVxuICAgICAqIHBhY2tlZCBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiTGVuZ3RoRGVsaW1pdGVkXCJdID0gMl0gPSBcIkxlbmd0aERlbGltaXRlZFwiO1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IG9mIGEgdGFnLWRlbGltaXRlZCBhZ2dyZWdhdGUsIHN1Y2ggYXMgYSBwcm90bzIgZ3JvdXAsIG9yIGEgbWVzc2FnZVxuICAgICAqIGluIGVkaXRpb25zIHdpdGggbWVzc2FnZV9lbmNvZGluZyA9IERFTElNSVRFRC5cbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIlN0YXJ0R3JvdXBcIl0gPSAzXSA9IFwiU3RhcnRHcm91cFwiO1xuICAgIC8qKlxuICAgICAqIEVuZCBvZiBhIHRhZy1kZWxpbWl0ZWQgYWdncmVnYXRlLlxuICAgICAqL1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiRW5kR3JvdXBcIl0gPSA0XSA9IFwiRW5kR3JvdXBcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBmaXhlZDMyLCBzZml4ZWQzMiwgZmxvYXQuXG4gICAgICogQWx3YXlzIDQgYnl0ZXMgd2l0aCBsaXR0bGUtZW5kaWFuIGJ5dGUgb3JkZXIuXG4gICAgICovXG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJCaXQzMlwiXSA9IDVdID0gXCJCaXQzMlwiO1xufSkoV2lyZVR5cGUgfHwgKFdpcmVUeXBlID0ge30pKTtcbmV4cG9ydCBjbGFzcyBCaW5hcnlXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRleHRFbmNvZGVyKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmV2aW91cyBmb3JrIHN0YXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy50ZXh0RW5jb2RlciA9IHRleHRFbmNvZGVyICE9PSBudWxsICYmIHRleHRFbmNvZGVyICE9PSB2b2lkIDAgPyB0ZXh0RW5jb2RlciA6IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZiA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIGJ5dGVzIHdyaXR0ZW4gYW5kIHJlc2V0IHRoaXMgd3JpdGVyLlxuICAgICAqL1xuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZikpOyAvLyBmbHVzaCB0aGUgYnVmZmVyXG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbGVuICs9IHRoaXMuY2h1bmtzW2ldLmxlbmd0aDtcbiAgICAgICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJ5dGVzLnNldCh0aGlzLmNodW5rc1tpXSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSB0aGlzLmNodW5rc1tpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBhIG5ldyBmb3JrIGZvciBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgbGlrZSBhIG1lc3NhZ2VcbiAgICAgKiBvciBhIHBhY2tlZCByZXBlYXRlZCBmaWVsZC5cbiAgICAgKlxuICAgICAqIE11c3QgYmUgam9pbmVkIGxhdGVyIHdpdGggYGpvaW4oKWAuXG4gICAgICovXG4gICAgZm9yaygpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHsgY2h1bmtzOiB0aGlzLmNodW5rcywgYnVmOiB0aGlzLmJ1ZiB9KTtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5idWYgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpvaW4gdGhlIGxhc3QgZm9yay4gV3JpdGUgaXRzIGxlbmd0aCBhbmQgYnl0ZXMsIHRoZW5cbiAgICAgKiByZXR1cm4gdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxuICAgICAqL1xuICAgIGpvaW4oKSB7XG4gICAgICAgIC8vIGdldCBjaHVuayBvZiBmb3JrXG4gICAgICAgIGxldCBjaHVuayA9IHRoaXMuZmluaXNoKCk7XG4gICAgICAgIC8vIHJlc3RvcmUgcHJldmlvdXMgc3RhdGVcbiAgICAgICAgbGV0IHByZXYgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoIXByZXYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHN0YXRlLCBmb3JrIHN0YWNrIGVtcHR5XCIpO1xuICAgICAgICB0aGlzLmNodW5rcyA9IHByZXYuY2h1bmtzO1xuICAgICAgICB0aGlzLmJ1ZiA9IHByZXYuYnVmO1xuICAgICAgICAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgICAgIHRoaXMudWludDMyKGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSB0YWcgKGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlKS5cbiAgICAgKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gYHVpbnQzMiggKGZpZWxkTm8gPDwgMyB8IHR5cGUpID4+PiAwIClgLlxuICAgICAqXG4gICAgICogR2VuZXJhdGVkIGNvZGUgc2hvdWxkIGNvbXB1dGUgdGhlIHRhZyBhaGVhZCBvZiB0aW1lIGFuZCBjYWxsIGB1aW50MzIoKWAuXG4gICAgICovXG4gICAgdGFnKGZpZWxkTm8sIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDMyKCgoZmllbGRObyA8PCAzKSB8IHR5cGUpID4+PiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBjaHVuayBvZiByYXcgYnl0ZXMuXG4gICAgICovXG4gICAgcmF3KGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IFVpbnQ4QXJyYXkodGhpcy5idWYpKTtcbiAgICAgICAgICAgIHRoaXMuYnVmID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGB1aW50MzJgIHZhbHVlLCBhbiB1bnNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHVpbnQzMih2YWx1ZSkge1xuICAgICAgICBhc3NlcnRVSW50MzIodmFsdWUpO1xuICAgICAgICAvLyB3cml0ZSB2YWx1ZSBhcyB2YXJpbnQgMzIsIGlubGluZWQgZm9yIHNwZWVkXG4gICAgICAgIHdoaWxlICh2YWx1ZSA+IDB4N2YpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmLnB1c2goKHZhbHVlICYgMHg3ZikgfCAweDgwKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4+IDc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWYucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBpbnQzMmAgdmFsdWUsIGEgc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgaW50MzIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgICAgICB2YXJpbnQzMndyaXRlKHZhbHVlLCB0aGlzLmJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBib29sYCB2YWx1ZSwgYSB2YXJpYW50LlxuICAgICAqL1xuICAgIGJvb2wodmFsdWUpIHtcbiAgICAgICAgdGhpcy5idWYucHVzaCh2YWx1ZSA/IDEgOiAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGJ5dGVzYCB2YWx1ZSwgbGVuZ3RoLWRlbGltaXRlZCBhcmJpdHJhcnkgZGF0YS5cbiAgICAgKi9cbiAgICBieXRlcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLnVpbnQzMih2YWx1ZS5ieXRlTGVuZ3RoKTsgLy8gd3JpdGUgbGVuZ3RoIG9mIGNodW5rIGFzIHZhcmludFxuICAgICAgICByZXR1cm4gdGhpcy5yYXcodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBzdHJpbmdgIHZhbHVlLCBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgY29udmVydGVkIHRvIFVURi04IHRleHQuXG4gICAgICovXG4gICAgc3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGxldCBjaHVuayA9IHRoaXMudGV4dEVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgdGhpcy51aW50MzIoY2h1bmsuYnl0ZUxlbmd0aCk7IC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgZmxvYXRgIHZhbHVlLCAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZsb2F0KHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEZsb2F0MzIodmFsdWUpO1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0RmxvYXQzMigwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGRvdWJsZWAgdmFsdWUsIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAgKi9cbiAgICBkb3VibGUodmFsdWUpIHtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEZsb2F0NjQoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBmaXhlZDMyYCB2YWx1ZSwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBmaXhlZDMyKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydFVJbnQzMih2YWx1ZSk7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRVaW50MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBzZml4ZWQzMmAgdmFsdWUsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgc2ZpeGVkMzIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0SW50MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBzaW50MzJgIHZhbHVlLCBhIHNpZ25lZCwgemlnemFnLWVuY29kZWQgMzItYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBzaW50MzIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgICAgICAvLyB6aWd6YWcgZW5jb2RlXG4gICAgICAgIHZhbHVlID0gKCh2YWx1ZSA8PCAxKSBeICh2YWx1ZSA+PiAzMSkpID4+PiAwO1xuICAgICAgICB2YXJpbnQzMndyaXRlKHZhbHVlLCB0aGlzLmJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBmaXhlZDY0YCB2YWx1ZSwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCA2NC1iaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBzZml4ZWQ2NCh2YWx1ZSkge1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg4KSwgdmlldyA9IG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLCB0YyA9IHByb3RvSW50NjQuZW5jKHZhbHVlKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0Yy5sbywgdHJ1ZSk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoNCwgdGMuaGksIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBmaXhlZDY0YCB2YWx1ZSwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCA2NCBiaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBmaXhlZDY0KHZhbHVlKSB7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpLCB2aWV3ID0gbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlciksIHRjID0gcHJvdG9JbnQ2NC51RW5jKHZhbHVlKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0Yy5sbywgdHJ1ZSk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoNCwgdGMuaGksIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBpbnQ2NGAgdmFsdWUsIGEgc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgaW50NjQodmFsdWUpIHtcbiAgICAgICAgbGV0IHRjID0gcHJvdG9JbnQ2NC5lbmModmFsdWUpO1xuICAgICAgICB2YXJpbnQ2NHdyaXRlKHRjLmxvLCB0Yy5oaSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgc2ludDY0YCB2YWx1ZSwgYSBzaWduZWQsIHppZy16YWctZW5jb2RlZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHNpbnQ2NCh2YWx1ZSkge1xuICAgICAgICBsZXQgdGMgPSBwcm90b0ludDY0LmVuYyh2YWx1ZSksIFxuICAgICAgICAvLyB6aWd6YWcgZW5jb2RlXG4gICAgICAgIHNpZ24gPSB0Yy5oaSA+PiAzMSwgbG8gPSAodGMubG8gPDwgMSkgXiBzaWduLCBoaSA9ICgodGMuaGkgPDwgMSkgfCAodGMubG8gPj4+IDMxKSkgXiBzaWduO1xuICAgICAgICB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgdWludDY0YCB2YWx1ZSwgYW4gdW5zaWduZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICB1aW50NjQodmFsdWUpIHtcbiAgICAgICAgbGV0IHRjID0gcHJvdG9JbnQ2NC51RW5jKHZhbHVlKTtcbiAgICAgICAgdmFyaW50NjR3cml0ZSh0Yy5sbywgdGMuaGksIHRoaXMuYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJpbmFyeVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IoYnVmLCB0ZXh0RGVjb2Rlcikge1xuICAgICAgICB0aGlzLnZhcmludDY0ID0gdmFyaW50NjRyZWFkOyAvLyBkaXJ0eSBjYXN0IGZvciBgdGhpc2BcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYWQgYSBgdWludDMyYCBmaWVsZCwgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudWludDMyID0gdmFyaW50MzJyZWFkOyAvLyBkaXJ0eSBjYXN0IGZvciBgdGhpc2AgYW5kIGFjY2VzcyB0byBwcm90ZWN0ZWQgYGJ1ZmBcbiAgICAgICAgdGhpcy5idWYgPSBidWY7XG4gICAgICAgIHRoaXMubGVuID0gYnVmLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdGhpcy50ZXh0RGVjb2RlciA9IHRleHREZWNvZGVyICE9PSBudWxsICYmIHRleHREZWNvZGVyICE9PSB2b2lkIDAgPyB0ZXh0RGVjb2RlciA6IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIHRhZyAtIGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlLlxuICAgICAqL1xuICAgIHRhZygpIHtcbiAgICAgICAgbGV0IHRhZyA9IHRoaXMudWludDMyKCksIGZpZWxkTm8gPSB0YWcgPj4+IDMsIHdpcmVUeXBlID0gdGFnICYgNztcbiAgICAgICAgaWYgKGZpZWxkTm8gPD0gMCB8fCB3aXJlVHlwZSA8IDAgfHwgd2lyZVR5cGUgPiA1KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0YWc6IGZpZWxkIG5vIFwiICsgZmllbGRObyArIFwiIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlKTtcbiAgICAgICAgcmV0dXJuIFtmaWVsZE5vLCB3aXJlVHlwZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNraXAgb25lIGVsZW1lbnQgYW5kIHJldHVybiB0aGUgc2tpcHBlZCBkYXRhLlxuICAgICAqXG4gICAgICogV2hlbiBza2lwcGluZyBTdGFydEdyb3VwLCBwcm92aWRlIHRoZSB0YWdzIGZpZWxkIG51bWJlciB0byBjaGVjayBmb3JcbiAgICAgKiBtYXRjaGluZyBmaWVsZCBudW1iZXIgaW4gdGhlIEVuZEdyb3VwIHRhZy5cbiAgICAgKi9cbiAgICBza2lwKHdpcmVUeXBlLCBmaWVsZE5vKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLlZhcmludDpcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLkJpdDY0OlxuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgICAgICAgY2FzZSBXaXJlVHlwZS5CaXQzMjpcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQ6XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMudWludDMyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gbGVuO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXaXJlVHlwZS5TdGFydEdyb3VwOlxuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2ZuLCB3dF0gPSB0aGlzLnRhZygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod3QgPT09IFdpcmVUeXBlLkVuZEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRObyAhPT0gdW5kZWZpbmVkICYmIGZuICE9PSBmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBlbmQgZ3JvdXAgdGFnXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwKHd0LCBmbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW50IHNraXAgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheShzdGFydCwgdGhpcy5wb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaHJvd3MgZXJyb3IgaWYgcG9zaXRpb24gaW4gYnl0ZSBhcnJheSBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICovXG4gICAgYXNzZXJ0Qm91bmRzKCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPiB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwicHJlbWF0dXJlIEVPRlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBpbnQzMmAgZmllbGQsIGEgc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgaW50MzIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpbnQzMigpIHwgMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBzaW50MzJgIGZpZWxkLCBhIHNpZ25lZCwgemlnemFnLWVuY29kZWQgMzItYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBzaW50MzIoKSB7XG4gICAgICAgIGxldCB6emUgPSB0aGlzLnVpbnQzMigpO1xuICAgICAgICAvLyBkZWNvZGUgemlnemFnXG4gICAgICAgIHJldHVybiAoenplID4+PiAxKSBeIC0oenplICYgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgaW50NjRgIGZpZWxkLCBhIHNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIGludDY0KCkge1xuICAgICAgICByZXR1cm4gcHJvdG9JbnQ2NC5kZWMoLi4udGhpcy52YXJpbnQ2NCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGB1aW50NjRgIGZpZWxkLCBhbiB1bnNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHVpbnQ2NCgpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvSW50NjQudURlYyguLi50aGlzLnZhcmludDY0KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHNpbnQ2NGAgZmllbGQsIGEgc2lnbmVkLCB6aWctemFnLWVuY29kZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBzaW50NjQoKSB7XG4gICAgICAgIGxldCBbbG8sIGhpXSA9IHRoaXMudmFyaW50NjQoKTtcbiAgICAgICAgLy8gZGVjb2RlIHppZyB6YWdcbiAgICAgICAgbGV0IHMgPSAtKGxvICYgMSk7XG4gICAgICAgIGxvID0gKChsbyA+Pj4gMSkgfCAoKGhpICYgMSkgPDwgMzEpKSBeIHM7XG4gICAgICAgIGhpID0gKGhpID4+PiAxKSBeIHM7XG4gICAgICAgIHJldHVybiBwcm90b0ludDY0LmRlYyhsbywgaGkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGJvb2xgIGZpZWxkLCBhIHZhcmlhbnQuXG4gICAgICovXG4gICAgYm9vbCgpIHtcbiAgICAgICAgbGV0IFtsbywgaGldID0gdGhpcy52YXJpbnQ2NCgpO1xuICAgICAgICByZXR1cm4gbG8gIT09IDAgfHwgaGkgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgZml4ZWQzMmAgZmllbGQsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgZml4ZWQzMigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRVaW50MzIoKHRoaXMucG9zICs9IDQpIC0gNCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgc2ZpeGVkMzJgIGZpZWxkLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIHNmaXhlZDMyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldEludDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGZpeGVkNjRgIGZpZWxkLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0IGJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGZpeGVkNjQoKSB7XG4gICAgICAgIHJldHVybiBwcm90b0ludDY0LnVEZWModGhpcy5zZml4ZWQzMigpLCB0aGlzLnNmaXhlZDMyKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGZpeGVkNjRgIGZpZWxkLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0LWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIHNmaXhlZDY0KCkge1xuICAgICAgICByZXR1cm4gcHJvdG9JbnQ2NC5kZWModGhpcy5zZml4ZWQzMigpLCB0aGlzLnNmaXhlZDMyKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGZsb2F0YCBmaWVsZCwgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAgKi9cbiAgICBmbG9hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRGbG9hdDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGRvdWJsZWAgZmllbGQsIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAgKi9cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0RmxvYXQ2NCgodGhpcy5wb3MgKz0gOCkgLSA4LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBieXRlc2AgZmllbGQsIGxlbmd0aC1kZWxpbWl0ZWQgYXJiaXRyYXJ5IGRhdGEuXG4gICAgICovXG4gICAgYnl0ZXMoKSB7XG4gICAgICAgIGxldCBsZW4gPSB0aGlzLnVpbnQzMigpLCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW47XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHN0cmluZ2AgZmllbGQsIGxlbmd0aC1kZWxpbWl0ZWQgZGF0YSBjb252ZXJ0ZWQgdG8gVVRGLTggdGV4dC5cbiAgICAgKi9cbiAgICBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHREZWNvZGVyLmRlY29kZSh0aGlzLmJ5dGVzKCkpO1xuICAgIH1cbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBzY2FsYXJaZXJvVmFsdWUgfSBmcm9tIFwiLi9zY2FsYXJzLmpzXCI7XG5pbXBvcnQgeyBXaXJlVHlwZSB9IGZyb20gXCIuLi9iaW5hcnktZW5jb2RpbmcuanNcIjtcbi8qKlxuICogQ3JlYXRlIGEgbmV3IGV4dGVuc2lvbiB1c2luZyB0aGUgZ2l2ZW4gcnVudGltZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFeHRlbnNpb24ocnVudGltZSwgdHlwZU5hbWUsIGV4dGVuZGVlLCBmaWVsZCkge1xuICAgIGxldCBmaTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZSxcbiAgICAgICAgZXh0ZW5kZWUsXG4gICAgICAgIGdldCBmaWVsZCgpIHtcbiAgICAgICAgICAgIGlmICghZmkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gKHR5cGVvZiBmaWVsZCA9PSBcImZ1bmN0aW9uXCIgPyBmaWVsZCgpIDogZmllbGQpO1xuICAgICAgICAgICAgICAgIGkubmFtZSA9IHR5cGVOYW1lLnNwbGl0KFwiLlwiKS5wb3AoKTtcbiAgICAgICAgICAgICAgICBpLmpzb25OYW1lID0gYFske3R5cGVOYW1lfV1gO1xuICAgICAgICAgICAgICAgIGZpID0gcnVudGltZS51dGlsLm5ld0ZpZWxkTGlzdChbaV0pLmxpc3QoKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaTtcbiAgICAgICAgfSxcbiAgICAgICAgcnVudGltZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBjb250YWluZXIgdGhhdCBhbGxvd3MgdXMgdG8gcmVhZCBleHRlbnNpb24gZmllbGRzIGludG8gaXQgd2l0aCB0aGVcbiAqIHNhbWUgbG9naWMgYXMgcmVndWxhciBmaWVsZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFeHRlbnNpb25Db250YWluZXIoZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgbG9jYWxOYW1lID0gZXh0ZW5zaW9uLmZpZWxkLmxvY2FsTmFtZTtcbiAgICBjb25zdCBjb250YWluZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnRhaW5lcltsb2NhbE5hbWVdID0gaW5pdEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbik7XG4gICAgcmV0dXJuIFtjb250YWluZXIsICgpID0+IGNvbnRhaW5lcltsb2NhbE5hbWVdXTtcbn1cbmZ1bmN0aW9uIGluaXRFeHRlbnNpb25GaWVsZChleHQpIHtcbiAgICBjb25zdCBmaWVsZCA9IGV4dC5maWVsZDtcbiAgICBpZiAoZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoZmllbGQuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmaWVsZC5kZWZhdWx0O1xuICAgIH1cbiAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIHJldHVybiBmaWVsZC5ULnZhbHVlc1swXS5ubztcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhclplcm9WYWx1ZShmaWVsZC5ULCBmaWVsZC5MKTtcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jYXNlLWRlY2xhcmF0aW9uc1xuICAgICAgICAgICAgY29uc3QgVCA9IGZpZWxkLlQsIHZhbHVlID0gbmV3IFQoKTtcbiAgICAgICAgICAgIHJldHVybiBULmZpZWxkV3JhcHBlciA/IFQuZmllbGRXcmFwcGVyLnVud3JhcEZpZWxkKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICB0aHJvdyBcIm1hcCBmaWVsZHMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIGV4dGVuc2lvbnNcIjtcbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciB0byBmaWx0ZXIgdW5rbm93biBmaWVsZHMsIG9wdGltaXplZCBiYXNlZCBvbiBmaWVsZCB0eXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyVW5rbm93bkZpZWxkcyh1bmtub3duRmllbGRzLCBmaWVsZCkge1xuICAgIGlmICghZmllbGQucmVwZWF0ZWQgJiYgKGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgfHwgZmllbGQua2luZCA9PSBcInNjYWxhclwiKSkge1xuICAgICAgICAvLyBzaW5ndWxhciBzY2FsYXIgZmllbGRzIGRvIG5vdCBtZXJnZSwgd2UgcGljayB0aGUgbGFzdFxuICAgICAgICBmb3IgKGxldCBpID0gdW5rbm93bkZpZWxkcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgaWYgKHVua25vd25GaWVsZHNbaV0ubm8gPT0gZmllbGQubm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3Vua25vd25GaWVsZHNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHVua25vd25GaWVsZHMuZmlsdGVyKCh1ZikgPT4gdWYubm8gPT09IGZpZWxkLm5vKTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24sIHByZWZlci1jb25zdCAqL1xuLy8gbG9va3VwIHRhYmxlIGZyb20gYmFzZTY0IGNoYXJhY3RlciB0byBieXRlXG5sZXQgZW5jVGFibGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIi5zcGxpdChcIlwiKTtcbi8vIGxvb2t1cCB0YWJsZSBmcm9tIGJhc2U2NCBjaGFyYWN0ZXIgKmNvZGUqIHRvIGJ5dGUgYmVjYXVzZSBsb29rdXAgYnkgbnVtYmVyIGlzIGZhc3RcbmxldCBkZWNUYWJsZSA9IFtdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNUYWJsZS5sZW5ndGg7IGkrKylcbiAgICBkZWNUYWJsZVtlbmNUYWJsZVtpXS5jaGFyQ29kZUF0KDApXSA9IGk7XG4vLyBzdXBwb3J0IGJhc2U2NHVybCB2YXJpYW50c1xuZGVjVGFibGVbXCItXCIuY2hhckNvZGVBdCgwKV0gPSBlbmNUYWJsZS5pbmRleE9mKFwiK1wiKTtcbmRlY1RhYmxlW1wiX1wiLmNoYXJDb2RlQXQoMCldID0gZW5jVGFibGUuaW5kZXhPZihcIi9cIik7XG5leHBvcnQgY29uc3QgcHJvdG9CYXNlNjQgPSB7XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIGJhc2U2NCBzdHJpbmcgdG8gYSBieXRlIGFycmF5LlxuICAgICAqXG4gICAgICogLSBpZ25vcmVzIHdoaXRlLXNwYWNlLCBpbmNsdWRpbmcgbGluZSBicmVha3MgYW5kIHRhYnNcbiAgICAgKiAtIGFsbG93cyBpbm5lciBwYWRkaW5nIChjYW4gZGVjb2RlIGNvbmNhdGVuYXRlZCBiYXNlNjQgc3RyaW5ncylcbiAgICAgKiAtIGRvZXMgbm90IHJlcXVpcmUgcGFkZGluZ1xuICAgICAqIC0gdW5kZXJzdGFuZHMgYmFzZTY0dXJsIGVuY29kaW5nOlxuICAgICAqICAgXCItXCIgaW5zdGVhZCBvZiBcIitcIixcbiAgICAgKiAgIFwiX1wiIGluc3RlYWQgb2YgXCIvXCIsXG4gICAgICogICBubyBwYWRkaW5nXG4gICAgICovXG4gICAgZGVjKGJhc2U2NFN0cikge1xuICAgICAgICAvLyBlc3RpbWF0ZSBieXRlIHNpemUsIG5vdCBhY2NvdW50aW5nIGZvciBpbm5lciBwYWRkaW5nIGFuZCB3aGl0ZXNwYWNlXG4gICAgICAgIGxldCBlcyA9IChiYXNlNjRTdHIubGVuZ3RoICogMykgLyA0O1xuICAgICAgICBpZiAoYmFzZTY0U3RyW2Jhc2U2NFN0ci5sZW5ndGggLSAyXSA9PSBcIj1cIilcbiAgICAgICAgICAgIGVzIC09IDI7XG4gICAgICAgIGVsc2UgaWYgKGJhc2U2NFN0cltiYXNlNjRTdHIubGVuZ3RoIC0gMV0gPT0gXCI9XCIpXG4gICAgICAgICAgICBlcyAtPSAxO1xuICAgICAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShlcyksIGJ5dGVQb3MgPSAwLCAvLyBwb3NpdGlvbiBpbiBieXRlIGFycmF5XG4gICAgICAgIGdyb3VwUG9zID0gMCwgLy8gcG9zaXRpb24gaW4gYmFzZTY0IGdyb3VwXG4gICAgICAgIGIsIC8vIGN1cnJlbnQgYnl0ZVxuICAgICAgICBwID0gMDsgLy8gcHJldmlvdXMgYnl0ZVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2U2NFN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYiA9IGRlY1RhYmxlW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgICAgIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGJhc2U2NFN0cltpXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMDsgLy8gcmVzZXQgc3RhdGUgd2hlbiBwYWRkaW5nIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlxcdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHNraXAgd2hpdGUtc3BhY2UsIGFuZCBwYWRkaW5nXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgYmFzZTY0IHN0cmluZy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChncm91cFBvcykge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcCA9IGI7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gKHAgPDwgMikgfCAoKGIgJiA0OCkgPj4gNCk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBiO1xuICAgICAgICAgICAgICAgICAgICBncm91cFBvcyA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNbYnl0ZVBvcysrXSA9ICgocCAmIDE1KSA8PCA0KSB8ICgoYiAmIDYwKSA+PiAyKTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGI7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gKChwICYgMykgPDwgNikgfCBiO1xuICAgICAgICAgICAgICAgICAgICBncm91cFBvcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cFBvcyA9PSAxKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGJhc2U2NCBzdHJpbmcuXCIpO1xuICAgICAgICByZXR1cm4gYnl0ZXMuc3ViYXJyYXkoMCwgYnl0ZVBvcyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmNvZGUgYSBieXRlIGFycmF5IHRvIGEgYmFzZTY0IHN0cmluZy5cbiAgICAgKi9cbiAgICBlbmMoYnl0ZXMpIHtcbiAgICAgICAgbGV0IGJhc2U2NCA9IFwiXCIsIGdyb3VwUG9zID0gMCwgLy8gcG9zaXRpb24gaW4gYmFzZTY0IGdyb3VwXG4gICAgICAgIGIsIC8vIGN1cnJlbnQgYnl0ZVxuICAgICAgICBwID0gMDsgLy8gY2Fycnkgb3ZlciBmcm9tIHByZXZpb3VzIGJ5dGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYiA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgc3dpdGNoIChncm91cFBvcykge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW2IgPj4gMl07XG4gICAgICAgICAgICAgICAgICAgIHAgPSAoYiAmIDMpIDw8IDQ7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcCB8IChiID4+IDQpXTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IChiICYgMTUpIDw8IDI7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcCB8IChiID4+IDYpXTtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW2IgJiA2M107XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIG91dHB1dCBwYWRkaW5nXG4gICAgICAgIGlmIChncm91cFBvcykge1xuICAgICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW3BdO1xuICAgICAgICAgICAgYmFzZTY0ICs9IFwiPVwiO1xuICAgICAgICAgICAgaWYgKGdyb3VwUG9zID09IDEpXG4gICAgICAgICAgICAgICAgYmFzZTY0ICs9IFwiPVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfSxcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4vcHJpdmF0ZS9hc3NlcnQuanNcIjtcbmltcG9ydCB7IGNyZWF0ZUV4dGVuc2lvbkNvbnRhaW5lciwgZmlsdGVyVW5rbm93bkZpZWxkcywgfSBmcm9tIFwiLi9wcml2YXRlL2V4dGVuc2lvbnMuanNcIjtcbi8qKlxuICogUmV0cmlldmUgYW4gZXh0ZW5zaW9uIHZhbHVlIGZyb20gYSBtZXNzYWdlLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBuZXZlciByZXR1cm5zIHVuZGVmaW5lZC4gVXNlIGhhc0V4dGVuc2lvbigpIHRvIGNoZWNrIHdoZXRoZXIgYW5cbiAqIGV4dGVuc2lvbiBpcyBzZXQuIElmIHRoZSBleHRlbnNpb24gaXMgbm90IHNldCwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZVxuICogZGVmYXVsdCB2YWx1ZSAoaWYgb25lIHdhcyBzcGVjaWZpZWQgaW4gdGhlIHByb3RvYnVmIHNvdXJjZSksIG9yIHRoZSB6ZXJvIHZhbHVlXG4gKiAoZm9yIGV4YW1wbGUgYDBgIGZvciBudW1lcmljIHR5cGVzLCBgW11gIGZvciByZXBlYXRlZCBleHRlbnNpb24gZmllbGRzLCBhbmRcbiAqIGFuIGVtcHR5IG1lc3NhZ2UgaW5zdGFuY2UgZm9yIG1lc3NhZ2UgZmllbGRzKS5cbiAqXG4gKiBFeHRlbnNpb25zIGFyZSBzdG9yZWQgYXMgdW5rbm93biBmaWVsZHMgb24gYSBtZXNzYWdlLiBUbyBtdXRhdGUgYW4gZXh0ZW5zaW9uXG4gKiB2YWx1ZSwgbWFrZSBzdXJlIHRvIHN0b3JlIHRoZSBuZXcgdmFsdWUgd2l0aCBzZXRFeHRlbnNpb24oKSBhZnRlciBtdXRhdGluZy5cbiAqXG4gKiBJZiB0aGUgZXh0ZW5zaW9uIGRvZXMgbm90IGV4dGVuZCB0aGUgZ2l2ZW4gbWVzc2FnZSwgYW4gZXJyb3IgaXMgcmFpc2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dGVuc2lvbiwgb3B0aW9ucykge1xuICAgIGFzc2VydEV4dGVuZGVlKGV4dGVuc2lvbiwgbWVzc2FnZSk7XG4gICAgY29uc3Qgb3B0ID0gZXh0ZW5zaW9uLnJ1bnRpbWUuYmluLm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCB1ZnMgPSBmaWx0ZXJVbmtub3duRmllbGRzKG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluLmxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpLCBleHRlbnNpb24uZmllbGQpO1xuICAgIGNvbnN0IFtjb250YWluZXIsIGdldF0gPSBjcmVhdGVFeHRlbnNpb25Db250YWluZXIoZXh0ZW5zaW9uKTtcbiAgICBmb3IgKGNvbnN0IHVmIG9mIHVmcykge1xuICAgICAgICBleHRlbnNpb24ucnVudGltZS5iaW4ucmVhZEZpZWxkKGNvbnRhaW5lciwgb3B0LnJlYWRlckZhY3RvcnkodWYuZGF0YSksIGV4dGVuc2lvbi5maWVsZCwgdWYud2lyZVR5cGUsIG9wdCk7XG4gICAgfVxuICAgIHJldHVybiBnZXQoKTtcbn1cbi8qKlxuICogU2V0IGFuIGV4dGVuc2lvbiB2YWx1ZSBvbiBhIG1lc3NhZ2UuIElmIHRoZSBtZXNzYWdlIGFscmVhZHkgaGFzIGEgdmFsdWUgZm9yXG4gKiB0aGlzIGV4dGVuc2lvbiwgdGhlIHZhbHVlIGlzIHJlcGxhY2VkLlxuICpcbiAqIElmIHRoZSBleHRlbnNpb24gZG9lcyBub3QgZXh0ZW5kIHRoZSBnaXZlbiBtZXNzYWdlLCBhbiBlcnJvciBpcyByYWlzZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRFeHRlbnNpb24obWVzc2FnZSwgZXh0ZW5zaW9uLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGFzc2VydEV4dGVuZGVlKGV4dGVuc2lvbiwgbWVzc2FnZSk7XG4gICAgY29uc3QgcmVhZE9wdCA9IGV4dGVuc2lvbi5ydW50aW1lLmJpbi5tYWtlUmVhZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3Qgd3JpdGVPcHQgPSBleHRlbnNpb24ucnVudGltZS5iaW4ubWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICBpZiAoaGFzRXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dGVuc2lvbikpIHtcbiAgICAgICAgY29uc3QgdWZzID0gbWVzc2FnZVxuICAgICAgICAgICAgLmdldFR5cGUoKVxuICAgICAgICAgICAgLnJ1bnRpbWUuYmluLmxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpXG4gICAgICAgICAgICAuZmlsdGVyKCh1ZikgPT4gdWYubm8gIT0gZXh0ZW5zaW9uLmZpZWxkLm5vKTtcbiAgICAgICAgbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW4uZGlzY2FyZFVua25vd25GaWVsZHMobWVzc2FnZSk7XG4gICAgICAgIGZvciAoY29uc3QgdWYgb2YgdWZzKSB7XG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICAgICAgLmdldFR5cGUoKVxuICAgICAgICAgICAgICAgIC5ydW50aW1lLmJpbi5vblVua25vd25GaWVsZChtZXNzYWdlLCB1Zi5ubywgdWYud2lyZVR5cGUsIHVmLmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHdyaXRlciA9IHdyaXRlT3B0LndyaXRlckZhY3RvcnkoKTtcbiAgICBsZXQgZiA9IGV4dGVuc2lvbi5maWVsZDtcbiAgICAvLyBJbXBsaWNpdCBwcmVzZW5jZSBkb2VzIG5vdCBhcHBseSB0byBleHRlbnNpb25zLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9pc3N1ZXMvODIzNFxuICAgIC8vIFdlIHBhdGNoIHRoZSBmaWVsZCBpbmZvIHRvIHVzZSBleHBsaWNpdCBwcmVzZW5jZTpcbiAgICBpZiAoIWYub3B0ICYmICFmLnJlcGVhdGVkICYmIChmLmtpbmQgPT0gXCJlbnVtXCIgfHwgZi5raW5kID09IFwic2NhbGFyXCIpKSB7XG4gICAgICAgIGYgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dGVuc2lvbi5maWVsZCksIHsgb3B0OiB0cnVlIH0pO1xuICAgIH1cbiAgICBleHRlbnNpb24ucnVudGltZS5iaW4ud3JpdGVGaWVsZChmLCB2YWx1ZSwgd3JpdGVyLCB3cml0ZU9wdCk7XG4gICAgY29uc3QgcmVhZGVyID0gcmVhZE9wdC5yZWFkZXJGYWN0b3J5KHdyaXRlci5maW5pc2goKSk7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCByZWFkZXIubGVuKSB7XG4gICAgICAgIGNvbnN0IFtubywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICBjb25zdCBkYXRhID0gcmVhZGVyLnNraXAod2lyZVR5cGUsIG5vKTtcbiAgICAgICAgbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW4ub25Vbmtub3duRmllbGQobWVzc2FnZSwgbm8sIHdpcmVUeXBlLCBkYXRhKTtcbiAgICB9XG59XG4vKipcbiAqIFJlbW92ZSBhbiBleHRlbnNpb24gdmFsdWUgZnJvbSBhIG1lc3NhZ2UuXG4gKlxuICogSWYgdGhlIGV4dGVuc2lvbiBkb2VzIG5vdCBleHRlbmQgdGhlIGdpdmVuIG1lc3NhZ2UsIGFuIGVycm9yIGlzIHJhaXNlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyRXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dGVuc2lvbikge1xuICAgIGFzc2VydEV4dGVuZGVlKGV4dGVuc2lvbiwgbWVzc2FnZSk7XG4gICAgaWYgKGhhc0V4dGVuc2lvbihtZXNzYWdlLCBleHRlbnNpb24pKSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluO1xuICAgICAgICBjb25zdCB1ZnMgPSBiaW5cbiAgICAgICAgICAgIC5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKVxuICAgICAgICAgICAgLmZpbHRlcigodWYpID0+IHVmLm5vICE9IGV4dGVuc2lvbi5maWVsZC5ubyk7XG4gICAgICAgIGJpbi5kaXNjYXJkVW5rbm93bkZpZWxkcyhtZXNzYWdlKTtcbiAgICAgICAgZm9yIChjb25zdCB1ZiBvZiB1ZnMpIHtcbiAgICAgICAgICAgIGJpbi5vblVua25vd25GaWVsZChtZXNzYWdlLCB1Zi5ubywgdWYud2lyZVR5cGUsIHVmLmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIGV4dGVuc2lvbiBpcyBzZXQgb24gYSBtZXNzYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzRXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dGVuc2lvbikge1xuICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgcmV0dXJuIChleHRlbnNpb24uZXh0ZW5kZWUudHlwZU5hbWUgPT09IG1lc3NhZ2VUeXBlLnR5cGVOYW1lICYmXG4gICAgICAgICEhbWVzc2FnZVR5cGUucnVudGltZS5iaW5cbiAgICAgICAgICAgIC5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKVxuICAgICAgICAgICAgLmZpbmQoKHVmKSA9PiB1Zi5ubyA9PSBleHRlbnNpb24uZmllbGQubm8pKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEV4dGVuZGVlKGV4dGVuc2lvbiwgbWVzc2FnZSkge1xuICAgIGFzc2VydChleHRlbnNpb24uZXh0ZW5kZWUudHlwZU5hbWUgPT0gbWVzc2FnZS5nZXRUeXBlKCkudHlwZU5hbWUsIGBleHRlbnNpb24gJHtleHRlbnNpb24udHlwZU5hbWV9IGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gbWVzc2FnZSAke2V4dGVuc2lvbi5leHRlbmRlZS50eXBlTmFtZX1gKTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBpc1NjYWxhclplcm9WYWx1ZSwgc2NhbGFyWmVyb1ZhbHVlIH0gZnJvbSBcIi4vc2NhbGFycy5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZpZWxkIGlzIHNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRmllbGRTZXQoZmllbGQsIHRhcmdldCkge1xuICAgIGNvbnN0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgICBpZiAoZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFtsb2NhbE5hbWVdLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICByZXR1cm4gdGFyZ2V0W2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV0uY2FzZSA9PT0gbG9jYWxOYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgIH1cbiAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgaWYgKGZpZWxkLm9wdCB8fCBmaWVsZC5yZXEpIHtcbiAgICAgICAgICAgICAgICAvLyBleHBsaWNpdCBwcmVzZW5jZVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbbG9jYWxOYW1lXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW1wbGljaXQgcHJlc2VuY2VcbiAgICAgICAgICAgIGlmIChmaWVsZC5raW5kID09IFwiZW51bVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtsb2NhbE5hbWVdICE9PSBmaWVsZC5ULnZhbHVlc1swXS5ubztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhaXNTY2FsYXJaZXJvVmFsdWUoZmllbGQuVCwgdGFyZ2V0W2xvY2FsTmFtZV0pO1xuICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtsb2NhbE5hbWVdICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXRbbG9jYWxOYW1lXSkubGVuZ3RoID4gMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgfVxufVxuLyoqXG4gKiBSZXNldHMgdGhlIGZpZWxkLCBzbyB0aGF0IGlzRmllbGRTZXQoKSB3aWxsIHJldHVybiBmYWxzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyRmllbGQoZmllbGQsIHRhcmdldCkge1xuICAgIGNvbnN0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgICBjb25zdCBpbXBsaWNpdFByZXNlbmNlID0gIWZpZWxkLm9wdCAmJiAhZmllbGQucmVxO1xuICAgIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IFtdO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXSA9IHsgY2FzZTogdW5kZWZpbmVkIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHt9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGltcGxpY2l0UHJlc2VuY2UgPyBmaWVsZC5ULnZhbHVlc1swXS5ubyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGltcGxpY2l0UHJlc2VuY2VcbiAgICAgICAgICAgICAgICAgICAgPyBzY2FsYXJaZXJvVmFsdWUoZmllbGQuVCwgZmllbGQuTClcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IE1lc3NhZ2UgfSBmcm9tIFwiLi9tZXNzYWdlLmpzXCI7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhbnkgc3VidHlwZSBvZiBNZXNzYWdlIG9yIGlzIGEgc3BlY2lmaWNcbiAqIE1lc3NhZ2UgYnkgcGFzc2luZyB0aGUgdHlwZS5cbiAqXG4gKiBKdXN0IGxpa2UgYGluc3RhbmNlb2ZgLCBgaXNNZXNzYWdlYCBuYXJyb3dzIHRoZSB0eXBlLiBUaGUgYWR2YW50YWdlIG9mXG4gKiBgaXNNZXNzYWdlYCBpcyB0aGF0IGl0IGNvbXBhcmVzIGlkZW50aXR5IGJ5IHRoZSBtZXNzYWdlIHR5cGUgbmFtZSwgbm90IGJ5XG4gKiBjbGFzcyBpZGVudGl0eS4gVGhpcyBtYWtlcyBpdCByb2J1c3QgYWdhaW5zdCB0aGUgZHVhbCBwYWNrYWdlIGhhemFyZCBhbmRcbiAqIHNpbWlsYXIgc2l0dWF0aW9ucywgd2hlcmUgdGhlIHNhbWUgbWVzc2FnZSBpcyBkdXBsaWNhdGVkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgX21vc3RseV8gZXF1aXZhbGVudCB0byB0aGUgYGluc3RhbmNlb2ZgIG9wZXJhdG9yLiBGb3JcbiAqIGV4YW1wbGUsIGBpc01lc3NhZ2UoZm9vLCBNeU1lc3NhZ2UpYCBpcyB0aGUgc2FtZSBhcyBgZm9vIGluc3RhbmNlb2YgTXlNZXNzYWdlYCxcbiAqIGFuZCBgaXNNZXNzYWdlKGZvbylgIGlzIHRoZSBzYW1lIGFzIGBmb28gaW5zdGFuY2VvZiBNZXNzYWdlYC4gSW4gbW9zdCBjYXNlcyxcbiAqIGBpc01lc3NhZ2VgIHNob3VsZCBiZSBwcmVmZXJyZWQgb3ZlciBgaW5zdGFuY2VvZmAuXG4gKlxuICogSG93ZXZlciwgZHVlIHRvIHRoZSBmYWN0IHRoYXQgYGlzTWVzc2FnZWAgZG9lcyBub3QgdXNlIGNsYXNzIGlkZW50aXR5LCB0aGVyZVxuICogYXJlIHN1YnRsZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoaXMgZnVuY3Rpb24gYW5kIGBpbnN0YW5jZW9mYC4gTm90YWJseSxcbiAqIGNhbGxpbmcgYGlzTWVzc2FnZWAgb24gYW4gZXhwbGljaXQgdHlwZSBvZiBNZXNzYWdlIHdpbGwgcmV0dXJuIGZhbHNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNNZXNzYWdlKGFyZywgdHlwZSkge1xuICAgIGlmIChhcmcgPT09IG51bGwgfHwgdHlwZW9mIGFyZyAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNZXNzYWdlLnByb3RvdHlwZSkuZXZlcnkoKG0pID0+IG0gaW4gYXJnICYmIHR5cGVvZiBhcmdbbV0gPT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFjdHVhbFR5cGUgPSBhcmcuZ2V0VHlwZSgpO1xuICAgIGlmIChhY3R1YWxUeXBlID09PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiBhY3R1YWxUeXBlICE9IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgICAhKFwidHlwZU5hbWVcIiBpbiBhY3R1YWxUeXBlKSB8fFxuICAgICAgICB0eXBlb2YgYWN0dWFsVHlwZS50eXBlTmFtZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhY3R1YWxUeXBlLnR5cGVOYW1lID09IHR5cGUudHlwZU5hbWU7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgTWVzc2FnZSB9IGZyb20gXCIuLi9tZXNzYWdlLmpzXCI7XG5pbXBvcnQgeyBTY2FsYXJUeXBlIH0gZnJvbSBcIi4uL3NjYWxhci5qc1wiO1xuaW1wb3J0IHsgaXNNZXNzYWdlIH0gZnJvbSBcIi4uL2lzLW1lc3NhZ2UuanNcIjtcbi8qKlxuICogV3JhcCBhIHByaW1pdGl2ZSBtZXNzYWdlIGZpZWxkIHZhbHVlIGluIGl0cyBjb3JyZXNwb25kaW5nIHdyYXBwZXJcbiAqIG1lc3NhZ2UuIFRoaXMgZnVuY3Rpb24gaXMgaWRlbXBvdGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBGaWVsZCh0eXBlLCB2YWx1ZSkge1xuICAgIGlmIChpc01lc3NhZ2UodmFsdWUpIHx8ICF0eXBlLmZpZWxkV3JhcHBlcikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlLmZpZWxkV3JhcHBlci53cmFwRmllbGQodmFsdWUpO1xufVxuLyoqXG4gKiBJZiB0aGUgZ2l2ZW4gZmllbGQgdXNlcyBvbmUgb2YgdGhlIHdlbGwta25vd24gd3JhcHBlciB0eXBlcywgcmV0dXJuXG4gKiB0aGUgcHJpbWl0aXZlIHR5cGUgaXQgd3JhcHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbndyYXBwZWRGaWVsZFR5cGUoZmllbGQpIHtcbiAgICBpZiAoZmllbGQuZmllbGRLaW5kICE9PSBcIm1lc3NhZ2VcIikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGZpZWxkLm9uZW9mICE9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gd2t0V3JhcHBlclRvU2NhbGFyVHlwZVtmaWVsZC5tZXNzYWdlLnR5cGVOYW1lXTtcbn1cbmNvbnN0IHdrdFdyYXBwZXJUb1NjYWxhclR5cGUgPSB7XG4gICAgXCJnb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWVcIjogU2NhbGFyVHlwZS5ET1VCTEUsXG4gICAgXCJnb29nbGUucHJvdG9idWYuRmxvYXRWYWx1ZVwiOiBTY2FsYXJUeXBlLkZMT0FULFxuICAgIFwiZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWVcIjogU2NhbGFyVHlwZS5JTlQ2NCxcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5VSW50NjRWYWx1ZVwiOiBTY2FsYXJUeXBlLlVJTlQ2NCxcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlXCI6IFNjYWxhclR5cGUuSU5UMzIsXG4gICAgXCJnb29nbGUucHJvdG9idWYuVUludDMyVmFsdWVcIjogU2NhbGFyVHlwZS5VSU5UMzIsXG4gICAgXCJnb29nbGUucHJvdG9idWYuQm9vbFZhbHVlXCI6IFNjYWxhclR5cGUuQk9PTCxcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5TdHJpbmdWYWx1ZVwiOiBTY2FsYXJUeXBlLlNUUklORyxcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5CeXRlc1ZhbHVlXCI6IFNjYWxhclR5cGUuQllURVMsXG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IE1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRGbG9hdDMyLCBhc3NlcnRJbnQzMiwgYXNzZXJ0VUludDMyIH0gZnJvbSBcIi4vYXNzZXJ0LmpzXCI7XG5pbXBvcnQgeyBwcm90b0ludDY0IH0gZnJvbSBcIi4uL3Byb3RvLWludDY0LmpzXCI7XG5pbXBvcnQgeyBwcm90b0Jhc2U2NCB9IGZyb20gXCIuLi9wcm90by1iYXNlNjQuanNcIjtcbmltcG9ydCB7IGNyZWF0ZUV4dGVuc2lvbkNvbnRhaW5lciB9IGZyb20gXCIuL2V4dGVuc2lvbnMuanNcIjtcbmltcG9ydCB7IGdldEV4dGVuc2lvbiwgaGFzRXh0ZW5zaW9uLCBzZXRFeHRlbnNpb24sIH0gZnJvbSBcIi4uL2V4dGVuc2lvbi1hY2Nlc3Nvci5qc1wiO1xuaW1wb3J0IHsgY2xlYXJGaWVsZCwgaXNGaWVsZFNldCB9IGZyb20gXCIuL3JlZmxlY3QuanNcIjtcbmltcG9ydCB7IHdyYXBGaWVsZCB9IGZyb20gXCIuL2ZpZWxkLXdyYXBwZXIuanNcIjtcbmltcG9ydCB7IHNjYWxhclplcm9WYWx1ZSB9IGZyb20gXCIuL3NjYWxhcnMuanNcIjtcbmltcG9ydCB7IGlzU2NhbGFyWmVyb1ZhbHVlIH0gZnJvbSBcIi4vc2NhbGFycy5qc1wiO1xuaW1wb3J0IHsgTG9uZ1R5cGUsIFNjYWxhclR5cGUgfSBmcm9tIFwiLi4vc2NhbGFyLmpzXCI7XG5pbXBvcnQgeyBpc01lc3NhZ2UgfSBmcm9tIFwiLi4vaXMtbWVzc2FnZS5qc1wiO1xuLyogZXNsaW50LWRpc2FibGUgbm8tY2FzZS1kZWNsYXJhdGlvbnMsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbCAqL1xuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBwYXJzaW5nIEpTT04uXG5jb25zdCBqc29uUmVhZERlZmF1bHRzID0ge1xuICAgIGlnbm9yZVVua25vd25GaWVsZHM6IGZhbHNlLFxufTtcbi8vIERlZmF1bHQgb3B0aW9ucyBmb3Igc2VyaWFsaXppbmcgdG8gSlNPTi5cbmNvbnN0IGpzb25Xcml0ZURlZmF1bHRzID0ge1xuICAgIGVtaXREZWZhdWx0VmFsdWVzOiBmYWxzZSxcbiAgICBlbnVtQXNJbnRlZ2VyOiBmYWxzZSxcbiAgICB1c2VQcm90b0ZpZWxkTmFtZTogZmFsc2UsXG4gICAgcHJldHR5U3BhY2VzOiAwLFxufTtcbmZ1bmN0aW9uIG1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGpzb25SZWFkRGVmYXVsdHMpLCBvcHRpb25zKSA6IGpzb25SZWFkRGVmYXVsdHM7XG59XG5mdW5jdGlvbiBtYWtlV3JpdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwganNvbldyaXRlRGVmYXVsdHMpLCBvcHRpb25zKSA6IGpzb25Xcml0ZURlZmF1bHRzO1xufVxuY29uc3QgdG9rZW5OdWxsID0gU3ltYm9sKCk7XG5jb25zdCB0b2tlbklnbm9yZWRVbmtub3duRW51bSA9IFN5bWJvbCgpO1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VKc29uRm9ybWF0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1ha2VSZWFkT3B0aW9ucyxcbiAgICAgICAgbWFrZVdyaXRlT3B0aW9ucyxcbiAgICAgICAgcmVhZE1lc3NhZ2UodHlwZSwganNvbiwgb3B0aW9ucywgbWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKGpzb24gPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGpzb24pIHx8IHR5cGVvZiBqc29uICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgbWVzc2FnZSAke3R5cGUudHlwZU5hbWV9IGZyb20gSlNPTjogJHtkZWJ1Z0pzb25WYWx1ZShqc29uKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBuZXcgdHlwZSgpO1xuICAgICAgICAgICAgY29uc3Qgb25lb2ZTZWVuID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgY29uc3QgcmVnaXN0cnkgPSBvcHRpb25zLnR5cGVSZWdpc3RyeTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2pzb25LZXksIGpzb25WYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoanNvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IHR5cGUuZmllbGRzLmZpbmRKc29uTmFtZShqc29uS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsICYmIGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlZSBjb25mb3JtYW5jZSB0ZXN0IFJlcXVpcmVkLlByb3RvMy5Kc29uSW5wdXQuT25lb2ZGaWVsZE51bGx7Rmlyc3QsU2Vjb25kfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VlbiA9IG9uZW9mU2Vlbi5nZXQoZmllbGQub25lb2YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBtZXNzYWdlICR7dHlwZS50eXBlTmFtZX0gZnJvbSBKU09OOiBtdWx0aXBsZSBrZXlzIGZvciBvbmVvZiBcIiR7ZmllbGQub25lb2YubmFtZX1cIiBwcmVzZW50OiBcIiR7c2Vlbn1cIiwgXCIke2pzb25LZXl9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mU2Vlbi5zZXQoZmllbGQub25lb2YsIGpzb25LZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlYWRGaWVsZChtZXNzYWdlLCBqc29uVmFsdWUsIGZpZWxkLCBvcHRpb25zLCB0eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHJlZ2lzdHJ5ID09PSBudWxsIHx8IHJlZ2lzdHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWdpc3RyeS5maW5kRXh0ZW5zaW9uKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAganNvbktleS5zdGFydHNXaXRoKFwiW1wiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAganNvbktleS5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dCA9IHJlZ2lzdHJ5LmZpbmRFeHRlbnNpb24oanNvbktleS5zdWJzdHJpbmcoMSwganNvbktleS5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ICYmIGV4dC5leHRlbmRlZS50eXBlTmFtZSA9PSB0eXBlLnR5cGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtjb250YWluZXIsIGdldF0gPSBjcmVhdGVFeHRlbnNpb25Db250YWluZXIoZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkRmllbGQoY29udGFpbmVyLCBqc29uVmFsdWUsIGV4dC5maWVsZCwgb3B0aW9ucywgZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBwYXNzIG9uIHRoZSBvcHRpb25zIGFzIEJpbmFyeVJlYWRPcHRpb25zL0JpbmFyeVdyaXRlT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IHVzZXJzIGNhbiBicmluZyB0aGVpciBvd24gYmluYXJ5IHJlYWRlciBhbmQgd3JpdGVyIGZhY3Rvcmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFeHRlbnNpb24obWVzc2FnZSwgZXh0LCBnZXQoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCAmJiAhb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgbWVzc2FnZSAke3R5cGUudHlwZU5hbWV9IGZyb20gSlNPTjoga2V5IFwiJHtqc29uS2V5fVwiIGlzIHVua25vd25gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgY29uc3QganNvbiA9IHt9O1xuICAgICAgICAgICAgbGV0IGZpZWxkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKGZpZWxkIG9mIHR5cGUuZmllbGRzLmJ5TnVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0ZpZWxkU2V0KGZpZWxkLCBtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLnJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGByZXF1aXJlZCBmaWVsZCBub3Qgc2V0YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5FbWl0RmllbGREZWZhdWx0VmFsdWUoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5vbmVvZlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtZXNzYWdlW2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV0udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbWVzc2FnZVtmaWVsZC5sb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uVmFsdWUgPSB3cml0ZUZpZWxkKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbltvcHRpb25zLnVzZVByb3RvRmllbGROYW1lID8gZmllbGQubmFtZSA6IGZpZWxkLmpzb25OYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvblZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gb3B0aW9ucy50eXBlUmVnaXN0cnk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lzdHJ5ID09PSBudWxsIHx8IHJlZ2lzdHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWdpc3RyeS5maW5kRXh0ZW5zaW9uRm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdWYgb2YgdHlwZS5ydW50aW1lLmJpbi5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0ID0gcmVnaXN0cnkuZmluZEV4dGVuc2lvbkZvcih0eXBlLnR5cGVOYW1lLCB1Zi5ubyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ICYmIGhhc0V4dGVuc2lvbihtZXNzYWdlLCBleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgcGFzcyBvbiB0aGUgb3B0aW9ucyBhcyBCaW5hcnlSZWFkT3B0aW9ucywgc28gdGhhdCB1c2VycyBjYW4gYnJpbmcgdGhlaXIgb3duXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmluYXJ5IHJlYWRlciBmYWN0b3J5IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEV4dGVuc2lvbihtZXNzYWdlLCBleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzb25WYWx1ZSA9IHdyaXRlRmllbGQoZXh0LmZpZWxkLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25bZXh0LmZpZWxkLmpzb25OYW1lXSA9IGpzb25WYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBmaWVsZFxuICAgICAgICAgICAgICAgICAgICA/IGBjYW5ub3QgZW5jb2RlIGZpZWxkICR7dHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSB0byBKU09OYFxuICAgICAgICAgICAgICAgICAgICA6IGBjYW5ub3QgZW5jb2RlIG1lc3NhZ2UgJHt0eXBlLnR5cGVOYW1lfSB0byBKU09OYDtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtICsgKHIubGVuZ3RoID4gMCA/IGA6ICR7cn1gIDogXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRTY2FsYXIodHlwZSwganNvbiwgbG9uZ1R5cGUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBzaWduYXR1cmUgb2Ygb3VyIGludGVybmFsIGZ1bmN0aW9uIGhhcyBjaGFuZ2VkLiBGb3IgYmFja3dhcmRzLVxuICAgICAgICAgICAgLy8gY29tcGF0aWJpbGl0eSwgd2Ugc3VwcG9ydCB0aGUgb2xkIGZvcm0gdGhhdCBpcyBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJXG4gICAgICAgICAgICAvLyB0aHJvdWdoIHRoZSBpbnRlcmZhY2UgSnNvbkZvcm1hdC5cbiAgICAgICAgICAgIHJldHVybiByZWFkU2NhbGFyKHR5cGUsIGpzb24sIGxvbmdUeXBlICE9PSBudWxsICYmIGxvbmdUeXBlICE9PSB2b2lkIDAgPyBsb25nVHlwZSA6IExvbmdUeXBlLkJJR0lOVCwgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlU2NhbGFyKHR5cGUsIHZhbHVlLCBlbWl0RGVmYXVsdFZhbHVlcykge1xuICAgICAgICAgICAgLy8gVGhlIHNpZ25hdHVyZSBvZiBvdXIgaW50ZXJuYWwgZnVuY3Rpb24gaGFzIGNoYW5nZWQuIEZvciBiYWNrd2FyZHMtXG4gICAgICAgICAgICAvLyBjb21wYXRpYmlsaXR5LCB3ZSBzdXBwb3J0IHRoZSBvbGQgZm9ybSB0aGF0IGlzIHBhcnQgb2YgdGhlIHB1YmxpYyBBUElcbiAgICAgICAgICAgIC8vIHRocm91Z2ggdGhlIGludGVyZmFjZSBKc29uRm9ybWF0LlxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVtaXREZWZhdWx0VmFsdWVzIHx8IGlzU2NhbGFyWmVyb1ZhbHVlKHR5cGUsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZVNjYWxhcih0eXBlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICBkZWJ1ZzogZGVidWdKc29uVmFsdWUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRlYnVnSnNvblZhbHVlKGpzb24pIHtcbiAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mIGpzb24pIHtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoanNvbikgPyBcImFycmF5XCIgOiBcIm9iamVjdFwiO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4ganNvbi5sZW5ndGggPiAxMDAgPyBcInN0cmluZ1wiIDogYFwiJHtqc29uLnNwbGl0KCdcIicpLmpvaW4oJ1xcXFxcIicpfVwiYDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoanNvbik7XG4gICAgfVxufVxuLy8gUmVhZCBhIEpTT04gdmFsdWUgZm9yIGEgZmllbGQuXG4vLyBUaGUgXCJwYXJlbnRUeXBlXCIgYXJndW1lbnQgaXMgb25seSB1c2VkIHRvIHByb3ZpZGUgY29udGV4dCBpbiBlcnJvcnMuXG5mdW5jdGlvbiByZWFkRmllbGQodGFyZ2V0LCBqc29uVmFsdWUsIGZpZWxkLCBvcHRpb25zLCBwYXJlbnRUeXBlKSB7XG4gICAgbGV0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgICBpZiAoZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgYXNzZXJ0KGZpZWxkLmtpbmQgIT0gXCJtYXBcIik7XG4gICAgICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvblZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGZpZWxkICR7cGFyZW50VHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046ICR7ZGVidWdKc29uVmFsdWUoanNvblZhbHVlKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRBcnJheSA9IHRhcmdldFtsb2NhbE5hbWVdO1xuICAgICAgICBmb3IgKGNvbnN0IGpzb25JdGVtIG9mIGpzb25WYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGpzb25JdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGZpZWxkICR7cGFyZW50VHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046ICR7ZGVidWdKc29uVmFsdWUoanNvbkl0ZW0pfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QXJyYXkucHVzaChmaWVsZC5ULmZyb21Kc29uKGpzb25JdGVtLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IHJlYWRFbnVtKGZpZWxkLlQsIGpzb25JdGVtLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW51bVZhbHVlICE9PSB0b2tlbklnbm9yZWRVbmtub3duRW51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QXJyYXkucHVzaChlbnVtVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEFycmF5LnB1c2gocmVhZFNjYWxhcihmaWVsZC5ULCBqc29uSXRlbSwgZmllbGQuTCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IGBjYW5ub3QgZGVjb2RlIGZpZWxkICR7cGFyZW50VHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046ICR7ZGVidWdKc29uVmFsdWUoanNvbkl0ZW0pfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbSArPSBgOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpZWxkLmtpbmQgPT0gXCJtYXBcIikge1xuICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBqc29uVmFsdWUgIT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGpzb25WYWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBmaWVsZCAke3BhcmVudFR5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiAke2RlYnVnSnNvblZhbHVlKGpzb25WYWx1ZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0TWFwID0gdGFyZ2V0W2xvY2FsTmFtZV07XG4gICAgICAgIGZvciAoY29uc3QgW2pzb25NYXBLZXksIGpzb25NYXBWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoanNvblZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGpzb25NYXBWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBmaWVsZCAke3BhcmVudFR5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiBtYXAgdmFsdWUgbnVsbGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAga2V5ID0gcmVhZE1hcEtleShmaWVsZC5LLCBqc29uTWFwS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG0gPSBgY2Fubm90IGRlY29kZSBtYXAga2V5IGZvciBmaWVsZCAke3BhcmVudFR5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiAke2RlYnVnSnNvblZhbHVlKGpzb25WYWx1ZSl9YDtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG0gKz0gYDogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRNYXBba2V5XSA9IGZpZWxkLlYuVC5mcm9tSnNvbihqc29uTWFwVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnVtVmFsdWUgPSByZWFkRW51bShmaWVsZC5WLlQsIGpzb25NYXBWYWx1ZSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudW1WYWx1ZSAhPT0gdG9rZW5JZ25vcmVkVW5rbm93bkVudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE1hcFtrZXldID0gZW51bVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE1hcFtrZXldID0gcmVhZFNjYWxhcihmaWVsZC5WLlQsIGpzb25NYXBWYWx1ZSwgTG9uZ1R5cGUuQklHSU5ULCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBgY2Fubm90IGRlY29kZSBtYXAgdmFsdWUgZm9yIGZpZWxkICR7cGFyZW50VHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046ICR7ZGVidWdKc29uVmFsdWUoanNvblZhbHVlKX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gKz0gYDogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXSA9IHsgY2FzZTogbG9jYWxOYW1lIH07XG4gICAgICAgICAgICBsb2NhbE5hbWUgPSBcInZhbHVlXCI7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gZmllbGQuVDtcbiAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VUeXBlLnR5cGVOYW1lICE9IFwiZ29vZ2xlLnByb3RvYnVmLlZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFZhbHVlID0gdGFyZ2V0W2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGlzTWVzc2FnZShjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBjdXJyZW50VmFsdWUgPSBtZXNzYWdlVHlwZS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyICYmICFmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlci51bndyYXBGaWVsZChjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICBjb25zdCBlbnVtVmFsdWUgPSByZWFkRW51bShmaWVsZC5ULCBqc29uVmFsdWUsIG9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZW51bVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdG9rZW5OdWxsOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJGaWVsZChmaWVsZCwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHRva2VuSWdub3JlZFVua25vd25FbnVtOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGVudW1WYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2FsYXJWYWx1ZSA9IHJlYWRTY2FsYXIoZmllbGQuVCwganNvblZhbHVlLCBmaWVsZC5MLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc2NhbGFyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdG9rZW5OdWxsOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyRmllbGQoZmllbGQsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gc2NhbGFyVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBgY2Fubm90IGRlY29kZSBmaWVsZCAke3BhcmVudFR5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiAke2RlYnVnSnNvblZhbHVlKGpzb25WYWx1ZSl9YDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbSArPSBgOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiByZWFkTWFwS2V5KHR5cGUsIGpzb24pIHtcbiAgICBpZiAodHlwZSA9PT0gU2NhbGFyVHlwZS5CT09MKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrXG4gICAgICAgIHN3aXRjaCAoanNvbikge1xuICAgICAgICAgICAgY2FzZSBcInRydWVcIjpcbiAgICAgICAgICAgICAgICBqc29uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmYWxzZVwiOlxuICAgICAgICAgICAgICAgIGpzb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVhZFNjYWxhcih0eXBlLCBqc29uLCBMb25nVHlwZS5CSUdJTlQsIHRydWUpLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiByZWFkU2NhbGFyKHR5cGUsIGpzb24sIGxvbmdUeXBlLCBudWxsQXNaZXJvVmFsdWUpIHtcbiAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobnVsbEFzWmVyb1ZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGFyWmVyb1ZhbHVlKHR5cGUsIGxvbmdUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5OdWxsO1xuICAgIH1cbiAgICAvLyBldmVyeSB2YWxpZCBjYXNlIGluIHRoZSBzd2l0Y2ggYmVsb3cgcmV0dXJucywgYW5kIGV2ZXJ5IGZhbGxcbiAgICAvLyB0aHJvdWdoIGlzIHJlZ2FyZGVkIGFzIGEgZmFpbHVyZS5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgLy8gZmxvYXQsIGRvdWJsZTogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgbnVtYmVyIG9yIG9uZSBvZiB0aGUgc3BlY2lhbCBzdHJpbmcgdmFsdWVzIFwiTmFOXCIsIFwiSW5maW5pdHlcIiwgYW5kIFwiLUluZmluaXR5XCIuXG4gICAgICAgIC8vIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLiBFeHBvbmVudCBub3RhdGlvbiBpcyBhbHNvIGFjY2VwdGVkLlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gXCJOYU5cIilcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk5hTjtcbiAgICAgICAgICAgIGlmIChqc29uID09PSBcIkluZmluaXR5XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgIGlmIChqc29uID09PSBcIi1JbmZpbml0eVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIC8vIGVtcHR5IHN0cmluZyBpcyBub3QgYSBudW1iZXJcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcInN0cmluZ1wiICYmIGpzb24udHJpbSgpLmxlbmd0aCAhPT0ganNvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBleHRyYSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YganNvbiAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmbG9hdCA9IE51bWJlcihqc29uKTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4oZmxvYXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGEgbnVtYmVyXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShmbG9hdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpbmZpbml0eSBhbmQgLWluZmluaXR5IGFyZSBoYW5kbGVkIGJ5IHN0cmluZyByZXByZXNlbnRhdGlvbiBhYm92ZSwgc28gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5GTE9BVClcbiAgICAgICAgICAgICAgICBhc3NlcnRGbG9hdDMyKGZsb2F0KTtcbiAgICAgICAgICAgIHJldHVybiBmbG9hdDtcbiAgICAgICAgLy8gaW50MzIsIGZpeGVkMzIsIHVpbnQzMjogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBudW1iZXIuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgICAgICAgICBsZXQgaW50MzI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBpbnQzMiA9IGpzb247XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YganNvbiA9PSBcInN0cmluZ1wiICYmIGpzb24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChqc29uLnRyaW0oKS5sZW5ndGggPT09IGpzb24ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBpbnQzMiA9IE51bWJlcihqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnQzMiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5VSU5UMzIgfHwgdHlwZSA9PSBTY2FsYXJUeXBlLkZJWEVEMzIpXG4gICAgICAgICAgICAgICAgYXNzZXJ0VUludDMyKGludDMyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhc3NlcnRJbnQzMihpbnQzMik7XG4gICAgICAgICAgICByZXR1cm4gaW50MzI7XG4gICAgICAgIC8vIGludDY0LCBmaXhlZDY0LCB1aW50NjQ6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgc3RyaW5nLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIiAmJiB0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY29uc3QgbG9uZyA9IHByb3RvSW50NjQucGFyc2UoanNvbik7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICAgICAgICByZXR1cm4gbG9uZ1R5cGUgPyBsb25nLnRvU3RyaW5nKCkgOiBsb25nO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcIm51bWJlclwiICYmIHR5cGVvZiBqc29uICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjb25zdCB1TG9uZyA9IHByb3RvSW50NjQudVBhcnNlKGpzb24pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgICAgICAgcmV0dXJuIGxvbmdUeXBlID8gdUxvbmcudG9TdHJpbmcoKSA6IHVMb25nO1xuICAgICAgICAvLyBib29sOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgLy8gc3RyaW5nOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBIHN0cmluZyBtdXN0IGFsd2F5cyBjb250YWluIFVURi04IGVuY29kZWQgb3IgNy1iaXQgQVNDSUkuXG4gICAgICAgICAgICAvLyBXZSB2YWxpZGF0ZSB3aXRoIGVuY29kZVVSSUNvbXBvbmVudCwgd2hpY2ggYXBwZWFycyB0byBiZSB0aGUgZmFzdGVzdCB3aWRlbHkgYXZhaWxhYmxlIG9wdGlvbi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGpzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFVURjhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgLy8gYnl0ZXM6IEpTT04gdmFsdWUgd2lsbCBiZSB0aGUgZGF0YSBlbmNvZGVkIGFzIGEgc3RyaW5nIHVzaW5nIHN0YW5kYXJkIGJhc2U2NCBlbmNvZGluZyB3aXRoIHBhZGRpbmdzLlxuICAgICAgICAvLyBFaXRoZXIgc3RhbmRhcmQgb3IgVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nIHdpdGgvd2l0aG91dCBwYWRkaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgICAgICAgIGlmIChqc29uID09PSBcIlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHJldHVybiBwcm90b0Jhc2U2NC5kZWMoanNvbik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigpO1xufVxuZnVuY3Rpb24gcmVhZEVudW0odHlwZSwganNvbiwgaWdub3JlVW5rbm93bkZpZWxkcywgbnVsbEFzWmVyb1ZhbHVlKSB7XG4gICAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGUudHlwZU5hbWUgPT0gXCJnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlLk5VTExfVkFMVUUgPSAwXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGxBc1plcm9WYWx1ZSA/IHR5cGUudmFsdWVzWzBdLm5vIDogdG9rZW5OdWxsO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVja1xuICAgIHN3aXRjaCAodHlwZW9mIGpzb24pIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoanNvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGUuZmluZE5hbWUoanNvbik7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5ubztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpZ25vcmVVbmtub3duRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuSWdub3JlZFVua25vd25FbnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBlbnVtICR7dHlwZS50eXBlTmFtZX0gZnJvbSBKU09OOiAke2RlYnVnSnNvblZhbHVlKGpzb24pfWApO1xufVxuLy8gRGVjaWRlIHdoZXRoZXIgYW4gdW5zZXQgZmllbGQgc2hvdWxkIGJlIGVtaXR0ZWQgd2l0aCBKU09OIHdyaXRlIG9wdGlvbiBgZW1pdERlZmF1bHRWYWx1ZXNgXG5mdW5jdGlvbiBjYW5FbWl0RmllbGREZWZhdWx0VmFsdWUoZmllbGQpIHtcbiAgICBpZiAoZmllbGQucmVwZWF0ZWQgfHwgZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgICAgIC8vIG1hcHMgYXJlIHt9LCByZXBlYXRlZCBmaWVsZHMgYXJlIFtdXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgLy8gb25lb2YgZmllbGRzIGFyZSBuZXZlciBlbWl0dGVkXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGZpZWxkLmtpbmQgPT0gXCJtZXNzYWdlXCIpIHtcbiAgICAgICAgLy8gc2luZ3VsYXIgbWVzc2FnZSBmaWVsZCBhcmUgYWxsb3dlZCB0byBlbWl0IEpTT04gbnVsbCwgYnV0IHdlIGRvIG5vdFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICBpZiAoZmllbGQub3B0IHx8IGZpZWxkLnJlcSkge1xuICAgICAgICAvLyB0aGUgZmllbGQgdXNlcyBleHBsaWNpdCBwcmVzZW5jZSwgc28gd2UgY2Fubm90IGVtaXQgYSB6ZXJvIHZhbHVlXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB3cml0ZUZpZWxkKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChmaWVsZC5raW5kID09IFwibWFwXCIpIHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlICE9IG51bGwpO1xuICAgICAgICBjb25zdCBqc29uT2JqID0ge307XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyh2YWx1ZSk7XG4gICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IHdyaXRlU2NhbGFyKGZpZWxkLlYuVCwgZW50cnlWYWx1ZSk7IC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IGVudHJ5VmFsdWUudG9Kc29uKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgY29uc3QgZW51bVR5cGUgPSBmaWVsZC5WLlQ7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxuICAgICAgICAgICAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gd3JpdGVFbnVtKGVudW1UeXBlLCBlbnRyeVZhbHVlLCBvcHRpb25zLmVudW1Bc0ludGVnZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcyB8fCBlbnRyaWVzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8ganNvbk9ialxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh2YWx1ZSkpO1xuICAgICAgICBjb25zdCBqc29uQXJyID0gW107XG4gICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAganNvbkFyci5wdXNoKHdyaXRlU2NhbGFyKGZpZWxkLlQsIHZhbHVlW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGpzb25BcnIucHVzaCh3cml0ZUVudW0oZmllbGQuVCwgdmFsdWVbaV0sIG9wdGlvbnMuZW51bUFzSW50ZWdlcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBqc29uQXJyLnB1c2godmFsdWVbaV0udG9Kc29uKG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMgfHwganNvbkFyci5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IGpzb25BcnJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlU2NhbGFyKGZpZWxkLlQsIHZhbHVlKTtcbiAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIHJldHVybiB3cml0ZUVudW0oZmllbGQuVCwgdmFsdWUsIG9wdGlvbnMuZW51bUFzSW50ZWdlcik7XG4gICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICByZXR1cm4gd3JhcEZpZWxkKGZpZWxkLlQsIHZhbHVlKS50b0pzb24ob3B0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JpdGVFbnVtKHR5cGUsIHZhbHVlLCBlbnVtQXNJbnRlZ2VyKSB7XG4gICAgdmFyIF9hO1xuICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgaWYgKHR5cGUudHlwZU5hbWUgPT0gXCJnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChlbnVtQXNJbnRlZ2VyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsID0gdHlwZS5maW5kTnVtYmVyKHZhbHVlKTtcbiAgICByZXR1cm4gKF9hID0gdmFsID09PSBudWxsIHx8IHZhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsLm5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlOyAvLyBpZiB3ZSBkb24ndCBrbm93IHRoZSBlbnVtIHZhbHVlLCBqdXN0IHJldHVybiB0aGUgbnVtYmVyXG59XG5mdW5jdGlvbiB3cml0ZVNjYWxhcih0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAvLyBpbnQzMiwgZml4ZWQzMiwgdWludDMyOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIG51bWJlci4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIC8vIGZsb2F0LCBkb3VibGU6IEpTT04gdmFsdWUgd2lsbCBiZSBhIG51bWJlciBvciBvbmUgb2YgdGhlIHNwZWNpYWwgc3RyaW5nIHZhbHVlcyBcIk5hTlwiLCBcIkluZmluaXR5XCIsIGFuZCBcIi1JbmZpbml0eVwiLlxuICAgICAgICAvLyBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC4gRXhwb25lbnQgbm90YXRpb24gaXMgYWxzbyBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgICAvLyBhc3NlcnRGbG9hdDMyKHZhbHVlKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIk5hTlwiO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiSW5maW5pdHlcIjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIi1JbmZpbml0eVwiO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAvLyBzdHJpbmc6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAvLyBib29sOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJib29sZWFuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAvLyBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIHN0cmluZy4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJiaWdpbnRcIiB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIGJ5dGVzOiBKU09OIHZhbHVlIHdpbGwgYmUgdGhlIGRhdGEgZW5jb2RlZCBhcyBhIHN0cmluZyB1c2luZyBzdGFuZGFyZCBiYXNlNjQgZW5jb2Rpbmcgd2l0aCBwYWRkaW5ncy5cbiAgICAgICAgLy8gRWl0aGVyIHN0YW5kYXJkIG9yIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyB3aXRoL3dpdGhvdXQgcGFkZGluZ3MgYXJlIGFjY2VwdGVkLlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICBhc3NlcnQodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KTtcbiAgICAgICAgICAgIHJldHVybiBwcm90b0Jhc2U2NC5lbmModmFsdWUpO1xuICAgIH1cbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBCaW5hcnlSZWFkZXIsIEJpbmFyeVdyaXRlciwgV2lyZVR5cGUgfSBmcm9tIFwiLi4vYmluYXJ5LWVuY29kaW5nLmpzXCI7XG5pbXBvcnQgeyBNZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2UuanNcIjtcbmltcG9ydCB7IHdyYXBGaWVsZCB9IGZyb20gXCIuL2ZpZWxkLXdyYXBwZXIuanNcIjtcbmltcG9ydCB7IHNjYWxhclplcm9WYWx1ZSB9IGZyb20gXCIuL3NjYWxhcnMuanNcIjtcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuL2Fzc2VydC5qc1wiO1xuaW1wb3J0IHsgaXNGaWVsZFNldCB9IGZyb20gXCIuL3JlZmxlY3QuanNcIjtcbmltcG9ydCB7IExvbmdUeXBlLCBTY2FsYXJUeXBlIH0gZnJvbSBcIi4uL3NjYWxhci5qc1wiO1xuaW1wb3J0IHsgaXNNZXNzYWdlIH0gZnJvbSBcIi4uL2lzLW1lc3NhZ2UuanNcIjtcbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxuby1jYXNlLWRlY2xhcmF0aW9ucyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGwsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4gKi9cbmNvbnN0IHVua25vd25GaWVsZHNTeW1ib2wgPSBTeW1ib2woXCJAYnVmYnVpbGQvcHJvdG9idWYvdW5rbm93bi1maWVsZHNcIik7XG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHBhcnNpbmcgYmluYXJ5IGRhdGEuXG5jb25zdCByZWFkRGVmYXVsdHMgPSB7XG4gICAgcmVhZFVua25vd25GaWVsZHM6IHRydWUsXG4gICAgcmVhZGVyRmFjdG9yeTogKGJ5dGVzKSA9PiBuZXcgQmluYXJ5UmVhZGVyKGJ5dGVzKSxcbn07XG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHNlcmlhbGl6aW5nIGJpbmFyeSBkYXRhLlxuY29uc3Qgd3JpdGVEZWZhdWx0cyA9IHtcbiAgICB3cml0ZVVua25vd25GaWVsZHM6IHRydWUsXG4gICAgd3JpdGVyRmFjdG9yeTogKCkgPT4gbmV3IEJpbmFyeVdyaXRlcigpLFxufTtcbmZ1bmN0aW9uIG1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlYWREZWZhdWx0cyksIG9wdGlvbnMpIDogcmVhZERlZmF1bHRzO1xufVxuZnVuY3Rpb24gbWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdyaXRlRGVmYXVsdHMpLCBvcHRpb25zKSA6IHdyaXRlRGVmYXVsdHM7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZUJpbmFyeUZvcm1hdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYWtlUmVhZE9wdGlvbnMsXG4gICAgICAgIG1ha2VXcml0ZU9wdGlvbnMsXG4gICAgICAgIGxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBtZXNzYWdlW3Vua25vd25GaWVsZHNTeW1ib2xdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzY2FyZFVua25vd25GaWVsZHMobWVzc2FnZSkge1xuICAgICAgICAgICAgZGVsZXRlIG1lc3NhZ2VbdW5rbm93bkZpZWxkc1N5bWJvbF07XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlVW5rbm93bkZpZWxkcyhtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgY29uc3QgYyA9IG1bdW5rbm93bkZpZWxkc1N5bWJvbF07XG4gICAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZiBvZiBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci50YWcoZi5ubywgZi53aXJlVHlwZSkucmF3KGYuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblVua25vd25GaWVsZChtZXNzYWdlLCBubywgd2lyZVR5cGUsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1bdW5rbm93bkZpZWxkc1N5bWJvbF0pKSB7XG4gICAgICAgICAgICAgICAgbVt1bmtub3duRmllbGRzU3ltYm9sXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbVt1bmtub3duRmllbGRzU3ltYm9sXS5wdXNoKHsgbm8sIHdpcmVUeXBlLCBkYXRhIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZWFkTWVzc2FnZShtZXNzYWdlLCByZWFkZXIsIGxlbmd0aE9yRW5kVGFnRmllbGRObywgb3B0aW9ucywgZGVsaW1pdGVkTWVzc2FnZUVuY29kaW5nKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICAgICAgICBjb25zdCBlbmQgPSBkZWxpbWl0ZWRNZXNzYWdlRW5jb2RpbmdcbiAgICAgICAgICAgICAgICA/IHJlYWRlci5sZW5cbiAgICAgICAgICAgICAgICA6IHJlYWRlci5wb3MgKyBsZW5ndGhPckVuZFRhZ0ZpZWxkTm87XG4gICAgICAgICAgICBsZXQgZmllbGRObywgd2lyZVR5cGU7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGltaXRlZE1lc3NhZ2VFbmNvZGluZyA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICAgICAgICB3aXJlVHlwZSA9PSBXaXJlVHlwZS5FbmRHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0eXBlLmZpZWxkcy5maW5kKGZpZWxkTm8pO1xuICAgICAgICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlYWRlci5za2lwKHdpcmVUeXBlLCBmaWVsZE5vKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVhZFVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Vbmtub3duRmllbGQobWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWFkRmllbGQobWVzc2FnZSwgcmVhZGVyLCBmaWVsZCwgd2lyZVR5cGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbGltaXRlZE1lc3NhZ2VFbmNvZGluZyAmJiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICh3aXJlVHlwZSAhPSBXaXJlVHlwZS5FbmRHcm91cCB8fCBmaWVsZE5vICE9PSBsZW5ndGhPckVuZFRhZ0ZpZWxkTm8pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGVuZCBncm91cCB0YWdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVhZEZpZWxkLFxuICAgICAgICB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGUuZmllbGRzLmJ5TnVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmllbGRTZXQoZmllbGQsIG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5yZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGVuY29kZSBmaWVsZCAke3R5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gdG8gYmluYXJ5OiByZXF1aXJlZCBmaWVsZCBub3Qgc2V0YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQub25lb2ZcbiAgICAgICAgICAgICAgICAgICAgPyBtZXNzYWdlW2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV0udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBtZXNzYWdlW2ZpZWxkLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgd3JpdGVGaWVsZChmaWVsZCwgdmFsdWUsIHdyaXRlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy53cml0ZVVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVW5rbm93bkZpZWxkcyhtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGVGaWVsZChmaWVsZCwgdmFsdWUsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAgICAgLy8gVGhlIGJlaGF2aW9yIG9mIG91ciBpbnRlcm5hbCBmdW5jdGlvbiBoYXMgY2hhbmdlZCwgaXQgZG9lcyBubyBsb25nZXJcbiAgICAgICAgICAgIC8vIGFjY2VwdCBgdW5kZWZpbmVkYCB2YWx1ZXMgZm9yIHNpbmd1bGFyIHNjYWxhciBhbmQgbWFwLlxuICAgICAgICAgICAgLy8gRm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCB3ZSBzdXBwb3J0IHRoZSBvbGQgZm9ybSB0aGF0IGlzIHBhcnQgb2ZcbiAgICAgICAgICAgIC8vIHRoZSBwdWJsaWMgQVBJIHRocm91Z2ggdGhlIGludGVyZmFjZSBCaW5hcnlGb3JtYXQuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZUZpZWxkKGZpZWxkLCB2YWx1ZSwgd3JpdGVyLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVhZEZpZWxkKHRhcmdldCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55IC0tIGBhbnlgIGlzIHRoZSBiZXN0IGNob2ljZSBmb3IgZHluYW1pYyBhY2Nlc3NcbnJlYWRlciwgZmllbGQsIHdpcmVUeXBlLCBvcHRpb25zKSB7XG4gICAgbGV0IHsgcmVwZWF0ZWQsIGxvY2FsTmFtZSB9ID0gZmllbGQ7XG4gICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldFtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdO1xuICAgICAgICBpZiAodGFyZ2V0LmNhc2UgIT0gbG9jYWxOYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5jYXNlID0gbG9jYWxOYW1lO1xuICAgICAgICBsb2NhbE5hbWUgPSBcInZhbHVlXCI7XG4gICAgfVxuICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICBjb25zdCBzY2FsYXJUeXBlID0gZmllbGQua2luZCA9PSBcImVudW1cIiA/IFNjYWxhclR5cGUuSU5UMzIgOiBmaWVsZC5UO1xuICAgICAgICAgICAgbGV0IHJlYWQgPSByZWFkU2NhbGFyO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uIC0tIGFjY2VwdGFibGUgc2luY2UgaXQncyBjb3ZlcmVkIGJ5IHRlc3RzXG4gICAgICAgICAgICBpZiAoZmllbGQua2luZCA9PSBcInNjYWxhclwiICYmIGZpZWxkLkwgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVhZCA9IHJlYWRTY2FsYXJMVFN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgIGxldCBhcnIgPSB0YXJnZXRbbG9jYWxOYW1lXTsgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgYXJyYXksIG9uZW9mIGNhbm5vdCBjb250YWluIHJlcGVhdGVkIHZhbHVlc1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUGFja2VkID0gd2lyZVR5cGUgPT0gV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkICYmXG4gICAgICAgICAgICAgICAgICAgIHNjYWxhclR5cGUgIT0gU2NhbGFyVHlwZS5TVFJJTkcgJiZcbiAgICAgICAgICAgICAgICAgICAgc2NhbGFyVHlwZSAhPSBTY2FsYXJUeXBlLkJZVEVTO1xuICAgICAgICAgICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZSA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2gocmVhZChyZWFkZXIsIHNjYWxhclR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2gocmVhZChyZWFkZXIsIHNjYWxhclR5cGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHJlYWQocmVhZGVyLCBzY2FsYXJUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBmaWVsZC5UO1xuICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgYXJyYXksIG9uZW9mIGNhbm5vdCBjb250YWluIHJlcGVhdGVkIHZhbHVlc1xuICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdLnB1c2gocmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG5ldyBtZXNzYWdlVHlwZSgpLCBvcHRpb25zLCBmaWVsZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTWVzc2FnZSh0YXJnZXRbbG9jYWxOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIHRhcmdldFtsb2NhbE5hbWVdLCBvcHRpb25zLCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBuZXcgbWVzc2FnZVR5cGUoKSwgb3B0aW9ucywgZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyICYmICFmaWVsZC5vbmVvZiAmJiAhZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gbWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyLnVud3JhcEZpZWxkKHRhcmdldFtsb2NhbE5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICBsZXQgW21hcEtleSwgbWFwVmFsXSA9IHJlYWRNYXBFbnRyeShmaWVsZCwgcmVhZGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIHNhZmUgdG8gYXNzdW1lIHByZXNlbmNlIG9mIG1hcCBvYmplY3QsIG9uZW9mIGNhbm5vdCBjb250YWluIHJlcGVhdGVkIHZhbHVlc1xuICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV1bbWFwS2V5XSA9IG1hcFZhbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbi8vIFJlYWQgYSBtZXNzYWdlLCBhdm9pZGluZyBNZXNzYWdlVHlwZS5mcm9tQmluYXJ5KCkgdG8gcmUtdXNlIHRoZVxuLy8gQmluYXJ5UmVhZE9wdGlvbnMgYW5kIHRoZSBJQmluYXJ5UmVhZGVyLlxuZnVuY3Rpb24gcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG1lc3NhZ2UsIG9wdGlvbnMsIGZpZWxkKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW47XG4gICAgY29uc3QgZGVsaW1pdGVkID0gZmllbGQgPT09IG51bGwgfHwgZmllbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkLmRlbGltaXRlZDtcbiAgICBmb3JtYXQucmVhZE1lc3NhZ2UobWVzc2FnZSwgcmVhZGVyLCBkZWxpbWl0ZWQgPyBmaWVsZC5ubyA6IHJlYWRlci51aW50MzIoKSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICBvcHRpb25zLCBkZWxpbWl0ZWQpO1xuICAgIHJldHVybiBtZXNzYWdlO1xufVxuLy8gUmVhZCBhIG1hcCBmaWVsZCwgZXhwZWN0aW5nIGtleSBmaWVsZCA9IDEsIHZhbHVlIGZpZWxkID0gMlxuZnVuY3Rpb24gcmVhZE1hcEVudHJ5KGZpZWxkLCByZWFkZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZW5ndGggPSByZWFkZXIudWludDMyKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgbGV0IGtleSwgdmFsO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIGNvbnN0IFtmaWVsZE5vXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAga2V5ID0gcmVhZFNjYWxhcihyZWFkZXIsIGZpZWxkLkspO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRTY2FsYXIocmVhZGVyLCBmaWVsZC5WLlQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG5ldyBmaWVsZC5WLlQoKSwgb3B0aW9ucywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5ID0gc2NhbGFyWmVyb1ZhbHVlKGZpZWxkLkssIExvbmdUeXBlLkJJR0lOVCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Yga2V5ICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIGtleSAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgIGtleSA9IGtleS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICB2YWwgPSBzY2FsYXJaZXJvVmFsdWUoZmllbGQuVi5ULCBMb25nVHlwZS5CSUdJTlQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICB2YWwgPSBmaWVsZC5WLlQudmFsdWVzWzBdLm5vO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICB2YWwgPSBuZXcgZmllbGQuVi5UKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtrZXksIHZhbF07XG59XG4vLyBSZWFkIGEgc2NhbGFyIHZhbHVlLCBidXQgcmV0dXJuIDY0IGJpdCBpbnRlZ3JhbCB0eXBlcyAoaW50NjQsIHVpbnQ2NCxcbi8vIHNpbnQ2NCwgZml4ZWQ2NCwgc2ZpeGVkNjQpIGFzIHN0cmluZyBpbnN0ZWFkIG9mIGJpZ2ludC5cbmZ1bmN0aW9uIHJlYWRTY2FsYXJMVFN0cmluZyhyZWFkZXIsIHR5cGUpIHtcbiAgICBjb25zdCB2ID0gcmVhZFNjYWxhcihyZWFkZXIsIHR5cGUpO1xuICAgIHJldHVybiB0eXBlb2YgdiA9PSBcImJpZ2ludFwiID8gdi50b1N0cmluZygpIDogdjtcbn1cbi8vIERvZXMgbm90IHVzZSBzY2FsYXJUeXBlSW5mbygpIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG5mdW5jdGlvbiByZWFkU2NhbGFyKHJlYWRlciwgdHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuZG91YmxlKCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5pbnQzMigpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLmludDY0KCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuZml4ZWQ2NCgpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5maXhlZDMyKCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuc2ZpeGVkMzIoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5zZml4ZWQ2NCgpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5zaW50NjQoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIudWludDMyKCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLnNpbnQzMigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdyaXRlRmllbGQoZmllbGQsIHZhbHVlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCk7XG4gICAgY29uc3QgcmVwZWF0ZWQgPSBmaWVsZC5yZXBlYXRlZDtcbiAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgbGV0IHNjYWxhclR5cGUgPSBmaWVsZC5raW5kID09IFwiZW51bVwiID8gU2NhbGFyVHlwZS5JTlQzMiA6IGZpZWxkLlQ7XG4gICAgICAgICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5wYWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVQYWNrZWQod3JpdGVyLCBzY2FsYXJUeXBlLCBmaWVsZC5ubywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZVNjYWxhcih3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyaXRlU2NhbGFyKHdyaXRlciwgc2NhbGFyVHlwZSwgZmllbGQubm8sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVNZXNzYWdlRmllbGQod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JpdGVNZXNzYWdlRmllbGQod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPSBudWxsKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB3cml0ZU1hcEVudHJ5KHdyaXRlciwgb3B0aW9ucywgZmllbGQsIGtleSwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZU1hcEVudHJ5KHdyaXRlciwgb3B0aW9ucywgZmllbGQsIGtleSwgdmFsdWUpIHtcbiAgICB3cml0ZXIudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpO1xuICAgIHdyaXRlci5mb3JrKCk7XG4gICAgLy8gamF2YXNjcmlwdCBvbmx5IGFsbG93cyBudW1iZXIgb3Igc3RyaW5nIGZvciBvYmplY3QgcHJvcGVydGllc1xuICAgIC8vIHdlIGNvbnZlcnQgZnJvbSBvdXIgcmVwcmVzZW50YXRpb24gdG8gdGhlIHByb3RvYnVmIHR5cGVcbiAgICBsZXQga2V5VmFsdWUgPSBrZXk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gd2UgZGVsaWJlcmF0ZWx5IGhhbmRsZSBqdXN0IHRoZSBzcGVjaWFsIGNhc2VzIGZvciBtYXAga2V5c1xuICAgIHN3aXRjaCAoZmllbGQuSykge1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgICAgICBrZXlWYWx1ZSA9IE51bWJlci5wYXJzZUludChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgYXNzZXJ0KGtleSA9PSBcInRydWVcIiB8fCBrZXkgPT0gXCJmYWxzZVwiKTtcbiAgICAgICAgICAgIGtleVZhbHVlID0ga2V5ID09IFwidHJ1ZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIHdyaXRlIGtleSwgZXhwZWN0aW5nIGtleSBmaWVsZCBudW1iZXIgPSAxXG4gICAgd3JpdGVTY2FsYXIod3JpdGVyLCBmaWVsZC5LLCAxLCBrZXlWYWx1ZSk7XG4gICAgLy8gd3JpdGUgdmFsdWUsIGV4cGVjdGluZyB2YWx1ZSBmaWVsZCBudW1iZXIgPSAyXG4gICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBmaWVsZC5WLlQsIDIsIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBTY2FsYXJUeXBlLklOVDMyLCAyLCB2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5ieXRlcyh2YWx1ZS50b0JpbmFyeShvcHRpb25zKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgd3JpdGVyLmpvaW4oKTtcbn1cbi8vIFZhbHVlIG11c3Qgbm90IGJlIHVuZGVmaW5lZFxuZnVuY3Rpb24gd3JpdGVNZXNzYWdlRmllbGQod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwgdmFsdWUpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gd3JhcEZpZWxkKGZpZWxkLlQsIHZhbHVlKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgaWYgKGZpZWxkLmRlbGltaXRlZClcbiAgICAgICAgd3JpdGVyXG4gICAgICAgICAgICAudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5TdGFydEdyb3VwKVxuICAgICAgICAgICAgLnJhdyhtZXNzYWdlLnRvQmluYXJ5KG9wdGlvbnMpKVxuICAgICAgICAgICAgLnRhZyhmaWVsZC5ubywgV2lyZVR5cGUuRW5kR3JvdXApO1xuICAgIGVsc2VcbiAgICAgICAgd3JpdGVyXG4gICAgICAgICAgICAudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpXG4gICAgICAgICAgICAuYnl0ZXMobWVzc2FnZS50b0JpbmFyeShvcHRpb25zKSk7XG59XG5mdW5jdGlvbiB3cml0ZVNjYWxhcih3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlKSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQpO1xuICAgIGxldCBbd2lyZVR5cGUsIG1ldGhvZF0gPSBzY2FsYXJUeXBlSW5mbyh0eXBlKTtcbiAgICB3cml0ZXIudGFnKGZpZWxkTm8sIHdpcmVUeXBlKVttZXRob2RdKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkKHdyaXRlciwgdHlwZSwgZmllbGRObywgdmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHdyaXRlci50YWcoZmllbGRObywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCk7XG4gICAgbGV0IFssIG1ldGhvZF0gPSBzY2FsYXJUeXBlSW5mbyh0eXBlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdyaXRlclttZXRob2RdKHZhbHVlW2ldKTtcbiAgICB9XG4gICAgd3JpdGVyLmpvaW4oKTtcbn1cbi8qKlxuICogR2V0IGluZm9ybWF0aW9uIGZvciB3cml0aW5nIGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIFJldHVybnMgdHVwbGU6XG4gKiBbMF06IGFwcHJvcHJpYXRlIFdpcmVUeXBlXG4gKiBbMV06IG5hbWUgb2YgdGhlIGFwcHJvcHJpYXRlIG1ldGhvZCBvZiBJQmluYXJ5V3JpdGVyXG4gKiBbMl06IHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvdG8zIHNlbWFudGljc1xuICpcbiAqIElmIGFyZ3VtZW50IGB2YWx1ZWAgaXMgb21pdHRlZCwgWzJdIGlzIGFsd2F5cyBmYWxzZS5cbiAqL1xuLy8gVE9ETyByZXBsYWNlIGNhbGwtc2l0ZXMgd3JpdGVTY2FsYXIoKSBhbmQgd3JpdGVQYWNrZWQoKSwgdGhlbiByZW1vdmVcbmZ1bmN0aW9uIHNjYWxhclR5cGVJbmZvKHR5cGUpIHtcbiAgICBsZXQgd2lyZVR5cGUgPSBXaXJlVHlwZS5WYXJpbnQ7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gSU5UMzIsIFVJTlQzMiwgU0lOVDMyIGFyZSBjb3ZlcmVkIGJ5IHRoZSBkZWZhdWx0c1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICAgICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQ2NDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDMyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9IFNjYWxhclR5cGVbdHlwZV0udG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gW3dpcmVUeXBlLCBtZXRob2RdO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IHNldEVudW1UeXBlIH0gZnJvbSBcIi4vZW51bS5qc1wiO1xuaW1wb3J0IHsgTWVzc2FnZSB9IGZyb20gXCIuLi9tZXNzYWdlLmpzXCI7XG5pbXBvcnQgeyBzY2FsYXJFcXVhbHMgfSBmcm9tIFwiLi9zY2FsYXJzLmpzXCI7XG5pbXBvcnQgeyBTY2FsYXJUeXBlIH0gZnJvbSBcIi4uL3NjYWxhci5qc1wiO1xuaW1wb3J0IHsgaXNNZXNzYWdlIH0gZnJvbSBcIi4uL2lzLW1lc3NhZ2UuanNcIjtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybixAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50LG5vLWNhc2UtZGVjbGFyYXRpb25zICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVV0aWxDb21tb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2V0RW51bVR5cGUsXG4gICAgICAgIGluaXRQYXJ0aWFsKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAoc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdGFyZ2V0LmdldFR5cGUoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbE5hbWUgPSBtZW1iZXIubG9jYWxOYW1lLCB0ID0gdGFyZ2V0LCBzID0gc291cmNlO1xuICAgICAgICAgICAgICAgIGlmIChzW2xvY2FsTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGlmIHNvdXJjZSBpcyBhIE1lc3NhZ2UgaW5zdGFuY2UsIHdlIHNob3VsZCB1c2UgaXNGaWVsZFNldCgpIGhlcmUgdG8gc3VwcG9ydCBmdXR1cmUgZmllbGQgcHJlc2VuY2VcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAobWVtYmVyLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzayA9IHNbbG9jYWxOYW1lXS5jYXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUZpZWxkID0gbWVtYmVyLmZpbmRGaWVsZChzayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gc1tsb2NhbE5hbWVdLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZUZpZWxkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlRmllbGQua2luZCA9PSBcIm1lc3NhZ2VcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc01lc3NhZ2UodmFsLCBzb3VyY2VGaWVsZC5UKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG5ldyBzb3VyY2VGaWVsZC5UKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VGaWVsZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUZpZWxkLmtpbmQgPT09IFwic2NhbGFyXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VGaWVsZC5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdG9VOEFycih2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0geyBjYXNlOiBzaywgdmFsdWU6IHZhbCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb3B5ID0gc1tsb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlci5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weSA9IG1lbWJlci5yZXBlYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNvcHkubWFwKHRvVThBcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdG9VOEFycihjb3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IGNvcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtZW1iZXIuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIuVi5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhzW2xvY2FsTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdW2tdID0gdG9VOEFycih2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odFtsb2NhbE5hbWVdLCBzW2xvY2FsTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gbWVtYmVyLlYuVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKHNbbG9jYWxOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBzW2xvY2FsTmFtZV1ba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgdGFrZSBwYXJ0aWFsIGlucHV0IGZvciBtZXNzYWdlcyB0aGF0IGFyZSBub3QgYSB3cmFwcGVyIHR5cGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRob3NlIG1lc3NhZ2VzLCB3ZSByZWN1cnNpdmVseSBub3JtYWxpemUgdGhlIHBhcnRpYWwgaW5wdXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbmV3IG1lc3NhZ2VUeXBlKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV1ba10gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG10ID0gbWVtYmVyLlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gc1tsb2NhbE5hbWVdLm1hcCgodmFsKSA9PiBpc01lc3NhZ2UodmFsLCBtdCkgPyB2YWwgOiBuZXcgbXQodmFsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBzW2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG10LmZpZWxkV3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IHVzZSBCeXRlc1ZhbHVlLnR5cGVOYW1lIGFzIHRoYXQgd2lsbCBjcmVhdGUgYSBjaXJjdWxhciBpbXBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXQudHlwZU5hbWUgPT09IFwiZ29vZ2xlLnByb3RvYnVmLkJ5dGVzVmFsdWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gdG9VOEFycih2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSBpc01lc3NhZ2UodmFsLCBtdCkgPyB2YWwgOiBuZXcgbXQodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRPRE8gdXNlIGlzRmllbGRTZXQoKSBoZXJlIHRvIHN1cHBvcnQgZnV0dXJlIGZpZWxkIHByZXNlbmNlXG4gICAgICAgIGVxdWFscyh0eXBlLCBhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhIHx8ICFiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkuZXZlcnkoKG0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YSA9IGFbbS5sb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZiID0gYlttLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhLmxlbmd0aCAhPT0gdmIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gcmVwZWF0ZWQgZmllbGRzIGFyZSBuZXZlciBcIm1hcFwiXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobS5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gbS5ULmVxdWFscyhhLCB2YltpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gc2NhbGFyRXF1YWxzKG0uVCwgYSwgdmJbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhLmV2ZXJ5KChhLCBpKSA9PiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgYSwgdmJbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlcGVhdGVkIGNhbm5vdCBjb250YWluICR7bS5raW5kfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG0ua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0uVC5lcXVhbHModmEsIHZiKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgdmEsIHZiKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhtLlQsIHZhLCB2Yik7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhLmNhc2UgIT09IHZiLmNhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gbS5maW5kRmllbGQodmEuY2FzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSBvbmVvZiBmaWVsZHMgYXJlIG5ldmVyIFwibWFwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocy5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuVC5lcXVhbHModmEudmFsdWUsIHZiLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIHZhLnZhbHVlLCB2Yi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGFyRXF1YWxzKHMuVCwgdmEudmFsdWUsIHZiLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25lb2YgY2Fubm90IGNvbnRhaW4gJHtzLmtpbmR9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YSkuY29uY2F0KE9iamVjdC5rZXlzKHZiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG0uVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBtLlYuVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXMuZXZlcnkoKGspID0+IG1lc3NhZ2VUeXBlLmVxdWFscyh2YVtrXSwgdmJba10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeSgoaykgPT4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGFyVHlwZSA9IG0uVi5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeSgoaykgPT4gc2NhbGFyRXF1YWxzKHNjYWxhclR5cGUsIHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRPRE8gdXNlIGlzRmllbGRTZXQoKSBoZXJlIHRvIHN1cHBvcnQgZnV0dXJlIGZpZWxkIHByZXNlbmNlXG4gICAgICAgIGNsb25lKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKSwgdGFyZ2V0ID0gbmV3IHR5cGUoKSwgYW55ID0gdGFyZ2V0O1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdHlwZS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IG1lc3NhZ2VbbWVtYmVyLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgbGV0IGNvcHk7XG4gICAgICAgICAgICAgICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gc291cmNlLm1hcChjbG9uZVNpbmd1bGFyRmllbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZW1iZXIua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBhbnlbbWVtYmVyLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdl0gb2YgT2JqZWN0LmVudHJpZXMoc291cmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weVtrZXldID0gY2xvbmVTaW5ndWxhckZpZWxkKHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lbWJlci5raW5kID09IFwib25lb2ZcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmID0gbWVtYmVyLmZpbmRGaWVsZChzb3VyY2UuY2FzZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBmXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgY2FzZTogc291cmNlLmNhc2UsIHZhbHVlOiBjbG9uZVNpbmd1bGFyRmllbGQoc291cmNlLnZhbHVlKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHsgY2FzZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gY2xvbmVTaW5ndWxhckZpZWxkKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFueVttZW1iZXIubG9jYWxOYW1lXSA9IGNvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVmIG9mIHR5cGUucnVudGltZS5iaW4ubGlzdFVua25vd25GaWVsZHMobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICB0eXBlLnJ1bnRpbWUuYmluLm9uVW5rbm93bkZpZWxkKGFueSwgdWYubm8sIHVmLndpcmVUeXBlLCB1Zi5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIGNsb25lIGEgc2luZ2xlIGZpZWxkIHZhbHVlIC0gaS5lLiB0aGUgZWxlbWVudCB0eXBlIG9mIHJlcGVhdGVkIGZpZWxkcywgdGhlIHZhbHVlIHR5cGUgb2YgbWFwc1xuZnVuY3Rpb24gY2xvbmVTaW5ndWxhckZpZWxkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNNZXNzYWdlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuY2xvbmUoKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGMuc2V0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8vIGNvbnZlcnRzIGFueSBBcnJheUxpa2U8bnVtYmVyPiB0byBVaW50OEFycmF5IGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIHRvVThBcnIoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gaW5wdXQgOiBuZXcgVWludDhBcnJheShpbnB1dCk7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgZ2V0RW51bVR5cGUsIG1ha2VFbnVtLCBtYWtlRW51bVR5cGUgfSBmcm9tIFwiLi9lbnVtLmpzXCI7XG5pbXBvcnQgeyBtYWtlTWVzc2FnZVR5cGUgfSBmcm9tIFwiLi9tZXNzYWdlLXR5cGUuanNcIjtcbmltcG9ydCB7IG1ha2VFeHRlbnNpb24gfSBmcm9tIFwiLi9leHRlbnNpb25zLmpzXCI7XG5pbXBvcnQgeyBtYWtlSnNvbkZvcm1hdCB9IGZyb20gXCIuL2pzb24tZm9ybWF0LmpzXCI7XG5pbXBvcnQgeyBtYWtlQmluYXJ5Rm9ybWF0IH0gZnJvbSBcIi4vYmluYXJ5LWZvcm1hdC5qc1wiO1xuaW1wb3J0IHsgbWFrZVV0aWxDb21tb24gfSBmcm9tIFwiLi91dGlsLWNvbW1vbi5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQcm90b1J1bnRpbWUoc3ludGF4LCBuZXdGaWVsZExpc3QsIGluaXRGaWVsZHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzeW50YXgsXG4gICAgICAgIGpzb246IG1ha2VKc29uRm9ybWF0KCksXG4gICAgICAgIGJpbjogbWFrZUJpbmFyeUZvcm1hdCgpLFxuICAgICAgICB1dGlsOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1ha2VVdGlsQ29tbW9uKCkpLCB7IG5ld0ZpZWxkTGlzdCxcbiAgICAgICAgICAgIGluaXRGaWVsZHMgfSksXG4gICAgICAgIG1ha2VNZXNzYWdlVHlwZSh0eXBlTmFtZSwgZmllbGRzLCBvcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlTWVzc2FnZVR5cGUodGhpcywgdHlwZU5hbWUsIGZpZWxkcywgb3B0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFrZUVudW0sXG4gICAgICAgIG1ha2VFbnVtVHlwZSxcbiAgICAgICAgZ2V0RW51bVR5cGUsXG4gICAgICAgIG1ha2VFeHRlbnNpb24odHlwZU5hbWUsIGV4dGVuZGVlLCBmaWVsZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VFeHRlbnNpb24odGhpcywgdHlwZU5hbWUsIGV4dGVuZGVlLCBmaWVsZCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxGaWVsZExpc3Qge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgbm9ybWFsaXplcikge1xuICAgICAgICB0aGlzLl9maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZXIgPSBub3JtYWxpemVyO1xuICAgIH1cbiAgICBmaW5kSnNvbk5hbWUoanNvbk5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmpzb25OYW1lcykge1xuICAgICAgICAgICAgY29uc3QgdCA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMubGlzdCgpKSB7XG4gICAgICAgICAgICAgICAgdFtmLmpzb25OYW1lXSA9IHRbZi5uYW1lXSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmpzb25OYW1lcyA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuanNvbk5hbWVzW2pzb25OYW1lXTtcbiAgICB9XG4gICAgZmluZChmaWVsZE5vKSB7XG4gICAgICAgIGlmICghdGhpcy5udW1iZXJzKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5saXN0KCkpIHtcbiAgICAgICAgICAgICAgICB0W2Yubm9dID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubnVtYmVycyA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubnVtYmVyc1tmaWVsZE5vXTtcbiAgICB9XG4gICAgbGlzdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbCkge1xuICAgICAgICAgICAgdGhpcy5hbGwgPSB0aGlzLl9ub3JtYWxpemVyKHRoaXMuX2ZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsO1xuICAgIH1cbiAgICBieU51bWJlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm51bWJlcnNBc2MpIHtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyc0FzYyA9IHRoaXMubGlzdCgpXG4gICAgICAgICAgICAgICAgLmNvbmNhdCgpXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEubm8gLSBiLm5vKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5udW1iZXJzQXNjO1xuICAgIH1cbiAgICBieU1lbWJlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lbWJlcnMpIHtcbiAgICAgICAgICAgIHRoaXMubWVtYmVycyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMubWVtYmVycztcbiAgICAgICAgICAgIGxldCBvO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMubGlzdCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGYub25lb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYub25lb2YgIT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBmLm9uZW9mO1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhLnB1c2goZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1lbWJlcnM7XG4gICAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIHByb3RvYnVmIGVsZW1lbnQgaW4gZ2VuZXJhdGVkIGNvZGUuXG4gKlxuICogRmllbGQgbmFtZXMgLSBpbmNsdWRpbmcgb25lb2ZzIC0gYXJlIGNvbnZlcnRlZCB0byBsb3dlckNhbWVsQ2FzZS4gRm9yXG4gKiBtZXNzYWdlcywgZW51bWVyYXRpb25zIGFuZCBzZXJ2aWNlcywgdGhlIHBhY2thZ2UgbmFtZSBpcyBzdHJpcHBlZCBmcm9tXG4gKiB0aGUgdHlwZSBuYW1lLiBGb3IgbmVzdGVkIG1lc3NhZ2VzIGFuZCBlbnVtZXJhdGlvbnMsIHRoZSBuYW1lcyBhcmUgam9pbmVkXG4gKiB3aXRoIGFuIHVuZGVyc2NvcmUuIEZvciBtZXRob2RzLCB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIG1hZGUgbG93ZXJjYXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9jYWxOYW1lKGRlc2MpIHtcbiAgICBzd2l0Y2ggKGRlc2Mua2luZCkge1xuICAgICAgICBjYXNlIFwiZmllbGRcIjpcbiAgICAgICAgICAgIHJldHVybiBsb2NhbEZpZWxkTmFtZShkZXNjLm5hbWUsIGRlc2Mub25lb2YgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsT25lb2ZOYW1lKGRlc2MubmFtZSk7XG4gICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgIGNhc2UgXCJzZXJ2aWNlXCI6XG4gICAgICAgIGNhc2UgXCJleHRlbnNpb25cIjoge1xuICAgICAgICAgICAgY29uc3QgcGtnID0gZGVzYy5maWxlLnByb3RvLnBhY2thZ2U7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBwa2cgPT09IHVuZGVmaW5lZCA/IDAgOiBwa2cubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBkZXNjLnR5cGVOYW1lLnN1YnN0cmluZyhvZmZzZXQpLnJlcGxhY2UoL1xcLi9nLCBcIl9cIik7XG4gICAgICAgICAgICAvLyBGb3Igc2VydmljZXMsIHdlIG9ubHkgY2FyZSBhYm91dCBzYWZlIGlkZW50aWZpZXJzLCBub3Qgc2FmZSBvYmplY3QgcHJvcGVydGllcyxcbiAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIHNoaXBwZWQgdjEgd2l0aCBhIGJ1ZyB0aGF0IHJlc3BlY3RlZCBvYmplY3QgcHJvcGVydGllcywgYW5kIHdlXG4gICAgICAgICAgICAvLyBkbyBub3Qgd2FudCB0byBpbnRyb2R1Y2UgYSBicmVha2luZyBjaGFuZ2UsIHNvIHdlIGNvbnRpbnVlIHRvIGVzY2FwZSBmb3JcbiAgICAgICAgICAgIC8vIHNhZmUgb2JqZWN0IHByb3BlcnRpZXMuXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2J1ZmJ1aWxkL3Byb3RvYnVmLWVzL3B1bGwvMzkxXG4gICAgICAgICAgICByZXR1cm4gc2FmZU9iamVjdFByb3BlcnR5KHNhZmVJZGVudGlmaWVyKG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZW51bV92YWx1ZVwiOiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGRlc2MubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFByZWZpeCA9IGRlc2MucGFyZW50LnNoYXJlZFByZWZpeDtcbiAgICAgICAgICAgIGlmIChzaGFyZWRQcmVmaXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZyhzaGFyZWRQcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzYWZlT2JqZWN0UHJvcGVydHkobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJwY1wiOiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGRlc2MubmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYW1lID0gbmFtZVswXS50b0xvd2VyQ2FzZSgpICsgbmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICByZXR1cm4gc2FmZU9iamVjdFByb3BlcnR5KG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgZmllbGQgaW4gZ2VuZXJhdGVkIGNvZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2NhbEZpZWxkTmFtZShwcm90b05hbWUsIGluT25lb2YpIHtcbiAgICBjb25zdCBuYW1lID0gcHJvdG9DYW1lbENhc2UocHJvdG9OYW1lKTtcbiAgICBpZiAoaW5PbmVvZikge1xuICAgICAgICAvLyBvbmVvZiBtZW1iZXIgbmFtZXMgYXJlIG5vdCBwcm9wZXJ0aWVzLCBidXQgdmFsdWVzIG9mIHRoZSBgY2FzZWAgcHJvcGVydHkuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gc2FmZU9iamVjdFByb3BlcnR5KHNhZmVNZXNzYWdlUHJvcGVydHkobmFtZSkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgb25lb2YgZ3JvdXAgaW4gZ2VuZXJhdGVkIGNvZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2NhbE9uZW9mTmFtZShwcm90b05hbWUpIHtcbiAgICByZXR1cm4gbG9jYWxGaWVsZE5hbWUocHJvdG9OYW1lLCBmYWxzZSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIEpTT04gbmFtZSBmb3IgYSBwcm90b2J1ZiBmaWVsZCwgZXhhY3RseSBsaWtlIHByb3RvYyBkb2VzLlxuICovXG5leHBvcnQgY29uc3QgZmllbGRKc29uTmFtZSA9IHByb3RvQ2FtZWxDYXNlO1xuLyoqXG4gKiBGaW5kcyBhIHByZWZpeCBzaGFyZWQgYnkgZW51bSB2YWx1ZXMsIGZvciBleGFtcGxlIGBNWV9FTlVNX2AgZm9yXG4gKiBgZW51bSBNeUVudW0ge01ZX0VOVU1fQT0wOyBNWV9FTlVNX0I9MTt9YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRFbnVtU2hhcmVkUHJlZml4KGVudW1OYW1lLCB2YWx1ZU5hbWVzKSB7XG4gICAgY29uc3QgcHJlZml4ID0gY2FtZWxUb1NuYWtlQ2FzZShlbnVtTmFtZSkgKyBcIl9cIjtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdmFsdWVOYW1lcykge1xuICAgICAgICBpZiAoIW5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hvcnROYW1lID0gbmFtZS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIGlmIChzaG9ydE5hbWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9eXFxkLy50ZXN0KHNob3J0TmFtZSkpIHtcbiAgICAgICAgICAgIC8vIGlkZW50aWZpZXJzIG11c3Qgbm90IHN0YXJ0IHdpdGggbnVtYmVyc1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJlZml4O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBsb3dlckNhbWVsQ2FzZSBvciBVcHBlckNhbWVsQ2FzZSBpbnRvIGxvd2VyX3NuYWtlX2Nhc2UuXG4gKiBUaGlzIGlzIHVzZWQgdG8gZmluZCBzaGFyZWQgcHJlZml4ZXMgaW4gYW4gZW51bS5cbiAqL1xuZnVuY3Rpb24gY2FtZWxUb1NuYWtlQ2FzZShjYW1lbCkge1xuICAgIHJldHVybiAoY2FtZWwuc3Vic3RyaW5nKDAsIDEpICsgY2FtZWwuc3Vic3RyaW5nKDEpLnJlcGxhY2UoL1tBLVpdL2csIChjKSA9PiBcIl9cIiArIGMpKS50b0xvd2VyQ2FzZSgpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBzbmFrZV9jYXNlIHRvIHByb3RvQ2FtZWxDYXNlIGFjY29yZGluZyB0byB0aGUgY29udmVudGlvblxuICogdXNlZCBieSBwcm90b2MgdG8gY29udmVydCBhIGZpZWxkIG5hbWUgdG8gYSBKU09OIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHByb3RvQ2FtZWxDYXNlKHNuYWtlQ2FzZSkge1xuICAgIGxldCBjYXBOZXh0ID0gZmFsc2U7XG4gICAgY29uc3QgYiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc25ha2VDYXNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjID0gc25ha2VDYXNlLmNoYXJBdChpKTtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICBjYXNlIFwiX1wiOlxuICAgICAgICAgICAgICAgIGNhcE5leHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgICAgICBjYXNlIFwiMlwiOlxuICAgICAgICAgICAgY2FzZSBcIjNcIjpcbiAgICAgICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICAgICAgY2FzZSBcIjZcIjpcbiAgICAgICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICAgICAgY2FzZSBcIjlcIjpcbiAgICAgICAgICAgICAgICBiLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgY2FwTmV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2FwTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBjYXBOZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBjLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIucHVzaChjKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYi5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBpZGVudGlmaWVycywgc3VjaCBhcyBjbGFzcyBuYW1lcyxcbiAqIGJ1dCBfY2FuXyBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcy5cbiAqL1xuY29uc3QgcmVzZXJ2ZWRJZGVudGlmaWVycyA9IG5ldyBTZXQoW1xuICAgIC8vIEVDTUFTY3JpcHQgMjAxNSBrZXl3b3Jkc1xuICAgIFwiYnJlYWtcIixcbiAgICBcImNhc2VcIixcbiAgICBcImNhdGNoXCIsXG4gICAgXCJjbGFzc1wiLFxuICAgIFwiY29uc3RcIixcbiAgICBcImNvbnRpbnVlXCIsXG4gICAgXCJkZWJ1Z2dlclwiLFxuICAgIFwiZGVmYXVsdFwiLFxuICAgIFwiZGVsZXRlXCIsXG4gICAgXCJkb1wiLFxuICAgIFwiZWxzZVwiLFxuICAgIFwiZXhwb3J0XCIsXG4gICAgXCJleHRlbmRzXCIsXG4gICAgXCJmYWxzZVwiLFxuICAgIFwiZmluYWxseVwiLFxuICAgIFwiZm9yXCIsXG4gICAgXCJmdW5jdGlvblwiLFxuICAgIFwiaWZcIixcbiAgICBcImltcG9ydFwiLFxuICAgIFwiaW5cIixcbiAgICBcImluc3RhbmNlb2ZcIixcbiAgICBcIm5ld1wiLFxuICAgIFwibnVsbFwiLFxuICAgIFwicmV0dXJuXCIsXG4gICAgXCJzdXBlclwiLFxuICAgIFwic3dpdGNoXCIsXG4gICAgXCJ0aGlzXCIsXG4gICAgXCJ0aHJvd1wiLFxuICAgIFwidHJ1ZVwiLFxuICAgIFwidHJ5XCIsXG4gICAgXCJ0eXBlb2ZcIixcbiAgICBcInZhclwiLFxuICAgIFwidm9pZFwiLFxuICAgIFwid2hpbGVcIixcbiAgICBcIndpdGhcIixcbiAgICBcInlpZWxkXCIsXG4gICAgLy8gRUNNQVNjcmlwdCAyMDE1IGZ1dHVyZSByZXNlcnZlZCBrZXl3b3Jkc1xuICAgIFwiZW51bVwiLFxuICAgIFwiaW1wbGVtZW50c1wiLFxuICAgIFwiaW50ZXJmYWNlXCIsXG4gICAgXCJsZXRcIixcbiAgICBcInBhY2thZ2VcIixcbiAgICBcInByaXZhdGVcIixcbiAgICBcInByb3RlY3RlZFwiLFxuICAgIFwicHVibGljXCIsXG4gICAgXCJzdGF0aWNcIixcbiAgICAvLyBDbGFzcyBuYW1lIGNhbm5vdCBiZSAnT2JqZWN0JyB3aGVuIHRhcmdldGluZyBFUzUgd2l0aCBtb2R1bGUgQ29tbW9uSlNcbiAgICBcIk9iamVjdFwiLFxuICAgIC8vIFR5cGVTY3JpcHQga2V5d29yZHMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3IgdHlwZXMgKGFzIG9wcG9zZWQgdG8gdmFyaWFibGVzKVxuICAgIFwiYmlnaW50XCIsXG4gICAgXCJudW1iZXJcIixcbiAgICBcImJvb2xlYW5cIixcbiAgICBcInN0cmluZ1wiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgLy8gSWRlbnRpZmllcnMgcmVzZXJ2ZWQgZm9yIHRoZSBydW50aW1lLCBzbyB3ZSBjYW4gZ2VuZXJhdGUgbGVnaWJsZSBjb2RlXG4gICAgXCJnbG9iYWxUaGlzXCIsXG4gICAgXCJVaW50OEFycmF5XCIsXG4gICAgXCJQYXJ0aWFsXCIsXG5dKTtcbi8qKlxuICogTmFtZXMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3Igb2JqZWN0IHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGFyZSByZXNlcnZlZFxuICogYnkgYnVpbHQtaW4gSmF2YVNjcmlwdCBwcm9wZXJ0aWVzLlxuICovXG5jb25zdCByZXNlcnZlZE9iamVjdFByb3BlcnRpZXMgPSBuZXcgU2V0KFtcbiAgICAvLyBuYW1lcyByZXNlcnZlZCBieSBKYXZhU2NyaXB0XG4gICAgXCJjb25zdHJ1Y3RvclwiLFxuICAgIFwidG9TdHJpbmdcIixcbiAgICBcInRvSlNPTlwiLFxuICAgIFwidmFsdWVPZlwiLFxuXSk7XG4vKipcbiAqIE5hbWVzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIG9iamVjdCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBhcmUgcmVzZXJ2ZWRcbiAqIGJ5IHRoZSBydW50aW1lLlxuICovXG5jb25zdCByZXNlcnZlZE1lc3NhZ2VQcm9wZXJ0aWVzID0gbmV3IFNldChbXG4gICAgLy8gbmFtZXMgcmVzZXJ2ZWQgYnkgdGhlIHJ1bnRpbWVcbiAgICBcImdldFR5cGVcIixcbiAgICBcImNsb25lXCIsXG4gICAgXCJlcXVhbHNcIixcbiAgICBcImZyb21CaW5hcnlcIixcbiAgICBcImZyb21Kc29uXCIsXG4gICAgXCJmcm9tSnNvblN0cmluZ1wiLFxuICAgIFwidG9CaW5hcnlcIixcbiAgICBcInRvSnNvblwiLFxuICAgIFwidG9Kc29uU3RyaW5nXCIsXG4gICAgLy8gbmFtZXMgcmVzZXJ2ZWQgYnkgdGhlIHJ1bnRpbWUgZm9yIHRoZSBmdXR1cmVcbiAgICBcInRvT2JqZWN0XCIsXG5dKTtcbmNvbnN0IGZhbGxiYWNrID0gKG5hbWUpID0+IGAke25hbWV9JGA7XG4vKipcbiAqIFdpbGwgd3JhcCBuYW1lcyB0aGF0IGFyZSBPYmplY3QgcHJvdG90eXBlIHByb3BlcnRpZXMgb3IgbmFtZXMgcmVzZXJ2ZWRcbiAqIGZvciBgTWVzc2FnZWBzLlxuICovXG5jb25zdCBzYWZlTWVzc2FnZVByb3BlcnR5ID0gKG5hbWUpID0+IHtcbiAgICBpZiAocmVzZXJ2ZWRNZXNzYWdlUHJvcGVydGllcy5oYXMobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn07XG4vKipcbiAqIE5hbWVzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIG9iamVjdCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBhcmUgcmVzZXJ2ZWRcbiAqIGJ5IGJ1aWx0LWluIEphdmFTY3JpcHQgcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0IGNvbnN0IHNhZmVPYmplY3RQcm9wZXJ0eSA9IChuYW1lKSA9PiB7XG4gICAgaWYgKHJlc2VydmVkT2JqZWN0UHJvcGVydGllcy5oYXMobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn07XG4vKipcbiAqIE5hbWVzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGlkZW50aWZpZXJzIG9yIGNsYXNzIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGNvbnN0IHNhZmVJZGVudGlmaWVyID0gKG5hbWUpID0+IHtcbiAgICBpZiAocmVzZXJ2ZWRJZGVudGlmaWVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgbG9jYWxPbmVvZk5hbWUgfSBmcm9tIFwiLi9uYW1lcy5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4vYXNzZXJ0LmpzXCI7XG5leHBvcnQgY2xhc3MgSW50ZXJuYWxPbmVvZkluZm8ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgdGhpcy5raW5kID0gXCJvbmVvZlwiO1xuICAgICAgICB0aGlzLnJlcGVhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3B0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVxID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5sb2NhbE5hbWUgPSBsb2NhbE9uZW9mTmFtZShuYW1lKTtcbiAgICB9XG4gICAgYWRkRmllbGQoZmllbGQpIHtcbiAgICAgICAgYXNzZXJ0KGZpZWxkLm9uZW9mID09PSB0aGlzLCBgZmllbGQgJHtmaWVsZC5uYW1lfSBub3Qgb25lIG9mICR7dGhpcy5uYW1lfWApO1xuICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICB9XG4gICAgZmluZEZpZWxkKGxvY2FsTmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvb2t1cCkge1xuICAgICAgICAgICAgdGhpcy5fbG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb29rdXBbdGhpcy5maWVsZHNbaV0ubG9jYWxOYW1lXSA9IHRoaXMuZmllbGRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sb29rdXBbbG9jYWxOYW1lXTtcbiAgICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgSW50ZXJuYWxPbmVvZkluZm8gfSBmcm9tIFwiLi9maWVsZC5qc1wiO1xuaW1wb3J0IHsgZmllbGRKc29uTmFtZSwgbG9jYWxGaWVsZE5hbWUgfSBmcm9tIFwiLi9uYW1lcy5qc1wiO1xuaW1wb3J0IHsgTG9uZ1R5cGUsIFNjYWxhclR5cGUgfSBmcm9tIFwiLi4vc2NhbGFyLmpzXCI7XG4vKipcbiAqIENvbnZlcnQgYSBjb2xsZWN0aW9uIG9mIGZpZWxkIGluZm8gdG8gYW4gYXJyYXkgb2Ygbm9ybWFsaXplZCBGaWVsZEluZm8uXG4gKlxuICogVGhlIGFyZ3VtZW50IGBwYWNrZWRCeURlZmF1bHRgIHNwZWNpZmllcyB3aGV0aGVyIGZpZWxkcyB0aGF0IGRvIG5vdCBzcGVjaWZ5XG4gKiBgcGFja2VkYCBzaG91bGQgYmUgcGFja2VkIChwcm90bzMpIG9yIHVucGFja2VkIChwcm90bzIpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRmllbGRJbmZvcyhmaWVsZEluZm9zLCBwYWNrZWRCeURlZmF1bHQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICBjb25zdCByID0gW107XG4gICAgbGV0IG87XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlb2YgZmllbGRJbmZvcyA9PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBmaWVsZEluZm9zKClcbiAgICAgICAgOiBmaWVsZEluZm9zKSB7XG4gICAgICAgIGNvbnN0IGYgPSBmaWVsZDtcbiAgICAgICAgZi5sb2NhbE5hbWUgPSBsb2NhbEZpZWxkTmFtZShmaWVsZC5uYW1lLCBmaWVsZC5vbmVvZiAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgZi5qc29uTmFtZSA9IChfYSA9IGZpZWxkLmpzb25OYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaWVsZEpzb25OYW1lKGZpZWxkLm5hbWUpO1xuICAgICAgICBmLnJlcGVhdGVkID0gKF9iID0gZmllbGQucmVwZWF0ZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgICAgICBpZiAoZmllbGQua2luZCA9PSBcInNjYWxhclwiKSB7XG4gICAgICAgICAgICBmLkwgPSAoX2MgPSBmaWVsZC5MKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBMb25nVHlwZS5CSUdJTlQ7XG4gICAgICAgIH1cbiAgICAgICAgZi5kZWxpbWl0ZWQgPSAoX2QgPSBmaWVsZC5kZWxpbWl0ZWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlO1xuICAgICAgICBmLnJlcSA9IChfZSA9IGZpZWxkLnJlcSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogZmFsc2U7XG4gICAgICAgIGYub3B0ID0gKF9mID0gZmllbGQub3B0KSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBmYWxzZTtcbiAgICAgICAgaWYgKGZpZWxkLnBhY2tlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocGFja2VkQnlEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgZi5wYWNrZWQgPVxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5raW5kID09IFwiZW51bVwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoZmllbGQua2luZCA9PSBcInNjYWxhclwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuVCAhPSBTY2FsYXJUeXBlLkJZVEVTICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuVCAhPSBTY2FsYXJUeXBlLlNUUklORyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmLnBhY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGRvIG5vdCBzdXJmYWNlIG9wdGlvbnMgYXQgdGhpcyB0aW1lXG4gICAgICAgIC8vIGYub3B0aW9ucyA9IGZpZWxkLm9wdGlvbnMgPz8gZW1wdHlSZWFkb25seU9iamVjdDtcbiAgICAgICAgaWYgKGZpZWxkLm9uZW9mICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9vbmFtZSA9IHR5cGVvZiBmaWVsZC5vbmVvZiA9PSBcInN0cmluZ1wiID8gZmllbGQub25lb2YgOiBmaWVsZC5vbmVvZi5uYW1lO1xuICAgICAgICAgICAgaWYgKCFvIHx8IG8ubmFtZSAhPSBvb25hbWUpIHtcbiAgICAgICAgICAgICAgICBvID0gbmV3IEludGVybmFsT25lb2ZJbmZvKG9vbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmLm9uZW9mID0gbztcbiAgICAgICAgICAgIG8uYWRkRmllbGQoZik7XG4gICAgICAgIH1cbiAgICAgICAgci5wdXNoKGYpO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBtYWtlUHJvdG9SdW50aW1lIH0gZnJvbSBcIi4vcHJpdmF0ZS9wcm90by1ydW50aW1lLmpzXCI7XG5pbXBvcnQgeyBJbnRlcm5hbEZpZWxkTGlzdCB9IGZyb20gXCIuL3ByaXZhdGUvZmllbGQtbGlzdC5qc1wiO1xuaW1wb3J0IHsgc2NhbGFyWmVyb1ZhbHVlIH0gZnJvbSBcIi4vcHJpdmF0ZS9zY2FsYXJzLmpzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVGaWVsZEluZm9zIH0gZnJvbSBcIi4vcHJpdmF0ZS9maWVsZC1ub3JtYWxpemUuanNcIjtcbi8qKlxuICogUHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgbWVzc2FnZXMgZGVmaW5lZCB3aXRoIHRoZSBwcm90bzMgc3ludGF4LlxuICovXG5leHBvcnQgY29uc3QgcHJvdG8zID0gbWFrZVByb3RvUnVudGltZShcInByb3RvM1wiLCAoZmllbGRzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBJbnRlcm5hbEZpZWxkTGlzdChmaWVsZHMsIChzb3VyY2UpID0+IG5vcm1hbGl6ZUZpZWxkSW5mb3Moc291cmNlLCB0cnVlKSk7XG59LCBcbi8vIFRPRE8gbWVyZ2Ugd2l0aCBwcm90bzIgYW5kIGluaXRFeHRlbnNpb25GaWVsZCwgYWxzbyBzZWUgaW5pdFBhcnRpYWwsIGVxdWFscywgY2xvbmVcbih0YXJnZXQpID0+IHtcbiAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0YXJnZXQuZ2V0VHlwZSgpLmZpZWxkcy5ieU1lbWJlcigpKSB7XG4gICAgICAgIGlmIChtZW1iZXIub3B0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gbWVtYmVyLmxvY2FsTmFtZSwgdCA9IHRhcmdldDtcbiAgICAgICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xuICAgICAgICAgICAgdFtuYW1lXSA9IFtdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChtZW1iZXIua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICAgICAgdFtuYW1lXSA9IHsgY2FzZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIHRbbmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgIHRbbmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICB0W25hbWVdID0gc2NhbGFyWmVyb1ZhbHVlKG1lbWJlci5ULCBtZW1iZXIuTCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UgZmllbGRzIGFyZSBhbHdheXMgb3B0aW9uYWwgaW4gcHJvdG8zXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIi8vIENvcHlyaWdodCAyMDIzIExpdmVLaXQsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8vIEBnZW5lcmF0ZWQgYnkgcHJvdG9jLWdlbi1lcyB2MS4xMC4wIHdpdGggcGFyYW1ldGVyIFwidGFyZ2V0PWpzK2R0c1wiXG4vLyBAZ2VuZXJhdGVkIGZyb20gZmlsZSBsaXZla2l0X21vZGVscy5wcm90byAocGFja2FnZSBsaXZla2l0LCBzeW50YXggcHJvdG8zKVxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEB0cy1ub2NoZWNrXG5cbmltcG9ydCB7IHByb3RvMywgVGltZXN0YW1wIH0gZnJvbSBcIkBidWZidWlsZC9wcm90b2J1ZlwiO1xuaW1wb3J0IHsgTWV0cmljc0JhdGNoIH0gZnJvbSBcIi4vbGl2ZWtpdF9tZXRyaWNzX3BiLmpzXCI7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5BdWRpb0NvZGVjXG4gKi9cbmV4cG9ydCBjb25zdCBBdWRpb0NvZGVjID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5BdWRpb0NvZGVjXCIsXG4gIFtcbiAgICB7bm86IDAsIG5hbWU6IFwiREVGQVVMVF9BQ1wifSxcbiAgICB7bm86IDEsIG5hbWU6IFwiT1BVU1wifSxcbiAgICB7bm86IDIsIG5hbWU6IFwiQUFDXCJ9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlZpZGVvQ29kZWNcbiAqL1xuZXhwb3J0IGNvbnN0IFZpZGVvQ29kZWMgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LlZpZGVvQ29kZWNcIixcbiAgW1xuICAgIHtubzogMCwgbmFtZTogXCJERUZBVUxUX1ZDXCJ9LFxuICAgIHtubzogMSwgbmFtZTogXCJIMjY0X0JBU0VMSU5FXCJ9LFxuICAgIHtubzogMiwgbmFtZTogXCJIMjY0X01BSU5cIn0sXG4gICAge25vOiAzLCBuYW1lOiBcIkgyNjRfSElHSFwifSxcbiAgICB7bm86IDQsIG5hbWU6IFwiVlA4XCJ9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkltYWdlQ29kZWNcbiAqL1xuZXhwb3J0IGNvbnN0IEltYWdlQ29kZWMgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LkltYWdlQ29kZWNcIixcbiAgW1xuICAgIHtubzogMCwgbmFtZTogXCJJQ19ERUZBVUxUXCJ9LFxuICAgIHtubzogMSwgbmFtZTogXCJJQ19KUEVHXCJ9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlRyYWNrVHlwZVxuICovXG5leHBvcnQgY29uc3QgVHJhY2tUeXBlID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5UcmFja1R5cGVcIixcbiAgW1xuICAgIHtubzogMCwgbmFtZTogXCJBVURJT1wifSxcbiAgICB7bm86IDEsIG5hbWU6IFwiVklERU9cIn0sXG4gICAge25vOiAyLCBuYW1lOiBcIkRBVEFcIn0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuVHJhY2tTb3VyY2VcbiAqL1xuZXhwb3J0IGNvbnN0IFRyYWNrU291cmNlID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5UcmFja1NvdXJjZVwiLFxuICBbXG4gICAge25vOiAwLCBuYW1lOiBcIlVOS05PV05cIn0sXG4gICAge25vOiAxLCBuYW1lOiBcIkNBTUVSQVwifSxcbiAgICB7bm86IDIsIG5hbWU6IFwiTUlDUk9QSE9ORVwifSxcbiAgICB7bm86IDMsIG5hbWU6IFwiU0NSRUVOX1NIQVJFXCJ9LFxuICAgIHtubzogNCwgbmFtZTogXCJTQ1JFRU5fU0hBUkVfQVVESU9cIn0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuVmlkZW9RdWFsaXR5XG4gKi9cbmV4cG9ydCBjb25zdCBWaWRlb1F1YWxpdHkgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LlZpZGVvUXVhbGl0eVwiLFxuICBbXG4gICAge25vOiAwLCBuYW1lOiBcIkxPV1wifSxcbiAgICB7bm86IDEsIG5hbWU6IFwiTUVESVVNXCJ9LFxuICAgIHtubzogMiwgbmFtZTogXCJISUdIXCJ9LFxuICAgIHtubzogMywgbmFtZTogXCJPRkZcIn0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlcbiAqL1xuZXhwb3J0IGNvbnN0IENvbm5lY3Rpb25RdWFsaXR5ID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eVwiLFxuICBbXG4gICAge25vOiAwLCBuYW1lOiBcIlBPT1JcIn0sXG4gICAge25vOiAxLCBuYW1lOiBcIkdPT0RcIn0sXG4gICAge25vOiAyLCBuYW1lOiBcIkVYQ0VMTEVOVFwifSxcbiAgICB7bm86IDMsIG5hbWU6IFwiTE9TVFwifSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5DbGllbnRDb25maWdTZXR0aW5nXG4gKi9cbmV4cG9ydCBjb25zdCBDbGllbnRDb25maWdTZXR0aW5nID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5DbGllbnRDb25maWdTZXR0aW5nXCIsXG4gIFtcbiAgICB7bm86IDAsIG5hbWU6IFwiVU5TRVRcIn0sXG4gICAge25vOiAxLCBuYW1lOiBcIkRJU0FCTEVEXCJ9LFxuICAgIHtubzogMiwgbmFtZTogXCJFTkFCTEVEXCJ9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkRpc2Nvbm5lY3RSZWFzb25cbiAqL1xuZXhwb3J0IGNvbnN0IERpc2Nvbm5lY3RSZWFzb24gPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LkRpc2Nvbm5lY3RSZWFzb25cIixcbiAgW1xuICAgIHtubzogMCwgbmFtZTogXCJVTktOT1dOX1JFQVNPTlwifSxcbiAgICB7bm86IDEsIG5hbWU6IFwiQ0xJRU5UX0lOSVRJQVRFRFwifSxcbiAgICB7bm86IDIsIG5hbWU6IFwiRFVQTElDQVRFX0lERU5USVRZXCJ9LFxuICAgIHtubzogMywgbmFtZTogXCJTRVJWRVJfU0hVVERPV05cIn0sXG4gICAge25vOiA0LCBuYW1lOiBcIlBBUlRJQ0lQQU5UX1JFTU9WRURcIn0sXG4gICAge25vOiA1LCBuYW1lOiBcIlJPT01fREVMRVRFRFwifSxcbiAgICB7bm86IDYsIG5hbWU6IFwiU1RBVEVfTUlTTUFUQ0hcIn0sXG4gICAge25vOiA3LCBuYW1lOiBcIkpPSU5fRkFJTFVSRVwifSxcbiAgICB7bm86IDgsIG5hbWU6IFwiTUlHUkFUSU9OXCJ9LFxuICAgIHtubzogOSwgbmFtZTogXCJTSUdOQUxfQ0xPU0VcIn0sXG4gICAge25vOiAxMCwgbmFtZTogXCJST09NX0NMT1NFRFwifSxcbiAgICB7bm86IDExLCBuYW1lOiBcIlVTRVJfVU5BVkFJTEFCTEVcIn0sXG4gICAge25vOiAxMiwgbmFtZTogXCJVU0VSX1JFSkVDVEVEXCJ9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlJlY29ubmVjdFJlYXNvblxuICovXG5leHBvcnQgY29uc3QgUmVjb25uZWN0UmVhc29uID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5SZWNvbm5lY3RSZWFzb25cIixcbiAgW1xuICAgIHtubzogMCwgbmFtZTogXCJSUl9VTktOT1dOXCJ9LFxuICAgIHtubzogMSwgbmFtZTogXCJSUl9TSUdOQUxfRElTQ09OTkVDVEVEXCJ9LFxuICAgIHtubzogMiwgbmFtZTogXCJSUl9QVUJMSVNIRVJfRkFJTEVEXCJ9LFxuICAgIHtubzogMywgbmFtZTogXCJSUl9TVUJTQ1JJQkVSX0ZBSUxFRFwifSxcbiAgICB7bm86IDQsIG5hbWU6IFwiUlJfU1dJVENIX0NBTkRJREFURVwifSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5TdWJzY3JpcHRpb25FcnJvclxuICovXG5leHBvcnQgY29uc3QgU3Vic2NyaXB0aW9uRXJyb3IgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LlN1YnNjcmlwdGlvbkVycm9yXCIsXG4gIFtcbiAgICB7bm86IDAsIG5hbWU6IFwiU0VfVU5LTk9XTlwifSxcbiAgICB7bm86IDEsIG5hbWU6IFwiU0VfQ09ERUNfVU5TVVBQT1JURURcIn0sXG4gICAge25vOiAyLCBuYW1lOiBcIlNFX1RSQUNLX05PVEZPVU5EXCJ9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkF1ZGlvVHJhY2tGZWF0dXJlXG4gKi9cbmV4cG9ydCBjb25zdCBBdWRpb1RyYWNrRmVhdHVyZSA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuQXVkaW9UcmFja0ZlYXR1cmVcIixcbiAgW1xuICAgIHtubzogMCwgbmFtZTogXCJURl9TVEVSRU9cIn0sXG4gICAge25vOiAxLCBuYW1lOiBcIlRGX05PX0RUWFwifSxcbiAgICB7bm86IDIsIG5hbWU6IFwiVEZfQVVUT19HQUlOX0NPTlRST0xcIn0sXG4gICAge25vOiAzLCBuYW1lOiBcIlRGX0VDSE9fQ0FOQ0VMTEFUSU9OXCJ9LFxuICAgIHtubzogNCwgbmFtZTogXCJURl9OT0lTRV9TVVBQUkVTU0lPTlwifSxcbiAgICB7bm86IDUsIG5hbWU6IFwiVEZfRU5IQU5DRURfTk9JU0VfQ0FOQ0VMTEFUSU9OXCJ9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJvb21cbiAqL1xuZXhwb3J0IGNvbnN0IFJvb20gPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5Sb29tXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInNpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJuYW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImVtcHR5X3RpbWVvdXRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAxNCwgbmFtZTogXCJkZXBhcnR1cmVfdGltZW91dFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwibWF4X3BhcnRpY2lwYW50c1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiY3JlYXRpb25fdGltZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi8gfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcInR1cm5fcGFzc3dvcmRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiZW5hYmxlZF9jb2RlY3NcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENvZGVjLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwibWV0YWRhdGFcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwibnVtX3BhcnRpY2lwYW50c1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDExLCBuYW1lOiBcIm51bV9wdWJsaXNoZXJzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwiYWN0aXZlX3JlY29yZGluZ1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDEzLCBuYW1lOiBcInZlcnNpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVkVmVyc2lvbiB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkNvZGVjXG4gKi9cbmV4cG9ydCBjb25zdCBDb2RlYyA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkNvZGVjXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIm1pbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiZm10cF9saW5lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5QbGF5b3V0RGVsYXlcbiAqL1xuZXhwb3J0IGNvbnN0IFBsYXlvdXREZWxheSA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlBsYXlvdXREZWxheVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJlbmFibGVkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJtaW5cIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIm1heFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlBhcnRpY2lwYW50UGVybWlzc2lvblxuICovXG5leHBvcnQgY29uc3QgUGFydGljaXBhbnRQZXJtaXNzaW9uID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuUGFydGljaXBhbnRQZXJtaXNzaW9uXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImNhbl9zdWJzY3JpYmVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImNhbl9wdWJsaXNoXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJjYW5fcHVibGlzaF9kYXRhXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJjYW5fcHVibGlzaF9zb3VyY2VzXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tTb3VyY2UpLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiaGlkZGVuXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJyZWNvcmRlclwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcImNhbl91cGRhdGVfbWV0YWRhdGFcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiAxMSwgbmFtZTogXCJhZ2VudFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcImNhbl9zdWJzY3JpYmVfbWV0cmljc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlBhcnRpY2lwYW50SW5mb1xuICovXG5leHBvcnQgY29uc3QgUGFydGljaXBhbnRJbmZvID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuUGFydGljaXBhbnRJbmZvXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInNpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJpZGVudGl0eVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJzdGF0ZVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFBhcnRpY2lwYW50SW5mb19TdGF0ZSkgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInRyYWNrc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJhY2tJbmZvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwibWV0YWRhdGFcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiam9pbmVkX2F0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwibmFtZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwidmVyc2lvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDExLCBuYW1lOiBcInBlcm1pc3Npb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFBhcnRpY2lwYW50UGVybWlzc2lvbiB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcInJlZ2lvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMTMsIG5hbWU6IFwiaXNfcHVibGlzaGVyXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogMTQsIG5hbWU6IFwia2luZFwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFBhcnRpY2lwYW50SW5mb19LaW5kKSB9LFxuICAgIHsgbm86IDE1LCBuYW1lOiBcImF0dHJpYnV0ZXNcIiwga2luZDogXCJtYXBcIiwgSzogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgVjoge2tpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi99IH0sXG4gICAgeyBubzogMTYsIG5hbWU6IFwiZGlzY29ubmVjdF9yZWFzb25cIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEaXNjb25uZWN0UmVhc29uKSB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlBhcnRpY2lwYW50SW5mby5TdGF0ZVxuICovXG5leHBvcnQgY29uc3QgUGFydGljaXBhbnRJbmZvX1N0YXRlID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5QYXJ0aWNpcGFudEluZm8uU3RhdGVcIixcbiAgW1xuICAgIHtubzogMCwgbmFtZTogXCJKT0lOSU5HXCJ9LFxuICAgIHtubzogMSwgbmFtZTogXCJKT0lORURcIn0sXG4gICAge25vOiAyLCBuYW1lOiBcIkFDVElWRVwifSxcbiAgICB7bm86IDMsIG5hbWU6IFwiRElTQ09OTkVDVEVEXCJ9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlBhcnRpY2lwYW50SW5mby5LaW5kXG4gKi9cbmV4cG9ydCBjb25zdCBQYXJ0aWNpcGFudEluZm9fS2luZCA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuUGFydGljaXBhbnRJbmZvLktpbmRcIixcbiAgW1xuICAgIHtubzogMCwgbmFtZTogXCJTVEFOREFSRFwifSxcbiAgICB7bm86IDEsIG5hbWU6IFwiSU5HUkVTU1wifSxcbiAgICB7bm86IDIsIG5hbWU6IFwiRUdSRVNTXCJ9LFxuICAgIHtubzogMywgbmFtZTogXCJTSVBcIn0sXG4gICAge25vOiA0LCBuYW1lOiBcIkFHRU5UXCJ9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkVuY3J5cHRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IEVuY3J5cHRpb24gPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5FbmNyeXB0aW9uXCIsXG4gIFtdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkVuY3J5cHRpb24uVHlwZVxuICovXG5leHBvcnQgY29uc3QgRW5jcnlwdGlvbl9UeXBlID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5FbmNyeXB0aW9uLlR5cGVcIixcbiAgW1xuICAgIHtubzogMCwgbmFtZTogXCJOT05FXCJ9LFxuICAgIHtubzogMSwgbmFtZTogXCJHQ01cIn0sXG4gICAge25vOiAyLCBuYW1lOiBcIkNVU1RPTVwifSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TaW11bGNhc3RDb2RlY0luZm9cbiAqL1xuZXhwb3J0IGNvbnN0IFNpbXVsY2FzdENvZGVjSW5mbyA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlNpbXVsY2FzdENvZGVjSW5mb1wiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJtaW1lX3R5cGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwibWlkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImNpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJsYXllcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFZpZGVvTGF5ZXIsIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVHJhY2tJbmZvXG4gKi9cbmV4cG9ydCBjb25zdCBUcmFja0luZm8gPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5UcmFja0luZm9cIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1R5cGUpIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJuYW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcIm11dGVkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJ3aWR0aFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiaGVpZ2h0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJzaW11bGNhc3RcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcImRpc2FibGVfZHR4XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJzb3VyY2VcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1NvdXJjZSkgfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJsYXllcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFZpZGVvTGF5ZXIsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwibWltZV90eXBlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAxMiwgbmFtZTogXCJtaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDEzLCBuYW1lOiBcImNvZGVjc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2ltdWxjYXN0Q29kZWNJbmZvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDE0LCBuYW1lOiBcInN0ZXJlb1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDE1LCBuYW1lOiBcImRpc2FibGVfcmVkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogMTYsIG5hbWU6IFwiZW5jcnlwdGlvblwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKEVuY3J5cHRpb25fVHlwZSkgfSxcbiAgICB7IG5vOiAxNywgbmFtZTogXCJzdHJlYW1cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDE4LCBuYW1lOiBcInZlcnNpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVkVmVyc2lvbiB9LFxuICAgIHsgbm86IDE5LCBuYW1lOiBcImF1ZGlvX2ZlYXR1cmVzXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQXVkaW9UcmFja0ZlYXR1cmUpLCByZXBlYXRlZDogdHJ1ZSB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IGF2YWlsYWJsZSBzcGF0aWFsIGxheWVyc1xuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVmlkZW9MYXllclxuICovXG5leHBvcnQgY29uc3QgVmlkZW9MYXllciA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlZpZGVvTGF5ZXJcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicXVhbGl0eVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSkgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIndpZHRoXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJoZWlnaHRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImJpdHJhdGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcInNzcmNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogbmV3IERhdGFQYWNrZXQgQVBJXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5EYXRhUGFja2V0XG4gKi9cbmV4cG9ydCBjb25zdCBEYXRhUGFja2V0ID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuRGF0YVBhY2tldFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJraW5kXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRGF0YVBhY2tldF9LaW5kKSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiZGVzdGluYXRpb25faWRlbnRpdGllc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidXNlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVXNlclBhY2tldCwgb25lb2Y6IFwidmFsdWVcIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwic3BlYWtlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQWN0aXZlU3BlYWtlclVwZGF0ZSwgb25lb2Y6IFwidmFsdWVcIiB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwic2lwX2R0bWZcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNpcERUTUYsIG9uZW9mOiBcInZhbHVlXCIgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcInRyYW5zY3JpcHRpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyYW5zY3JpcHRpb24sIG9uZW9mOiBcInZhbHVlXCIgfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcIm1ldHJpY3NcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IE1ldHJpY3NCYXRjaCwgb25lb2Y6IFwidmFsdWVcIiB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwiY2hhdF9tZXNzYWdlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBDaGF0TWVzc2FnZSwgb25lb2Y6IFwidmFsdWVcIiB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcInJwY19yZXF1ZXN0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBScGNSZXF1ZXN0LCBvbmVvZjogXCJ2YWx1ZVwiIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwicnBjX2Fja1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUnBjQWNrLCBvbmVvZjogXCJ2YWx1ZVwiIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwicnBjX3Jlc3BvbnNlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBScGNSZXNwb25zZSwgb25lb2Y6IFwidmFsdWVcIiB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LkRhdGFQYWNrZXQuS2luZFxuICovXG5leHBvcnQgY29uc3QgRGF0YVBhY2tldF9LaW5kID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5EYXRhUGFja2V0LktpbmRcIixcbiAgW1xuICAgIHtubzogMCwgbmFtZTogXCJSRUxJQUJMRVwifSxcbiAgICB7bm86IDEsIG5hbWU6IFwiTE9TU1lcIn0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuQWN0aXZlU3BlYWtlclVwZGF0ZVxuICovXG5leHBvcnQgY29uc3QgQWN0aXZlU3BlYWtlclVwZGF0ZSA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkFjdGl2ZVNwZWFrZXJVcGRhdGVcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic3BlYWtlcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNwZWFrZXJJbmZvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlNwZWFrZXJJbmZvXG4gKi9cbmV4cG9ydCBjb25zdCBTcGVha2VySW5mbyA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlNwZWFrZXJJbmZvXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInNpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJsZXZlbFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAyIC8qIFNjYWxhclR5cGUuRkxPQVQgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImFjdGl2ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlVzZXJQYWNrZXRcbiAqL1xuZXhwb3J0IGNvbnN0IFVzZXJQYWNrZXQgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5Vc2VyUGFja2V0XCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJwYXlsb2FkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEyIC8qIFNjYWxhclR5cGUuQllURVMgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImRlc3RpbmF0aW9uX3NpZHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImRlc3RpbmF0aW9uX2lkZW50aXRpZXNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInRvcGljXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwiaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJzdGFydF90aW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi8sIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcImVuZF90aW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi8sIG9wdDogdHJ1ZSB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlNpcERUTUZcbiAqL1xuZXhwb3J0IGNvbnN0IFNpcERUTUYgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TaXBEVE1GXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAzLCBuYW1lOiBcImNvZGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImRpZ2l0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5UcmFuc2NyaXB0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBUcmFuc2NyaXB0aW9uID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVHJhbnNjcmlwdGlvblwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMiwgbmFtZTogXCJ0cmFuc2NyaWJlZF9wYXJ0aWNpcGFudF9pZGVudGl0eVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJ0cmFja19pZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJzZWdtZW50c1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJhbnNjcmlwdGlvblNlZ21lbnQsIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVHJhbnNjcmlwdGlvblNlZ21lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFRyYW5zY3JpcHRpb25TZWdtZW50ID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVHJhbnNjcmlwdGlvblNlZ21lbnRcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidGV4dFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJzdGFydF90aW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi8gfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImVuZF90aW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi8gfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImZpbmFsXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJsYW5ndWFnZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuQ2hhdE1lc3NhZ2VcbiAqL1xuZXhwb3J0IGNvbnN0IENoYXRNZXNzYWdlID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuQ2hhdE1lc3NhZ2VcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidGltZXN0YW1wXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiZWRpdF90aW1lc3RhbXBcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcIm1lc3NhZ2VcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiZGVsZXRlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiZ2VuZXJhdGVkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUnBjUmVxdWVzdFxuICovXG5leHBvcnQgY29uc3QgUnBjUmVxdWVzdCA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlJwY1JlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwibWV0aG9kXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInBheWxvYWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwicmVzcG9uc2VfdGltZW91dF9tc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwidmVyc2lvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJwY0Fja1xuICovXG5leHBvcnQgY29uc3QgUnBjQWNrID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuUnBjQWNrXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInJlcXVlc3RfaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJwY1Jlc3BvbnNlXG4gKi9cbmV4cG9ydCBjb25zdCBScGNSZXNwb25zZSA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlJwY1Jlc3BvbnNlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInJlcXVlc3RfaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicGF5bG9hZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCBvbmVvZjogXCJ2YWx1ZVwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJlcnJvclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUnBjRXJyb3IsIG9uZW9mOiBcInZhbHVlXCIgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5ScGNFcnJvclxuICovXG5leHBvcnQgY29uc3QgUnBjRXJyb3IgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5ScGNFcnJvclwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJjb2RlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJtZXNzYWdlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImRhdGFcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlBhcnRpY2lwYW50VHJhY2tzXG4gKi9cbmV4cG9ydCBjb25zdCBQYXJ0aWNpcGFudFRyYWNrcyA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlBhcnRpY2lwYW50VHJhY2tzXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ0cmFja19zaWRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIGRldGFpbHMgYWJvdXQgdGhlIHNlcnZlclxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU2VydmVySW5mb1xuICovXG5leHBvcnQgY29uc3QgU2VydmVySW5mbyA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlNlcnZlckluZm9cIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiZWRpdGlvblwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFNlcnZlckluZm9fRWRpdGlvbikgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInZlcnNpb25cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwicHJvdG9jb2xcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJyZWdpb25cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwibm9kZV9pZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJkZWJ1Z19pbmZvXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcImFnZW50X3Byb3RvY29sXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqLyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gZW51bSBsaXZla2l0LlNlcnZlckluZm8uRWRpdGlvblxuICovXG5leHBvcnQgY29uc3QgU2VydmVySW5mb19FZGl0aW9uID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5TZXJ2ZXJJbmZvLkVkaXRpb25cIixcbiAgW1xuICAgIHtubzogMCwgbmFtZTogXCJTdGFuZGFyZFwifSxcbiAgICB7bm86IDEsIG5hbWU6IFwiQ2xvdWRcIn0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIGRldGFpbHMgYWJvdXQgdGhlIGNsaWVudFxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuQ2xpZW50SW5mb1xuICovXG5leHBvcnQgY29uc3QgQ2xpZW50SW5mbyA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkNsaWVudEluZm9cIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic2RrXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50SW5mb19TREspIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ2ZXJzaW9uXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInByb3RvY29sXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqLyB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwib3NcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwib3NfdmVyc2lvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJkZXZpY2VfbW9kZWxcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiYnJvd3NlclwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJicm93c2VyX3ZlcnNpb25cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwiYWRkcmVzc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwibmV0d29ya1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwib3RoZXJfc2Rrc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuQ2xpZW50SW5mby5TREtcbiAqL1xuZXhwb3J0IGNvbnN0IENsaWVudEluZm9fU0RLID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5DbGllbnRJbmZvLlNES1wiLFxuICBbXG4gICAge25vOiAwLCBuYW1lOiBcIlVOS05PV05cIn0sXG4gICAge25vOiAxLCBuYW1lOiBcIkpTXCJ9LFxuICAgIHtubzogMiwgbmFtZTogXCJTV0lGVFwifSxcbiAgICB7bm86IDMsIG5hbWU6IFwiQU5EUk9JRFwifSxcbiAgICB7bm86IDQsIG5hbWU6IFwiRkxVVFRFUlwifSxcbiAgICB7bm86IDUsIG5hbWU6IFwiR09cIn0sXG4gICAge25vOiA2LCBuYW1lOiBcIlVOSVRZXCJ9LFxuICAgIHtubzogNywgbmFtZTogXCJSRUFDVF9OQVRJVkVcIn0sXG4gICAge25vOiA4LCBuYW1lOiBcIlJVU1RcIn0sXG4gICAge25vOiA5LCBuYW1lOiBcIlBZVEhPTlwifSxcbiAgICB7bm86IDEwLCBuYW1lOiBcIkNQUFwifSxcbiAgICB7bm86IDExLCBuYW1lOiBcIlVOSVRZX1dFQlwifSxcbiAgICB7bm86IDEyLCBuYW1lOiBcIk5PREVcIn0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIHNlcnZlciBwcm92aWRlZCBjbGllbnQgY29uZmlndXJhdGlvblxuICpcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuQ2xpZW50Q29uZmlndXJhdGlvblxuICovXG5leHBvcnQgY29uc3QgQ2xpZW50Q29uZmlndXJhdGlvbiA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkNsaWVudENvbmZpZ3VyYXRpb25cIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidmlkZW9cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFZpZGVvQ29uZmlndXJhdGlvbiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwic2NyZWVuXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBWaWRlb0NvbmZpZ3VyYXRpb24gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInJlc3VtZV9jb25uZWN0aW9uXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZykgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImRpc2FibGVkX2NvZGVjc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRGlzYWJsZWRDb2RlY3MgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImZvcmNlX3JlbGF5XCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZykgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5WaWRlb0NvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IFZpZGVvQ29uZmlndXJhdGlvbiA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlZpZGVvQ29uZmlndXJhdGlvblwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJoYXJkd2FyZV9lbmNvZGVyXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZykgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5EaXNhYmxlZENvZGVjc1xuICovXG5leHBvcnQgY29uc3QgRGlzYWJsZWRDb2RlY3MgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5EaXNhYmxlZENvZGVjc1wiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJjb2RlY3NcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENvZGVjLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicHVibGlzaFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQ29kZWMsIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUlRQRHJpZnRcbiAqL1xuZXhwb3J0IGNvbnN0IFJUUERyaWZ0ID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuUlRQRHJpZnRcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic3RhcnRfdGltZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZXN0YW1wIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJlbmRfdGltZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZXN0YW1wIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJkdXJhdGlvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJzdGFydF90aW1lc3RhbXBcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqLyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiZW5kX3RpbWVzdGFtcFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJydHBfY2xvY2tfdGlja3NcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqLyB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiZHJpZnRfc2FtcGxlc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi8gfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcImRyaWZ0X21zXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi8gfSxcbiAgICB7IG5vOiA5LCBuYW1lOiBcImNsb2NrX3JhdGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqLyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJUUFN0YXRzXG4gKi9cbmV4cG9ydCBjb25zdCBSVFBTdGF0cyA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlJUUFN0YXRzXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInN0YXJ0X3RpbWVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVzdGFtcCB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiZW5kX3RpbWVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVzdGFtcCB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiZHVyYXRpb25cIiwga2luZDogXCJzY2FsYXJcIiwgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqLyB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwicGFja2V0c1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwicGFja2V0X3JhdGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMSAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqLyB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiYnl0ZXNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqLyB9LFxuICAgIHsgbm86IDM5LCBuYW1lOiBcImhlYWRlcl9ieXRlc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJiaXRyYXRlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi8gfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcInBhY2tldHNfbG9zdFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwicGFja2V0X2xvc3NfcmF0ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwicGFja2V0X2xvc3NfcGVyY2VudGFnZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAyIC8qIFNjYWxhclR5cGUuRkxPQVQgKi8gfSxcbiAgICB7IG5vOiAxMSwgbmFtZTogXCJwYWNrZXRzX2R1cGxpY2F0ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcInBhY2tldF9kdXBsaWNhdGVfcmF0ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogMTMsIG5hbWU6IFwiYnl0ZXNfZHVwbGljYXRlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi8gfSxcbiAgICB7IG5vOiA0MCwgbmFtZTogXCJoZWFkZXJfYnl0ZXNfZHVwbGljYXRlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi8gfSxcbiAgICB7IG5vOiAxNCwgbmFtZTogXCJiaXRyYXRlX2R1cGxpY2F0ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogMTUsIG5hbWU6IFwicGFja2V0c19wYWRkaW5nXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMTYsIG5hbWU6IFwicGFja2V0X3BhZGRpbmdfcmF0ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogMTcsIG5hbWU6IFwiYnl0ZXNfcGFkZGluZ1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovIH0sXG4gICAgeyBubzogNDEsIG5hbWU6IFwiaGVhZGVyX2J5dGVzX3BhZGRpbmdcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqLyB9LFxuICAgIHsgbm86IDE4LCBuYW1lOiBcImJpdHJhdGVfcGFkZGluZ1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogMTksIG5hbWU6IFwicGFja2V0c19vdXRfb2Zfb3JkZXJcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAyMCwgbmFtZTogXCJmcmFtZXNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAyMSwgbmFtZTogXCJmcmFtZV9yYXRlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi8gfSxcbiAgICB7IG5vOiAyMiwgbmFtZTogXCJqaXR0ZXJfY3VycmVudFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogMjMsIG5hbWU6IFwiaml0dGVyX21heFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxIC8qIFNjYWxhclR5cGUuRE9VQkxFICovIH0sXG4gICAgeyBubzogMjQsIG5hbWU6IFwiZ2FwX2hpc3RvZ3JhbVwiLCBraW5kOiBcIm1hcFwiLCBLOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8sIFY6IHtraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL30gfSxcbiAgICB7IG5vOiAyNSwgbmFtZTogXCJuYWNrc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDM3LCBuYW1lOiBcIm5hY2tfYWNrc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDI2LCBuYW1lOiBcIm5hY2tfbWlzc2VzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMzgsIG5hbWU6IFwibmFja19yZXBlYXRlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDI3LCBuYW1lOiBcInBsaXNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAyOCwgbmFtZTogXCJsYXN0X3BsaVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZXN0YW1wIH0sXG4gICAgeyBubzogMjksIG5hbWU6IFwiZmlyc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDMwLCBuYW1lOiBcImxhc3RfZmlyXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lc3RhbXAgfSxcbiAgICB7IG5vOiAzMSwgbmFtZTogXCJydHRfY3VycmVudFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDMyLCBuYW1lOiBcInJ0dF9tYXhcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAzMywgbmFtZTogXCJrZXlfZnJhbWVzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMzQsIG5hbWU6IFwibGFzdF9rZXlfZnJhbWVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVzdGFtcCB9LFxuICAgIHsgbm86IDM1LCBuYW1lOiBcImxheWVyX2xvY2tfcGxpc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDM2LCBuYW1lOiBcImxhc3RfbGF5ZXJfbG9ja19wbGlcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRpbWVzdGFtcCB9LFxuICAgIHsgbm86IDQ0LCBuYW1lOiBcInBhY2tldF9kcmlmdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUlRQRHJpZnQgfSxcbiAgICB7IG5vOiA0NSwgbmFtZTogXCJudHBfcmVwb3J0X2RyaWZ0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBSVFBEcmlmdCB9LFxuICAgIHsgbm86IDQ2LCBuYW1lOiBcInJlYmFzZWRfcmVwb3J0X2RyaWZ0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBSVFBEcmlmdCB9LFxuICAgIHsgbm86IDQ3LCBuYW1lOiBcInJlY2VpdmVkX3JlcG9ydF9kcmlmdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUlRQRHJpZnQgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5SVENQU2VuZGVyUmVwb3J0U3RhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IFJUQ1BTZW5kZXJSZXBvcnRTdGF0ZSA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlJUQ1BTZW5kZXJSZXBvcnRTdGF0ZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJydHBfdGltZXN0YW1wXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJydHBfdGltZXN0YW1wX2V4dFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJudHBfdGltZXN0YW1wXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi8gfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImF0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiYXRfYWRqdXN0ZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJwYWNrZXRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJvY3RldHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqLyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJUUEZvcndhcmRlclN0YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBSVFBGb3J3YXJkZXJTdGF0ZSA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlJUUEZvcndhcmRlclN0YXRlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInN0YXJ0ZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInJlZmVyZW5jZV9sYXllcl9zcGF0aWFsXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwicHJlX3N0YXJ0X3RpbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJleHRfZmlyc3RfdGltZXN0YW1wXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi8gfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImR1bW15X3N0YXJ0X3RpbWVzdGFtcF9vZmZzZXRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNCAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqLyB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwicnRwX211bmdlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUlRQTXVuZ2VyU3RhdGUgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcInZwOF9tdW5nZXJcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFZQOE11bmdlclN0YXRlLCBvbmVvZjogXCJjb2RlY19tdW5nZXJcIiB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwic2VuZGVyX3JlcG9ydF9zdGF0ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUlRDUFNlbmRlclJlcG9ydFN0YXRlLCByZXBlYXRlZDogdHJ1ZSB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJUUE11bmdlclN0YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBSVFBNdW5nZXJTdGF0ZSA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlJUUE11bmdlclN0YXRlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImV4dF9sYXN0X3NlcXVlbmNlX251bWJlclwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJleHRfc2Vjb25kX2xhc3Rfc2VxdWVuY2VfbnVtYmVyXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImV4dF9sYXN0X3RpbWVzdGFtcFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA0IC8qIFNjYWxhclR5cGUuVUlOVDY0ICovIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJleHRfc2Vjb25kX2xhc3RfdGltZXN0YW1wXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi8gfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImxhc3RfbWFya2VyXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJzZWNvbmRfbGFzdF9tYXJrZXJcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5WUDhNdW5nZXJTdGF0ZVxuICovXG5leHBvcnQgY29uc3QgVlA4TXVuZ2VyU3RhdGUgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5WUDhNdW5nZXJTdGF0ZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJleHRfbGFzdF9waWN0dXJlX2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicGljdHVyZV9pZF91c2VkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJsYXN0X3RsMF9waWNfaWR4XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJ0bDBfcGljX2lkeF91c2VkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJ0aWRfdXNlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwibGFzdF9rZXlfaWR4XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJrZXlfaWR4X3VzZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5UaW1lZFZlcnNpb25cbiAqL1xuZXhwb3J0IGNvbnN0IFRpbWVkVmVyc2lvbiA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlRpbWVkVmVyc2lvblwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ1bml4X21pY3JvXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidGlja3NcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovIH0sXG4gIF0sXG4pO1xuXG4iLCIvLyBDb3B5cmlnaHQgMjAyMyBMaXZlS2l0LCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vLyBAZ2VuZXJhdGVkIGJ5IHByb3RvYy1nZW4tZXMgdjEuMTAuMCB3aXRoIHBhcmFtZXRlciBcInRhcmdldD1qcytkdHNcIlxuLy8gQGdlbmVyYXRlZCBmcm9tIGZpbGUgbGl2ZWtpdF9ydGMucHJvdG8gKHBhY2thZ2UgbGl2ZWtpdCwgc3ludGF4IHByb3RvMylcbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBAdHMtbm9jaGVja1xuXG5pbXBvcnQgeyBwcm90bzMgfSBmcm9tIFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmXCI7XG5pbXBvcnQgeyBBdWRpb1RyYWNrRmVhdHVyZSwgQ2xpZW50Q29uZmlndXJhdGlvbiwgQ29kZWMsIENvbm5lY3Rpb25RdWFsaXR5LCBEaXNjb25uZWN0UmVhc29uLCBFbmNyeXB0aW9uX1R5cGUsIFBhcnRpY2lwYW50SW5mbywgUGFydGljaXBhbnRUcmFja3MsIFJvb20sIFNlcnZlckluZm8sIFNwZWFrZXJJbmZvLCBTdWJzY3JpcHRpb25FcnJvciwgVHJhY2tJbmZvLCBUcmFja1NvdXJjZSwgVHJhY2tUeXBlLCBWaWRlb0xheWVyLCBWaWRlb1F1YWxpdHkgfSBmcm9tIFwiLi9saXZla2l0X21vZGVsc19wYi5qc1wiO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuU2lnbmFsVGFyZ2V0XG4gKi9cbmV4cG9ydCBjb25zdCBTaWduYWxUYXJnZXQgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LlNpZ25hbFRhcmdldFwiLFxuICBbXG4gICAge25vOiAwLCBuYW1lOiBcIlBVQkxJU0hFUlwifSxcbiAgICB7bm86IDEsIG5hbWU6IFwiU1VCU0NSSUJFUlwifSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5TdHJlYW1TdGF0ZVxuICovXG5leHBvcnQgY29uc3QgU3RyZWFtU3RhdGUgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LlN0cmVhbVN0YXRlXCIsXG4gIFtcbiAgICB7bm86IDAsIG5hbWU6IFwiQUNUSVZFXCJ9LFxuICAgIHtubzogMSwgbmFtZTogXCJQQVVTRURcIn0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuQ2FuZGlkYXRlUHJvdG9jb2xcbiAqL1xuZXhwb3J0IGNvbnN0IENhbmRpZGF0ZVByb3RvY29sID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5DYW5kaWRhdGVQcm90b2NvbFwiLFxuICBbXG4gICAge25vOiAwLCBuYW1lOiBcIlVEUFwifSxcbiAgICB7bm86IDEsIG5hbWU6IFwiVENQXCJ9LFxuICAgIHtubzogMiwgbmFtZTogXCJUTFNcIn0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU2lnbmFsUmVxdWVzdFxuICovXG5leHBvcnQgY29uc3QgU2lnbmFsUmVxdWVzdCA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlNpZ25hbFJlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwib2ZmZXJcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNlc3Npb25EZXNjcmlwdGlvbiwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJhbnN3ZXJcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNlc3Npb25EZXNjcmlwdGlvbiwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJ0cmlja2xlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUcmlja2xlUmVxdWVzdCwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJhZGRfdHJhY2tcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEFkZFRyYWNrUmVxdWVzdCwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJtdXRlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBNdXRlVHJhY2tSZXF1ZXN0LCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcInN1YnNjcmlwdGlvblwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVXBkYXRlU3Vic2NyaXB0aW9uLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcInRyYWNrX3NldHRpbmdcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFVwZGF0ZVRyYWNrU2V0dGluZ3MsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwibGVhdmVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IExlYXZlUmVxdWVzdCwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwidXBkYXRlX2xheWVyc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVXBkYXRlVmlkZW9MYXllcnMsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDExLCBuYW1lOiBcInN1YnNjcmlwdGlvbl9wZXJtaXNzaW9uXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxMiwgbmFtZTogXCJzeW5jX3N0YXRlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTeW5jU3RhdGUsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDEzLCBuYW1lOiBcInNpbXVsYXRlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTaW11bGF0ZVNjZW5hcmlvLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxNCwgbmFtZTogXCJwaW5nXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLywgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTUsIG5hbWU6IFwidXBkYXRlX21ldGFkYXRhXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxNiwgbmFtZTogXCJwaW5nX3JlcVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUGluZywgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTcsIG5hbWU6IFwidXBkYXRlX2F1ZGlvX3RyYWNrXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBVcGRhdGVMb2NhbEF1ZGlvVHJhY2ssIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDE4LCBuYW1lOiBcInVwZGF0ZV92aWRlb190cmFja1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVXBkYXRlTG9jYWxWaWRlb1RyYWNrLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TaWduYWxSZXNwb25zZVxuICovXG5leHBvcnQgY29uc3QgU2lnbmFsUmVzcG9uc2UgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TaWduYWxSZXNwb25zZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJqb2luXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBKb2luUmVzcG9uc2UsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiYW5zd2VyXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTZXNzaW9uRGVzY3JpcHRpb24sIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwib2ZmZXJcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNlc3Npb25EZXNjcmlwdGlvbiwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJ0cmlja2xlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUcmlja2xlUmVxdWVzdCwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJ1cGRhdGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFBhcnRpY2lwYW50VXBkYXRlLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcInRyYWNrX3B1Ymxpc2hlZFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJhY2tQdWJsaXNoZWRSZXNwb25zZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJsZWF2ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogTGVhdmVSZXF1ZXN0LCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiA5LCBuYW1lOiBcIm11dGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IE11dGVUcmFja1JlcXVlc3QsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcInNwZWFrZXJzX2NoYW5nZWRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNwZWFrZXJzQ2hhbmdlZCwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwicm9vbV91cGRhdGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJvb21VcGRhdGUsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcImNvbm5lY3Rpb25fcXVhbGl0eVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDEzLCBuYW1lOiBcInN0cmVhbV9zdGF0ZV91cGRhdGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN0cmVhbVN0YXRlVXBkYXRlLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxNCwgbmFtZTogXCJzdWJzY3JpYmVkX3F1YWxpdHlfdXBkYXRlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTUsIG5hbWU6IFwic3Vic2NyaXB0aW9uX3Blcm1pc3Npb25fdXBkYXRlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxNiwgbmFtZTogXCJyZWZyZXNoX3Rva2VuXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDE3LCBuYW1lOiBcInRyYWNrX3VucHVibGlzaGVkXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUcmFja1VucHVibGlzaGVkUmVzcG9uc2UsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDE4LCBuYW1lOiBcInBvbmdcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxOSwgbmFtZTogXCJyZWNvbm5lY3RcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJlY29ubmVjdFJlc3BvbnNlLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAyMCwgbmFtZTogXCJwb25nX3Jlc3BcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFBvbmcsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDIxLCBuYW1lOiBcInN1YnNjcmlwdGlvbl9yZXNwb25zZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3Vic2NyaXB0aW9uUmVzcG9uc2UsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDIyLCBuYW1lOiBcInJlcXVlc3RfcmVzcG9uc2VcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJlcXVlc3RSZXNwb25zZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMjMsIG5hbWU6IFwidHJhY2tfc3Vic2NyaWJlZFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJhY2tTdWJzY3JpYmVkLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TaW11bGNhc3RDb2RlY1xuICovXG5leHBvcnQgY29uc3QgU2ltdWxjYXN0Q29kZWMgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TaW11bGNhc3RDb2RlY1wiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJjb2RlY1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJjaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkFkZFRyYWNrUmVxdWVzdFxuICovXG5leHBvcnQgY29uc3QgQWRkVHJhY2tSZXF1ZXN0ID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuQWRkVHJhY2tSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImNpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJuYW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1R5cGUpIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJ3aWR0aFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiaGVpZ2h0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJtdXRlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiZGlzYWJsZV9kdHhcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcInNvdXJjZVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrU291cmNlKSB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwibGF5ZXJzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBWaWRlb0xheWVyLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcInNpbXVsY2FzdF9jb2RlY3NcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNpbXVsY2FzdENvZGVjLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDExLCBuYW1lOiBcInNpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwic3RlcmVvXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogMTMsIG5hbWU6IFwiZGlzYWJsZV9yZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgICB7IG5vOiAxNCwgbmFtZTogXCJlbmNyeXB0aW9uXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jcnlwdGlvbl9UeXBlKSB9LFxuICAgIHsgbm86IDE1LCBuYW1lOiBcInN0cmVhbVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVHJpY2tsZVJlcXVlc3RcbiAqL1xuZXhwb3J0IGNvbnN0IFRyaWNrbGVSZXF1ZXN0ID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVHJpY2tsZVJlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiY2FuZGlkYXRlSW5pdFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ0YXJnZXRcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTaWduYWxUYXJnZXQpIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJmaW5hbFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0Lk11dGVUcmFja1JlcXVlc3RcbiAqL1xuZXhwb3J0IGNvbnN0IE11dGVUcmFja1JlcXVlc3QgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5NdXRlVHJhY2tSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInNpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJtdXRlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkpvaW5SZXNwb25zZVxuICovXG5leHBvcnQgY29uc3QgSm9pblJlc3BvbnNlID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuSm9pblJlc3BvbnNlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInJvb21cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJvb20gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInBhcnRpY2lwYW50XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBQYXJ0aWNpcGFudEluZm8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIm90aGVyX3BhcnRpY2lwYW50c1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUGFydGljaXBhbnRJbmZvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwic2VydmVyX3ZlcnNpb25cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiaWNlX3NlcnZlcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IElDRVNlcnZlciwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcInN1YnNjcmliZXJfcHJpbWFyeVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiYWx0ZXJuYXRpdmVfdXJsXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcImNsaWVudF9jb25maWd1cmF0aW9uXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBDbGllbnRDb25maWd1cmF0aW9uIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJzZXJ2ZXJfcmVnaW9uXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJwaW5nX3RpbWVvdXRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwicGluZ19pbnRlcnZhbFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbiAgICB7IG5vOiAxMiwgbmFtZTogXCJzZXJ2ZXJfaW5mb1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2VydmVySW5mbyB9LFxuICAgIHsgbm86IDEzLCBuYW1lOiBcInNpZl90cmFpbGVyXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEyIC8qIFNjYWxhclR5cGUuQllURVMgKi8gfSxcbiAgICB7IG5vOiAxNCwgbmFtZTogXCJlbmFibGVkX3B1Ymxpc2hfY29kZWNzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBDb2RlYywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAxNSwgbmFtZTogXCJmYXN0X3B1Ymxpc2hcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5SZWNvbm5lY3RSZXNwb25zZVxuICovXG5leHBvcnQgY29uc3QgUmVjb25uZWN0UmVzcG9uc2UgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5SZWNvbm5lY3RSZXNwb25zZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJpY2Vfc2VydmVyc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogSUNFU2VydmVyLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiY2xpZW50X2NvbmZpZ3VyYXRpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENsaWVudENvbmZpZ3VyYXRpb24gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5UcmFja1B1Ymxpc2hlZFJlc3BvbnNlXG4gKi9cbmV4cG9ydCBjb25zdCBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVHJhY2tQdWJsaXNoZWRSZXNwb25zZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJjaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidHJhY2tcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyYWNrSW5mbyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZVxuICovXG5leHBvcnQgY29uc3QgVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInRyYWNrX3NpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU2Vzc2lvbkRlc2NyaXB0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBTZXNzaW9uRGVzY3JpcHRpb24gPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TZXNzaW9uRGVzY3JpcHRpb25cIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJzZHBcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlBhcnRpY2lwYW50VXBkYXRlXG4gKi9cbmV4cG9ydCBjb25zdCBQYXJ0aWNpcGFudFVwZGF0ZSA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlBhcnRpY2lwYW50VXBkYXRlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInBhcnRpY2lwYW50c1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUGFydGljaXBhbnRJbmZvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlVwZGF0ZVN1YnNjcmlwdGlvblxuICovXG5leHBvcnQgY29uc3QgVXBkYXRlU3Vic2NyaXB0aW9uID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVXBkYXRlU3Vic2NyaXB0aW9uXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInRyYWNrX3NpZHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInN1YnNjcmliZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwicGFydGljaXBhbnRfdHJhY2tzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBQYXJ0aWNpcGFudFRyYWNrcywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5VcGRhdGVUcmFja1NldHRpbmdzXG4gKi9cbmV4cG9ydCBjb25zdCBVcGRhdGVUcmFja1NldHRpbmdzID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVXBkYXRlVHJhY2tTZXR0aW5nc1wiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ0cmFja19zaWRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJkaXNhYmxlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwicXVhbGl0eVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSkgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcIndpZHRoXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJoZWlnaHRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcImZwc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMyAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqLyB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwicHJpb3JpdHlcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5VcGRhdGVMb2NhbEF1ZGlvVHJhY2tcbiAqL1xuZXhwb3J0IGNvbnN0IFVwZGF0ZUxvY2FsQXVkaW9UcmFjayA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlVwZGF0ZUxvY2FsQXVkaW9UcmFja1wiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ0cmFja19zaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiZmVhdHVyZXNcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShBdWRpb1RyYWNrRmVhdHVyZSksIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuVXBkYXRlTG9jYWxWaWRlb1RyYWNrXG4gKi9cbmV4cG9ydCBjb25zdCBVcGRhdGVMb2NhbFZpZGVvVHJhY2sgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5VcGRhdGVMb2NhbFZpZGVvVHJhY2tcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidHJhY2tfc2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIndpZHRoXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJoZWlnaHRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMTMgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5MZWF2ZVJlcXVlc3RcbiAqL1xuZXhwb3J0IGNvbnN0IExlYXZlUmVxdWVzdCA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkxlYXZlUmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJjYW5fcmVjb25uZWN0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJyZWFzb25cIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEaXNjb25uZWN0UmVhc29uKSB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiYWN0aW9uXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoTGVhdmVSZXF1ZXN0X0FjdGlvbikgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInJlZ2lvbnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJlZ2lvblNldHRpbmdzIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIGluZGljYXRlcyBhY3Rpb24gY2xpZW50cyBzaG91bGQgdGFrZSBvbiByZWNlaXZpbmcgdGhpcyBtZXNzYWdlXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIGVudW0gbGl2ZWtpdC5MZWF2ZVJlcXVlc3QuQWN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBMZWF2ZVJlcXVlc3RfQWN0aW9uID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5MZWF2ZVJlcXVlc3QuQWN0aW9uXCIsXG4gIFtcbiAgICB7bm86IDAsIG5hbWU6IFwiRElTQ09OTkVDVFwifSxcbiAgICB7bm86IDEsIG5hbWU6IFwiUkVTVU1FXCJ9LFxuICAgIHtubzogMiwgbmFtZTogXCJSRUNPTk5FQ1RcIn0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIG1lc3NhZ2UgdG8gaW5kaWNhdGUgcHVibGlzaGVkIHZpZGVvIHRyYWNrIGRpbWVuc2lvbnMgYXJlIGNoYW5naW5nXG4gKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5VcGRhdGVWaWRlb0xheWVyc1xuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IFVwZGF0ZVZpZGVvTGF5ZXJzID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVXBkYXRlVmlkZW9MYXllcnNcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidHJhY2tfc2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImxheWVyc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVmlkZW9MYXllciwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5VcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJtZXRhZGF0YVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJuYW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImF0dHJpYnV0ZXNcIiwga2luZDogXCJtYXBcIiwgSzogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLywgVjoge2tpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi99IH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJyZXF1ZXN0X2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuSUNFU2VydmVyXG4gKi9cbmV4cG9ydCBjb25zdCBJQ0VTZXJ2ZXIgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5JQ0VTZXJ2ZXJcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidXJsc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidXNlcm5hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiY3JlZGVudGlhbFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3BlYWtlcnNDaGFuZ2VkXG4gKi9cbmV4cG9ydCBjb25zdCBTcGVha2Vyc0NoYW5nZWQgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TcGVha2Vyc0NoYW5nZWRcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic3BlYWtlcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNwZWFrZXJJbmZvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlJvb21VcGRhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IFJvb21VcGRhdGUgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5Sb29tVXBkYXRlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInJvb21cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJvb20gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eUluZm9cbiAqL1xuZXhwb3J0IGNvbnN0IENvbm5lY3Rpb25RdWFsaXR5SW5mbyA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5SW5mb1wiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicXVhbGl0eVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKENvbm5lY3Rpb25RdWFsaXR5KSB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwic2NvcmVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMiAvKiBTY2FsYXJUeXBlLkZMT0FUICovIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGVcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidXBkYXRlc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQ29ubmVjdGlvblF1YWxpdHlJbmZvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN0cmVhbVN0YXRlSW5mb1xuICovXG5leHBvcnQgY29uc3QgU3RyZWFtU3RhdGVJbmZvID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuU3RyZWFtU3RhdGVJbmZvXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ0cmFja19zaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwic3RhdGVcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTdHJlYW1TdGF0ZSkgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TdHJlYW1TdGF0ZVVwZGF0ZVxuICovXG5leHBvcnQgY29uc3QgU3RyZWFtU3RhdGVVcGRhdGUgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TdHJlYW1TdGF0ZVVwZGF0ZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzdHJlYW1fc3RhdGVzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTdHJlYW1TdGF0ZUluZm8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3Vic2NyaWJlZFF1YWxpdHlcbiAqL1xuZXhwb3J0IGNvbnN0IFN1YnNjcmliZWRRdWFsaXR5ID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuU3Vic2NyaWJlZFF1YWxpdHlcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicXVhbGl0eVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSkgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImVuYWJsZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TdWJzY3JpYmVkQ29kZWNcbiAqL1xuZXhwb3J0IGNvbnN0IFN1YnNjcmliZWRDb2RlYyA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlN1YnNjcmliZWRDb2RlY1wiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJjb2RlY1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJxdWFsaXRpZXNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN1YnNjcmliZWRRdWFsaXR5LCByZXBlYXRlZDogdHJ1ZSB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlXG4gKi9cbmV4cG9ydCBjb25zdCBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInRyYWNrX3NpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJzdWJzY3JpYmVkX3F1YWxpdGllc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3Vic2NyaWJlZFF1YWxpdHksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJzdWJzY3JpYmVkX2NvZGVjc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3Vic2NyaWJlZENvZGVjLCByZXBlYXRlZDogdHJ1ZSB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlRyYWNrUGVybWlzc2lvblxuICovXG5leHBvcnQgY29uc3QgVHJhY2tQZXJtaXNzaW9uID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVHJhY2tQZXJtaXNzaW9uXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJhbGxfdHJhY2tzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJ0cmFja19zaWRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblxuICovXG5leHBvcnQgY29uc3QgU3Vic2NyaXB0aW9uUGVybWlzc2lvbiA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlN1YnNjcmlwdGlvblBlcm1pc3Npb25cIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiYWxsX3BhcnRpY2lwYW50c1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidHJhY2tfcGVybWlzc2lvbnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyYWNrUGVybWlzc2lvbiwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXG4gKi9cbmV4cG9ydCBjb25zdCBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidHJhY2tfc2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImFsbG93ZWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8gfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5TeW5jU3RhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IFN5bmNTdGF0ZSA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlN5bmNTdGF0ZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJhbnN3ZXJcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNlc3Npb25EZXNjcmlwdGlvbiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwic3Vic2NyaXB0aW9uXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBVcGRhdGVTdWJzY3JpcHRpb24gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInB1Ymxpc2hfdHJhY2tzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiZGF0YV9jaGFubmVsc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRGF0YUNoYW5uZWxJbmZvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwib2ZmZXJcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNlc3Npb25EZXNjcmlwdGlvbiB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwidHJhY2tfc2lkc19kaXNhYmxlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovLCByZXBlYXRlZDogdHJ1ZSB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LkRhdGFDaGFubmVsSW5mb1xuICovXG5leHBvcnQgY29uc3QgRGF0YUNoYW5uZWxJbmZvID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuRGF0YUNoYW5uZWxJbmZvXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImxhYmVsXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImlkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJ0YXJnZXRcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTaWduYWxUYXJnZXQpIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuU2ltdWxhdGVTY2VuYXJpb1xuICovXG5leHBvcnQgY29uc3QgU2ltdWxhdGVTY2VuYXJpbyA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlNpbXVsYXRlU2NlbmFyaW9cIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic3BlYWtlcl91cGRhdGVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovLCBvbmVvZjogXCJzY2VuYXJpb1wiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJub2RlX2ZhaWx1cmVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCAvKiBTY2FsYXJUeXBlLkJPT0wgKi8sIG9uZW9mOiBcInNjZW5hcmlvXCIgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIm1pZ3JhdGlvblwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb25lb2Y6IFwic2NlbmFyaW9cIiB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwic2VydmVyX2xlYXZlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLCBvbmVvZjogXCJzY2VuYXJpb1wiIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJzd2l0Y2hfY2FuZGlkYXRlX3Byb3RvY29sXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2FuZGlkYXRlUHJvdG9jb2wpLCBvbmVvZjogXCJzY2VuYXJpb1wiIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJzdWJzY3JpYmVyX2JhbmR3aWR0aFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi8sIG9uZW9mOiBcInNjZW5hcmlvXCIgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcImRpc2Nvbm5lY3Rfc2lnbmFsX29uX3Jlc3VtZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4IC8qIFNjYWxhclR5cGUuQk9PTCAqLywgb25lb2Y6IFwic2NlbmFyaW9cIiB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwiZGlzY29ubmVjdF9zaWduYWxfb25fcmVzdW1lX25vX21lc3NhZ2VzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLCBvbmVvZjogXCJzY2VuYXJpb1wiIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJsZWF2ZV9yZXF1ZXN0X2Z1bGxfcmVjb25uZWN0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDggLyogU2NhbGFyVHlwZS5CT09MICovLCBvbmVvZjogXCJzY2VuYXJpb1wiIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUGluZ1xuICovXG5leHBvcnQgY29uc3QgUGluZyA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlBpbmdcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidGltZXN0YW1wXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicnR0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlBvbmdcbiAqL1xuZXhwb3J0IGNvbnN0IFBvbmcgPSAvKkBfX1BVUkVfXyovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5Qb25nXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImxhc3RfcGluZ190aW1lc3RhbXBcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ0aW1lc3RhbXBcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGxpdmVraXQuUmVnaW9uU2V0dGluZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IFJlZ2lvblNldHRpbmdzID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuUmVnaW9uU2V0dGluZ3NcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicmVnaW9uc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUmVnaW9uSW5mbywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5SZWdpb25JbmZvXG4gKi9cbmV4cG9ydCBjb25zdCBSZWdpb25JbmZvID0gLypAX19QVVJFX18qLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuUmVnaW9uSW5mb1wiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJyZWdpb25cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidXJsXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDkgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi8gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImRpc3RhbmNlXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqLyB9LFxuICBdLFxuKTtcblxuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBsaXZla2l0LlN1YnNjcmlwdGlvblJlc3BvbnNlXG4gKi9cbmV4cG9ydCBjb25zdCBTdWJzY3JpcHRpb25SZXNwb25zZSA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlN1YnNjcmlwdGlvblJlc3BvbnNlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInRyYWNrX3NpZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJlcnJcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTdWJzY3JpcHRpb25FcnJvcikgfSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5SZXF1ZXN0UmVzcG9uc2VcbiAqL1xuZXhwb3J0IGNvbnN0IFJlcXVlc3RSZXNwb25zZSA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlJlcXVlc3RSZXNwb25zZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJyZXF1ZXN0X2lkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDEzIC8qIFNjYWxhclR5cGUuVUlOVDMyICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJyZWFzb25cIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShSZXF1ZXN0UmVzcG9uc2VfUmVhc29uKSB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwibWVzc2FnZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5IC8qIFNjYWxhclR5cGUuU1RSSU5HICovIH0sXG4gIF0sXG4pO1xuXG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBlbnVtIGxpdmVraXQuUmVxdWVzdFJlc3BvbnNlLlJlYXNvblxuICovXG5leHBvcnQgY29uc3QgUmVxdWVzdFJlc3BvbnNlX1JlYXNvbiA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuUmVxdWVzdFJlc3BvbnNlLlJlYXNvblwiLFxuICBbXG4gICAge25vOiAwLCBuYW1lOiBcIk9LXCJ9LFxuICAgIHtubzogMSwgbmFtZTogXCJOT1RfRk9VTkRcIn0sXG4gICAge25vOiAyLCBuYW1lOiBcIk5PVF9BTExPV0VEXCJ9LFxuICAgIHtubzogMywgbmFtZTogXCJMSU1JVF9FWENFRURFRFwifSxcbiAgXSxcbik7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIG1lc3NhZ2UgbGl2ZWtpdC5UcmFja1N1YnNjcmliZWRcbiAqL1xuZXhwb3J0IGNvbnN0IFRyYWNrU3Vic2NyaWJlZCA9IC8qQF9fUFVSRV9fKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlRyYWNrU3Vic2NyaWJlZFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ0cmFja19zaWRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSAvKiBTY2FsYXJUeXBlLlNUUklORyAqLyB9LFxuICBdLFxuKTtcblxuIiwiLy8gdGlueSwgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9sYW5jZWRpa3Nvbi9ib3dzZXIvYmxvYi9tYXN0ZXIvc3JjL3BhcnNlci1icm93c2Vycy5qc1xuLy8gcmVkdWNlZCB0byBvbmx5IGRpZmZlcmVudGlhdGUgQ2hyb21lKGl1bSkgYmFzZWQgYnJvd3NlcnMgLyBGaXJlZm94IC8gU2FmYXJpXG5cbmNvbnN0IGNvbW1vblZlcnNpb25JZGVudGlmaWVyID0gL3ZlcnNpb25cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2k7XG5cbmV4cG9ydCB0eXBlIERldGVjdGFibGVCcm93c2VyID0gJ0Nocm9tZScgfCAnRmlyZWZveCcgfCAnU2FmYXJpJztcbmV4cG9ydCB0eXBlIERldGVjdGFibGVPUyA9ICdpT1MnIHwgJ21hY09TJztcblxuZXhwb3J0IHR5cGUgQnJvd3NlckRldGFpbHMgPSB7XG4gIG5hbWU6IERldGVjdGFibGVCcm93c2VyO1xuICB2ZXJzaW9uOiBzdHJpbmc7XG4gIG9zPzogRGV0ZWN0YWJsZU9TO1xuICBvc1ZlcnNpb24/OiBzdHJpbmc7XG59O1xuXG5sZXQgYnJvd3NlckRldGFpbHM6IEJyb3dzZXJEZXRhaWxzIHwgdW5kZWZpbmVkO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnJvd3Nlcih1c2VyQWdlbnQ/OiBzdHJpbmcsIGZvcmNlID0gdHJ1ZSk6IEJyb3dzZXJEZXRhaWxzIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHR5cGVvZiB1c2VyQWdlbnQgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVhID0gKHVzZXJBZ2VudCA/PyBuYXZpZ2F0b3IudXNlckFnZW50KS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoYnJvd3NlckRldGFpbHMgPT09IHVuZGVmaW5lZCB8fCBmb3JjZSkge1xuICAgIGNvbnN0IGJyb3dzZXIgPSBicm93c2Vyc0xpc3QuZmluZCgoeyB0ZXN0IH0pID0+IHRlc3QudGVzdCh1YSkpO1xuICAgIGJyb3dzZXJEZXRhaWxzID0gYnJvd3Nlcj8uZGVzY3JpYmUodWEpO1xuICB9XG4gIHJldHVybiBicm93c2VyRGV0YWlscztcbn1cblxuY29uc3QgYnJvd3NlcnNMaXN0ID0gW1xuICB7XG4gICAgdGVzdDogL2ZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zL2ksXG4gICAgZGVzY3JpYmUodWE6IHN0cmluZykge1xuICAgICAgY29uc3QgYnJvd3NlcjogQnJvd3NlckRldGFpbHMgPSB7XG4gICAgICAgIG5hbWU6ICdGaXJlZm94JyxcbiAgICAgICAgdmVyc2lvbjogZ2V0TWF0Y2goLyg/OmZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSwgdWEpLFxuICAgICAgICBvczogdWEudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZnhpb3MnKSA/ICdpT1MnIDogdW5kZWZpbmVkLFxuICAgICAgICBvc1ZlcnNpb246IGdldE9TVmVyc2lvbih1YSksXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGJyb3dzZXI7XG4gICAgfSxcbiAgfSxcbiAge1xuICAgIHRlc3Q6IC9jaHJvbXxjcmlvc3xjcm1vL2ksXG4gICAgZGVzY3JpYmUodWE6IHN0cmluZykge1xuICAgICAgY29uc3QgYnJvd3NlcjogQnJvd3NlckRldGFpbHMgPSB7XG4gICAgICAgIG5hbWU6ICdDaHJvbWUnLFxuICAgICAgICB2ZXJzaW9uOiBnZXRNYXRjaCgvKD86Y2hyb21lfGNocm9taXVtfGNyaW9zfGNybW8pXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLCB1YSksXG4gICAgICAgIG9zOiB1YS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdjcmlvcycpID8gJ2lPUycgOiB1bmRlZmluZWQsXG4gICAgICAgIG9zVmVyc2lvbjogZ2V0T1NWZXJzaW9uKHVhKSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBicm93c2VyO1xuICAgIH0sXG4gIH0sXG4gIC8qIFNhZmFyaSAqL1xuICB7XG4gICAgdGVzdDogL3NhZmFyaXxhcHBsZXdlYmtpdC9pLFxuICAgIGRlc2NyaWJlKHVhOiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IGJyb3dzZXI6IEJyb3dzZXJEZXRhaWxzID0ge1xuICAgICAgICBuYW1lOiAnU2FmYXJpJyxcbiAgICAgICAgdmVyc2lvbjogZ2V0TWF0Y2goY29tbW9uVmVyc2lvbklkZW50aWZpZXIsIHVhKSxcbiAgICAgICAgb3M6IHVhLmluY2x1ZGVzKCdtb2JpbGUvJykgPyAnaU9TJyA6ICdtYWNPUycsXG4gICAgICAgIG9zVmVyc2lvbjogZ2V0T1NWZXJzaW9uKHVhKSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBicm93c2VyO1xuICAgIH0sXG4gIH0sXG5dO1xuXG5mdW5jdGlvbiBnZXRNYXRjaChleHA6IFJlZ0V4cCwgdWE6IHN0cmluZywgaWQgPSAxKSB7XG4gIGNvbnN0IG1hdGNoID0gdWEubWF0Y2goZXhwKTtcbiAgcmV0dXJuIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPj0gaWQgJiYgbWF0Y2hbaWRdKSB8fCAnJztcbn1cblxuZnVuY3Rpb24gZ2V0T1NWZXJzaW9uKHVhOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHVhLmluY2x1ZGVzKCdtYWMgb3MnKVxuICAgID8gZ2V0TWF0Y2goL1xcKC4rPyhcXGQrX1xcZCsoOj9fXFxkKyk/KS8sIHVhLCAxKS5yZXBsYWNlKC9fL2csICcuJylcbiAgICA6IHVuZGVmaW5lZDtcbn1cbiIsImltcG9ydCB0eXBlIHsgVHJhY2sgfSBmcm9tICcuL1RyYWNrJztcbmltcG9ydCB0eXBlIHtcbiAgQXVkaW9Qcm9jZXNzb3JPcHRpb25zLFxuICBUcmFja1Byb2Nlc3NvcixcbiAgVmlkZW9Qcm9jZXNzb3JPcHRpb25zLFxufSBmcm9tICcuL3Byb2Nlc3Nvci90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhY2tQdWJsaXNoRGVmYXVsdHMge1xuICAvKipcbiAgICogZW5jb2RpbmcgcGFyYW1ldGVycyBmb3IgY2FtZXJhIHRyYWNrXG4gICAqL1xuICB2aWRlb0VuY29kaW5nPzogVmlkZW9FbmNvZGluZztcblxuICAvKipcbiAgICogTXVsdGktY29kZWMgU2ltdWxjYXN0XG4gICAqIFZQOSBhbmQgQVYxIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGFsbCBicm93c2VyIGNsaWVudHMuIFdoZW4gYmFja3VwQ29kZWMgaXNcbiAgICogc2V0LCB3aGVuIGFuIGluY29tcGF0aWJsZSBjbGllbnQgYXR0ZW1wdHMgdG8gc3Vic2NyaWJlIHRvIHRoZSB0cmFjaywgTGl2ZUtpdFxuICAgKiB3aWxsIGF1dG9tYXRpY2FsbHkgcHVibGlzaCBhIHNlY29uZGFyeSB0cmFjayBlbmNvZGVkIHdpdGggdGhlIGJhY2t1cCBjb2RlYy5cbiAgICpcbiAgICogWW91IGNvdWxkIGN1c3RvbWl6ZSBzcGVjaWZpYyBlbmNvZGluZyBwYXJhbWV0ZXJzIG9mIHRoZSBiYWNrdXAgdHJhY2sgYnlcbiAgICogZXhwbGljaXRseSBzZXR0aW5nIGNvZGVjIGFuZCBlbmNvZGluZyBmaWVsZHMuXG4gICAqXG4gICAqIERlZmF1bHRzIHRvIGB0cnVlYFxuICAgKi9cbiAgYmFja3VwQ29kZWM/OiB0cnVlIHwgZmFsc2UgfCB7IGNvZGVjOiBCYWNrdXBWaWRlb0NvZGVjOyBlbmNvZGluZz86IFZpZGVvRW5jb2RpbmcgfTtcblxuICAvKipcbiAgICogZW5jb2RpbmcgcGFyYW1ldGVycyBmb3Igc2NyZWVuIHNoYXJlIHRyYWNrXG4gICAqL1xuICBzY3JlZW5TaGFyZUVuY29kaW5nPzogVmlkZW9FbmNvZGluZztcblxuICAvKipcbiAgICogY29kZWMsIGRlZmF1bHRzIHRvIHZwODsgZm9yIHN2YyBjb2RlY3MsIGF1dG8gZW5hYmxlIHZwOFxuICAgKiBhcyBiYWNrdXAuIChUQkQpXG4gICAqL1xuICB2aWRlb0NvZGVjPzogVmlkZW9Db2RlYztcblxuICAvKipcbiAgICogd2hpY2ggYXVkaW8gcHJlc2V0IHNob3VsZCBiZSB1c2VkIGZvciBwdWJsaXNoaW5nIChhdWRpbykgdHJhY2tzXG4gICAqIGRlZmF1bHRzIHRvIFtbQXVkaW9QcmVzZXRzLm11c2ljXV1cbiAgICovXG4gIGF1ZGlvUHJlc2V0PzogQXVkaW9QcmVzZXQ7XG5cbiAgLyoqXG4gICAqIGR0eCAoRGlzY29udGludW91cyBUcmFuc21pc3Npb24gb2YgYXVkaW8pLCBlbmFibGVkIGJ5IGRlZmF1bHQgZm9yIG1vbm8gdHJhY2tzLlxuICAgKi9cbiAgZHR4PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogcmVkIChSZWR1bmRhbnQgQXVkaW8gRGF0YSksIGVuYWJsZWQgYnkgZGVmYXVsdCBmb3IgbW9ubyB0cmFja3MuXG4gICAqL1xuICByZWQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBwdWJsaXNoIHRyYWNrIGluIHN0ZXJlbyBtb2RlIChvciBzZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSkuIGRlZmF1bHRzIGRldGVybWluZWQgYnkgY2FwdHVyZSBjaGFubmVsIGNvdW50LlxuICAgKi9cbiAgZm9yY2VTdGVyZW8/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiB1c2Ugc2ltdWxjYXN0LCBkZWZhdWx0cyB0byB0cnVlLlxuICAgKiBXaGVuIHVzaW5nIHNpbXVsY2FzdCwgTGl2ZUtpdCB3aWxsIHB1Ymxpc2ggdXAgdG8gdGhyZWUgdmVyc2lvbnMgb2YgdGhlIHN0cmVhbVxuICAgKiBhdCB2YXJpb3VzIHJlc29sdXRpb25zLlxuICAgKi9cbiAgc2ltdWxjYXN0PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogc2NhbGFiaWxpdHkgbW9kZSBmb3Igc3ZjIGNvZGVjcywgZGVmYXVsdHMgdG8gJ0wzVDNfS0VZJy5cbiAgICogZm9yIHN2YyBjb2RlY3MsIHNpbXVsY2FzdCBpcyBkaXNhYmxlZC5cbiAgICovXG4gIHNjYWxhYmlsaXR5TW9kZT86IFNjYWxhYmlsaXR5TW9kZTtcblxuICAvKipcbiAgICogZGVncmFkYXRpb24gcHJlZmVyZW5jZVxuICAgKi9cbiAgZGVncmFkYXRpb25QcmVmZXJlbmNlPzogUlRDRGVncmFkYXRpb25QcmVmZXJlbmNlO1xuXG4gIC8qKlxuICAgKiBVcCB0byB0d28gYWRkaXRpb25hbCBzaW11bGNhc3QgbGF5ZXJzIHRvIHB1Ymxpc2ggaW4gYWRkaXRpb24gdG8gdGhlIG9yaWdpbmFsXG4gICAqIFRyYWNrLlxuICAgKiBXaGVuIGxlZnQgYmxhbmssIGl0IGRlZmF1bHRzIHRvIGgxODAsIGgzNjAuXG4gICAqIElmIGEgU1ZDIGNvZGVjIGlzIHVzZWQgKFZQOSBvciBBVjEpLCB0aGlzIGZpZWxkIGhhcyBubyBlZmZlY3QuXG4gICAqXG4gICAqIFRvIHB1Ymxpc2ggdGhyZWUgdG90YWwgbGF5ZXJzLCB5b3Ugd291bGQgc3BlY2lmeTpcbiAgICoge1xuICAgKiAgIHZpZGVvRW5jb2Rpbmc6IHsuLi59LCAvLyBlbmNvZGluZyBvZiB0aGUgcHJpbWFyeSBsYXllclxuICAgKiAgIHZpZGVvU2ltdWxjYXN0TGF5ZXJzOiBbXG4gICAqICAgICBWaWRlb1ByZXNldHMuaDU0MCxcbiAgICogICAgIFZpZGVvUHJlc2V0cy5oMjE2LFxuICAgKiAgIF0sXG4gICAqIH1cbiAgICovXG4gIHZpZGVvU2ltdWxjYXN0TGF5ZXJzPzogQXJyYXk8VmlkZW9QcmVzZXQ+O1xuXG4gIC8qKlxuICAgKiBjdXN0b20gdmlkZW8gc2ltdWxjYXN0IGxheWVycyBmb3Igc2NyZWVuIHRyYWNrc1xuICAgKiBOb3RlOiB0aGUgbGF5ZXJzIG5lZWQgdG8gYmUgb3JkZXJlZCBmcm9tIGxvd2VzdCB0byBoaWdoZXN0IHF1YWxpdHlcbiAgICovXG4gIHNjcmVlblNoYXJlU2ltdWxjYXN0TGF5ZXJzPzogQXJyYXk8VmlkZW9QcmVzZXQ+O1xuXG4gIC8qKlxuICAgKiBGb3IgbG9jYWwgdHJhY2tzLCBzdG9wIHRoZSB1bmRlcmx5aW5nIE1lZGlhU3RyZWFtVHJhY2sgd2hlbiB0aGUgdHJhY2sgaXMgbXV0ZWQgKG9yIHBhdXNlZClcbiAgICogb24gc29tZSBwbGF0Zm9ybXMsIHRoaXMgb3B0aW9uIGlzIG5lY2Vzc2FyeSB0byBkaXNhYmxlIHRoZSBtaWNyb3Bob25lIHJlY29yZGluZyBpbmRpY2F0b3IuXG4gICAqIE5vdGU6IHdoZW4gdGhpcyBpcyBlbmFibGVkLCBhbmQgQlQgZGV2aWNlcyBhcmUgY29ubmVjdGVkLCB0aGV5IHdpbGwgdHJhbnNpdGlvbiBiZXR3ZWVuXG4gICAqIHByb2ZpbGVzIChlLmcuIEhGUCB0byBBMkRQKSBhbmQgdGhlcmUgd2lsbCBiZSBhbiBhdWRpYmxlIGRpZmZlcmVuY2UgaW4gcGxheWJhY2suXG4gICAqXG4gICAqIGRlZmF1bHRzIHRvIGZhbHNlXG4gICAqL1xuICBzdG9wTWljVHJhY2tPbk11dGU/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgd2hlbiBwdWJsaXNoaW5nIHRyYWNrc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYWNrUHVibGlzaE9wdGlvbnMgZXh0ZW5kcyBUcmFja1B1Ymxpc2hEZWZhdWx0cyB7XG4gIC8qKlxuICAgKiBzZXQgYSB0cmFjayBuYW1lXG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTb3VyY2Ugb2YgdHJhY2ssIGNhbWVyYSwgbWljcm9waG9uZSwgb3Igc2NyZWVuXG4gICAqL1xuICBzb3VyY2U/OiBUcmFjay5Tb3VyY2U7XG5cbiAgLyoqXG4gICAqIFNldCBzdHJlYW0gbmFtZSBmb3IgdGhlIHRyYWNrLiBBdWRpbyBhbmQgdmlkZW8gdHJhY2tzIHdpdGggdGhlIHNhbWUgc3RyZWFtIG5hbWVcbiAgICogd2lsbCBiZSBwbGFjZWQgaW4gdGhlIHNhbWUgYE1lZGlhU3RyZWFtYCBhbmQgb2ZmZXIgYmV0dGVyIHN5bmNocm9uaXphdGlvbi5cbiAgICogQnkgZGVmYXVsdCwgY2FtZXJhIGFuZCBtaWNyb3Bob25lIHdpbGwgYmUgcGxhY2VkIGluIGEgc3RyZWFtOyBhcyB3b3VsZCBzY3JlZW5fc2hhcmUgYW5kIHNjcmVlbl9zaGFyZV9hdWRpb1xuICAgKi9cbiAgc3RyZWFtPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZUxvY2FsVHJhY2tzT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBhdWRpbyB0cmFjayBvcHRpb25zLCB0cnVlIHRvIGNyZWF0ZSB3aXRoIGRlZmF1bHRzLiBmYWxzZSBpZiBhdWRpbyBzaG91bGRuJ3QgYmUgY3JlYXRlZFxuICAgKiBkZWZhdWx0IHRydWVcbiAgICovXG4gIGF1ZGlvPzogYm9vbGVhbiB8IEF1ZGlvQ2FwdHVyZU9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIHZpZGVvIHRyYWNrIG9wdGlvbnMsIHRydWUgdG8gY3JlYXRlIHdpdGggZGVmYXVsdHMuIGZhbHNlIGlmIHZpZGVvIHNob3VsZG4ndCBiZSBjcmVhdGVkXG4gICAqIGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgdmlkZW8/OiBib29sZWFuIHwgVmlkZW9DYXB0dXJlT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaWRlb0NhcHR1cmVPcHRpb25zIHtcbiAgLyoqXG4gICAqIEEgQ29uc3RyYWluRE9NU3RyaW5nIG9iamVjdCBzcGVjaWZ5aW5nIGEgZGV2aWNlIElEIG9yIGFuIGFycmF5IG9mIGRldmljZVxuICAgKiBJRHMgd2hpY2ggYXJlIGFjY2VwdGFibGUgYW5kL29yIHJlcXVpcmVkLlxuICAgKi9cbiAgZGV2aWNlSWQ/OiBDb25zdHJhaW5ET01TdHJpbmc7XG5cbiAgLyoqXG4gICAqIGEgZmFjaW5nIG9yIGFuIGFycmF5IG9mIGZhY2luZ3Mgd2hpY2ggYXJlIGFjY2VwdGFibGUgYW5kL29yIHJlcXVpcmVkLlxuICAgKi9cbiAgZmFjaW5nTW9kZT86ICd1c2VyJyB8ICdlbnZpcm9ubWVudCcgfCAnbGVmdCcgfCAncmlnaHQnO1xuXG4gIHJlc29sdXRpb24/OiBWaWRlb1Jlc29sdXRpb247XG5cbiAgLyoqXG4gICAqIGluaXRpYWxpemUgdGhlIHRyYWNrIHdpdGggYSBnaXZlbiBwcm9jZXNzb3JcbiAgICovXG4gIHByb2Nlc3Nvcj86IFRyYWNrUHJvY2Vzc29yPFRyYWNrLktpbmQuVmlkZW8sIFZpZGVvUHJvY2Vzc29yT3B0aW9ucz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NyZWVuU2hhcmVDYXB0dXJlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiB0cnVlIHRvIGNhcHR1cmUgYXVkaW8gc2hhcmVkLiBicm93c2VyIHN1cHBvcnQgZm9yIGF1ZGlvIGNhcHR1cmluZyBpblxuICAgKiBzY3JlZW5zaGFyZSBpcyBsaW1pdGVkOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFEZXZpY2VzL2dldERpc3BsYXlNZWRpYSNicm93c2VyX2NvbXBhdGliaWxpdHlcbiAgICovXG4gIGF1ZGlvPzogYm9vbGVhbiB8IEF1ZGlvQ2FwdHVyZU9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIG9ubHkgYWxsb3dzIGZvciAndHJ1ZScgYW5kIGNocm9tZSBhbGxvd3MgZm9yIGFkZGl0aW9uYWwgb3B0aW9ucyB0byBiZSBwYXNzZWQgaW5cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kb2NzL3dlYi1wbGF0Zm9ybS9zY3JlZW4tc2hhcmluZy1jb250cm9scy8jZGlzcGxheVN1cmZhY2VcbiAgICovXG4gIHZpZGVvPzogdHJ1ZSB8IHsgZGlzcGxheVN1cmZhY2U/OiAnd2luZG93JyB8ICdicm93c2VyJyB8ICdtb25pdG9yJyB9O1xuXG4gIC8qKlxuICAgKiBjYXB0dXJlIHJlc29sdXRpb24sIGRlZmF1bHRzIHRvIDEwODAgZm9yIGFsbCBicm93c2VycyBvdGhlciB0aGFuIFNhZmFyaVxuICAgKiBPbiBTYWZhcmkgMTcsIGRlZmF1bHQgcmVzb2x1dGlvbiBpcyBub3QgY2FwcGVkLCBkdWUgdG8gYSBidWcsIHNwZWNpZnlpbmdcbiAgICogYW55IHJlc29sdXRpb24gYXQgYWxsIHdvdWxkIGxlYWQgdG8gYSBsb3ctcmVzb2x1dGlvbiBjYXB0dXJlLlxuICAgKiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjYzMDE1XG4gICAqL1xuICByZXNvbHV0aW9uPzogVmlkZW9SZXNvbHV0aW9uO1xuXG4gIC8qKiBhIENhcHR1cmVDb250cm9sbGVyIG9iamVjdCBpbnN0YW5jZSBjb250YWluaW5nIG1ldGhvZHMgdGhhdCBjYW4gYmUgdXNlZCB0byBmdXJ0aGVyIG1hbmlwdWxhdGUgdGhlIGNhcHR1cmUgc2Vzc2lvbiBpZiBpbmNsdWRlZC4gKi9cbiAgY29udHJvbGxlcj86IHVua25vd247IC8vIFRPRE8gcmVwbGFjZSB0eXBlIHdpdGggQ2FwdHVyZUNvbnRyb2xsZXIgb25jZSBpdCBsYW5kcyBpbiBUeXBlU2NyaXB0XG5cbiAgLyoqIHNwZWNpZmllcyB3aGV0aGVyIHRoZSBicm93c2VyIHNob3VsZCBhbGxvdyB0aGUgdXNlciB0byBzZWxlY3QgdGhlIGN1cnJlbnQgdGFiIGZvciBjYXB0dXJlICovXG4gIHNlbGZCcm93c2VyU3VyZmFjZT86ICdpbmNsdWRlJyB8ICdleGNsdWRlJztcblxuICAvKiogc3BlY2lmaWVzIHdoZXRoZXIgdGhlIGJyb3dzZXIgc2hvdWxkIGRpc3BsYXkgYSBjb250cm9sIHRvIGFsbG93IHRoZSB1c2VyIHRvIGR5bmFtaWNhbGx5IHN3aXRjaCB0aGUgc2hhcmVkIHRhYiBkdXJpbmcgc2NyZWVuLXNoYXJpbmcuICovXG4gIHN1cmZhY2VTd2l0Y2hpbmc/OiAnaW5jbHVkZScgfCAnZXhjbHVkZSc7XG5cbiAgLyoqIHNwZWNpZmllcyB3aGV0aGVyIHRoZSBicm93c2VyIHNob3VsZCBpbmNsdWRlIHRoZSBzeXN0ZW0gYXVkaW8gYW1vbmcgdGhlIHBvc3NpYmxlIGF1ZGlvIHNvdXJjZXMgb2ZmZXJlZCB0byB0aGUgdXNlciAqL1xuICBzeXN0ZW1BdWRpbz86ICdpbmNsdWRlJyB8ICdleGNsdWRlJztcblxuICAvKiogc3BlY2lmeSB0aGUgdHlwZSBvZiBjb250ZW50LCBzZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9tc3QtY29udGVudC1oaW50LyN2aWRlby1jb250ZW50LWhpbnRzICovXG4gIGNvbnRlbnRIaW50PzogJ2RldGFpbCcgfCAndGV4dCcgfCAnbW90aW9uJztcblxuICAvKipcbiAgICogRXhwZXJpbWVudGFsIG9wdGlvbiB0byBjb250cm9sIHdoZXRoZXIgdGhlIGF1ZGlvIHBsYXlpbmcgaW4gYSB0YWIgd2lsbCBjb250aW51ZSB0byBiZSBwbGF5ZWQgb3V0IG9mIGEgdXNlcidzXG4gICAqIGxvY2FsIHNwZWFrZXJzIHdoZW4gdGhlIHRhYiBpcyBjYXB0dXJlZC5cbiAgICovXG4gIHN1cHByZXNzTG9jYWxBdWRpb1BsYXliYWNrPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRXhwZXJpbWVudGFsIG9wdGlvbiB0byBpbnN0cnVjdCB0aGUgYnJvd3NlciB0byBvZmZlciB0aGUgY3VycmVudCB0YWIgYXMgdGhlIG1vc3QgcHJvbWluZW50IGNhcHR1cmUgc291cmNlXG4gICAqIEBleHBlcmltZW50YWxcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFEZXZpY2VzL2dldERpc3BsYXlNZWRpYSNwcmVmZXJjdXJyZW50dGFiXG4gICAqL1xuICBwcmVmZXJDdXJyZW50VGFiPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdWRpb0NhcHR1cmVPcHRpb25zIHtcbiAgLyoqXG4gICAqIHNwZWNpZmllcyB3aGV0aGVyIGF1dG9tYXRpYyBnYWluIGNvbnRyb2wgaXMgcHJlZmVycmVkIGFuZC9vciByZXF1aXJlZFxuICAgKi9cbiAgYXV0b0dhaW5Db250cm9sPzogQ29uc3RyYWluQm9vbGVhbjtcblxuICAvKipcbiAgICogdGhlIGNoYW5uZWwgY291bnQgb3IgcmFuZ2Ugb2YgY2hhbm5lbCBjb3VudHMgd2hpY2ggYXJlIGFjY2VwdGFibGUgYW5kL29yIHJlcXVpcmVkXG4gICAqL1xuICBjaGFubmVsQ291bnQ/OiBDb25zdHJhaW5VTG9uZztcblxuICAvKipcbiAgICogQSBDb25zdHJhaW5ET01TdHJpbmcgb2JqZWN0IHNwZWNpZnlpbmcgYSBkZXZpY2UgSUQgb3IgYW4gYXJyYXkgb2YgZGV2aWNlXG4gICAqIElEcyB3aGljaCBhcmUgYWNjZXB0YWJsZSBhbmQvb3IgcmVxdWlyZWQuXG4gICAqL1xuICBkZXZpY2VJZD86IENvbnN0cmFpbkRPTVN0cmluZztcblxuICAvKipcbiAgICogd2hldGhlciBvciBub3QgZWNobyBjYW5jZWxsYXRpb24gaXMgcHJlZmVycmVkIGFuZC9vciByZXF1aXJlZFxuICAgKi9cbiAgZWNob0NhbmNlbGxhdGlvbj86IENvbnN0cmFpbkJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHRoZSBsYXRlbmN5IG9yIHJhbmdlIG9mIGxhdGVuY2llcyB3aGljaCBhcmUgYWNjZXB0YWJsZSBhbmQvb3IgcmVxdWlyZWQuXG4gICAqL1xuICBsYXRlbmN5PzogQ29uc3RyYWluRG91YmxlO1xuXG4gIC8qKlxuICAgKiB3aGV0aGVyIG5vaXNlIHN1cHByZXNzaW9uIGlzIHByZWZlcnJlZCBhbmQvb3IgcmVxdWlyZWQuXG4gICAqL1xuICBub2lzZVN1cHByZXNzaW9uPzogQ29uc3RyYWluQm9vbGVhbjtcblxuICAvKipcbiAgICogdGhlIHNhbXBsZSByYXRlIG9yIHJhbmdlIG9mIHNhbXBsZSByYXRlcyB3aGljaCBhcmUgYWNjZXB0YWJsZSBhbmQvb3IgcmVxdWlyZWQuXG4gICAqL1xuICBzYW1wbGVSYXRlPzogQ29uc3RyYWluVUxvbmc7XG5cbiAgLyoqXG4gICAqIHNhbXBsZSBzaXplIG9yIHJhbmdlIG9mIHNhbXBsZSBzaXplcyB3aGljaCBhcmUgYWNjZXB0YWJsZSBhbmQvb3IgcmVxdWlyZWQuXG4gICAqL1xuICBzYW1wbGVTaXplPzogQ29uc3RyYWluVUxvbmc7XG5cbiAgLyoqXG4gICAqIGluaXRpYWxpemUgdGhlIHRyYWNrIHdpdGggYSBnaXZlbiBwcm9jZXNzb3JcbiAgICovXG4gIHByb2Nlc3Nvcj86IFRyYWNrUHJvY2Vzc29yPFRyYWNrLktpbmQuQXVkaW8sIEF1ZGlvUHJvY2Vzc29yT3B0aW9ucz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXVkaW9PdXRwdXRPcHRpb25zIHtcbiAgLyoqXG4gICAqIGRldmljZUlkIHRvIG91dHB1dCBhdWRpb1xuICAgKlxuICAgKiBPbmx5IHN1cHBvcnRlZCBvbiBicm93c2VycyB3aGVyZSBgc2V0U2lua0lkYCBpcyBhdmFpbGFibGVcbiAgICovXG4gIGRldmljZUlkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpZGVvUmVzb2x1dGlvbiB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBmcmFtZVJhdGU/OiBudW1iZXI7XG4gIGFzcGVjdFJhdGlvPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpZGVvRW5jb2Rpbmcge1xuICBtYXhCaXRyYXRlOiBudW1iZXI7XG4gIG1heEZyYW1lcmF0ZT86IG51bWJlcjtcbiAgcHJpb3JpdHk/OiBSVENQcmlvcml0eVR5cGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlkZW9QcmVzZXRPcHRpb25zIHtcbiAgd2lkdGg6IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIGFzcGVjdFJhdGlvPzogbnVtYmVyO1xuICBtYXhCaXRyYXRlOiBudW1iZXI7XG4gIG1heEZyYW1lcmF0ZT86IG51bWJlcjtcbiAgcHJpb3JpdHk/OiBSVENQcmlvcml0eVR5cGU7XG59XG5cbmV4cG9ydCBjbGFzcyBWaWRlb1ByZXNldCB7XG4gIGVuY29kaW5nOiBWaWRlb0VuY29kaW5nO1xuXG4gIHdpZHRoOiBudW1iZXI7XG5cbiAgaGVpZ2h0OiBudW1iZXI7XG5cbiAgYXNwZWN0UmF0aW8/OiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IodmlkZW9QcmVzZXRPcHRpb25zOiBWaWRlb1ByZXNldE9wdGlvbnMpO1xuICBjb25zdHJ1Y3RvcihcbiAgICB3aWR0aDogbnVtYmVyLFxuICAgIGhlaWdodDogbnVtYmVyLFxuICAgIG1heEJpdHJhdGU6IG51bWJlcixcbiAgICBtYXhGcmFtZXJhdGU/OiBudW1iZXIsXG4gICAgcHJpb3JpdHk/OiBSVENQcmlvcml0eVR5cGUsXG4gICk7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHdpZHRoT3JPcHRpb25zOiBudW1iZXIgfCBWaWRlb1ByZXNldE9wdGlvbnMsXG4gICAgaGVpZ2h0PzogbnVtYmVyLFxuICAgIG1heEJpdHJhdGU/OiBudW1iZXIsXG4gICAgbWF4RnJhbWVyYXRlPzogbnVtYmVyLFxuICAgIHByaW9yaXR5PzogUlRDUHJpb3JpdHlUeXBlLFxuICApIHtcbiAgICBpZiAodHlwZW9mIHdpZHRoT3JPcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoT3JPcHRpb25zLndpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB3aWR0aE9yT3B0aW9ucy5oZWlnaHQ7XG4gICAgICB0aGlzLmFzcGVjdFJhdGlvID0gd2lkdGhPck9wdGlvbnMuYXNwZWN0UmF0aW87XG4gICAgICB0aGlzLmVuY29kaW5nID0ge1xuICAgICAgICBtYXhCaXRyYXRlOiB3aWR0aE9yT3B0aW9ucy5tYXhCaXRyYXRlLFxuICAgICAgICBtYXhGcmFtZXJhdGU6IHdpZHRoT3JPcHRpb25zLm1heEZyYW1lcmF0ZSxcbiAgICAgICAgcHJpb3JpdHk6IHdpZHRoT3JPcHRpb25zLnByaW9yaXR5LFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGhlaWdodCAhPT0gdW5kZWZpbmVkICYmIG1heEJpdHJhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoT3JPcHRpb25zO1xuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLmFzcGVjdFJhdGlvID0gd2lkdGhPck9wdGlvbnMgLyBoZWlnaHQ7XG4gICAgICB0aGlzLmVuY29kaW5nID0ge1xuICAgICAgICBtYXhCaXRyYXRlLFxuICAgICAgICBtYXhGcmFtZXJhdGUsXG4gICAgICAgIHByaW9yaXR5LFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5zdXBwb3J0ZWQgb3B0aW9uczogcHJvdmlkZSBhdCBsZWFzdCB3aWR0aCwgaGVpZ2h0IGFuZCBtYXhCaXRyYXRlJyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHJlc29sdXRpb24oKTogVmlkZW9SZXNvbHV0aW9uIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgZnJhbWVSYXRlOiB0aGlzLmVuY29kaW5nLm1heEZyYW1lcmF0ZSxcbiAgICAgIGFzcGVjdFJhdGlvOiB0aGlzLmFzcGVjdFJhdGlvLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdWRpb1ByZXNldCB7XG4gIG1heEJpdHJhdGU6IG51bWJlcjtcbiAgcHJpb3JpdHk/OiBSVENQcmlvcml0eVR5cGU7XG59XG5cbmNvbnN0IGJhY2t1cENvZGVjcyA9IFsndnA4JywgJ2gyNjQnXSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IHZpZGVvQ29kZWNzID0gWyd2cDgnLCAnaDI2NCcsICd2cDknLCAnYXYxJ10gYXMgY29uc3Q7XG5cbmV4cG9ydCB0eXBlIFZpZGVvQ29kZWMgPSAodHlwZW9mIHZpZGVvQ29kZWNzKVtudW1iZXJdO1xuXG5leHBvcnQgdHlwZSBCYWNrdXBWaWRlb0NvZGVjID0gKHR5cGVvZiBiYWNrdXBDb2RlY3MpW251bWJlcl07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0JhY2t1cENvZGVjKGNvZGVjOiBzdHJpbmcpOiBjb2RlYyBpcyBCYWNrdXBWaWRlb0NvZGVjIHtcbiAgcmV0dXJuICEhYmFja3VwQ29kZWNzLmZpbmQoKGJhY2t1cCkgPT4gYmFja3VwID09PSBjb2RlYyk7XG59XG5cbi8qKlxuICogc2NhbGFiaWxpdHkgbW9kZXMgZm9yIHN2Yy5cbiAqL1xuZXhwb3J0IHR5cGUgU2NhbGFiaWxpdHlNb2RlID1cbiAgfCAnTDFUMSdcbiAgfCAnTDFUMidcbiAgfCAnTDFUMydcbiAgfCAnTDJUMSdcbiAgfCAnTDJUMWgnXG4gIHwgJ0wyVDFfS0VZJ1xuICB8ICdMMlQyJ1xuICB8ICdMMlQyaCdcbiAgfCAnTDJUMl9LRVknXG4gIHwgJ0wyVDMnXG4gIHwgJ0wyVDNoJ1xuICB8ICdMMlQzX0tFWSdcbiAgfCAnTDNUMSdcbiAgfCAnTDNUMWgnXG4gIHwgJ0wzVDFfS0VZJ1xuICB8ICdMM1QyJ1xuICB8ICdMM1QyaCdcbiAgfCAnTDNUMl9LRVknXG4gIHwgJ0wzVDMnXG4gIHwgJ0wzVDNoJ1xuICB8ICdMM1QzX0tFWSc7XG5cbmV4cG9ydCBuYW1lc3BhY2UgQXVkaW9QcmVzZXRzIHtcbiAgZXhwb3J0IGNvbnN0IHRlbGVwaG9uZTogQXVkaW9QcmVzZXQgPSB7XG4gICAgbWF4Qml0cmF0ZTogMTJfMDAwLFxuICB9O1xuICBleHBvcnQgY29uc3Qgc3BlZWNoOiBBdWRpb1ByZXNldCA9IHtcbiAgICBtYXhCaXRyYXRlOiAyMF8wMDAsXG4gIH07XG4gIGV4cG9ydCBjb25zdCBtdXNpYzogQXVkaW9QcmVzZXQgPSB7XG4gICAgbWF4Qml0cmF0ZTogMzJfMDAwLFxuICB9O1xuICBleHBvcnQgY29uc3QgbXVzaWNTdGVyZW86IEF1ZGlvUHJlc2V0ID0ge1xuICAgIG1heEJpdHJhdGU6IDQ4XzAwMCxcbiAgfTtcbiAgZXhwb3J0IGNvbnN0IG11c2ljSGlnaFF1YWxpdHk6IEF1ZGlvUHJlc2V0ID0ge1xuICAgIG1heEJpdHJhdGU6IDY0XzAwMCxcbiAgfTtcbiAgZXhwb3J0IGNvbnN0IG11c2ljSGlnaFF1YWxpdHlTdGVyZW86IEF1ZGlvUHJlc2V0ID0ge1xuICAgIG1heEJpdHJhdGU6IDk2XzAwMCxcbiAgfTtcbn1cblxuLyoqXG4gKiBTYW5lIHByZXNldHMgZm9yIHZpZGVvIHJlc29sdXRpb24vZW5jb2RpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IFZpZGVvUHJlc2V0cyA9IHtcbiAgaDkwOiBuZXcgVmlkZW9QcmVzZXQoMTYwLCA5MCwgOTBfMDAwLCAyMCksXG4gIGgxODA6IG5ldyBWaWRlb1ByZXNldCgzMjAsIDE4MCwgMTYwXzAwMCwgMjApLFxuICBoMjE2OiBuZXcgVmlkZW9QcmVzZXQoMzg0LCAyMTYsIDE4MF8wMDAsIDIwKSxcbiAgaDM2MDogbmV3IFZpZGVvUHJlc2V0KDY0MCwgMzYwLCA0NTBfMDAwLCAyMCksXG4gIGg1NDA6IG5ldyBWaWRlb1ByZXNldCg5NjAsIDU0MCwgODAwXzAwMCwgMjUpLFxuICBoNzIwOiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCAxXzcwMF8wMDAsIDMwKSxcbiAgaDEwODA6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxMDgwLCAzXzAwMF8wMDAsIDMwKSxcbiAgaDE0NDA6IG5ldyBWaWRlb1ByZXNldCgyNTYwLCAxNDQwLCA1XzAwMF8wMDAsIDMwKSxcbiAgaDIxNjA6IG5ldyBWaWRlb1ByZXNldCgzODQwLCAyMTYwLCA4XzAwMF8wMDAsIDMwKSxcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogRm91ciBieSB0aHJlZSBwcmVzZXRzXG4gKi9cbmV4cG9ydCBjb25zdCBWaWRlb1ByZXNldHM0MyA9IHtcbiAgaDEyMDogbmV3IFZpZGVvUHJlc2V0KDE2MCwgMTIwLCA3MF8wMDAsIDIwKSxcbiAgaDE4MDogbmV3IFZpZGVvUHJlc2V0KDI0MCwgMTgwLCAxMjVfMDAwLCAyMCksXG4gIGgyNDA6IG5ldyBWaWRlb1ByZXNldCgzMjAsIDI0MCwgMTQwXzAwMCwgMjApLFxuICBoMzYwOiBuZXcgVmlkZW9QcmVzZXQoNDgwLCAzNjAsIDMzMF8wMDAsIDIwKSxcbiAgaDQ4MDogbmV3IFZpZGVvUHJlc2V0KDY0MCwgNDgwLCA1MDBfMDAwLCAyMCksXG4gIGg1NDA6IG5ldyBWaWRlb1ByZXNldCg3MjAsIDU0MCwgNjAwXzAwMCwgMjUpLFxuICBoNzIwOiBuZXcgVmlkZW9QcmVzZXQoOTYwLCA3MjAsIDFfMzAwXzAwMCwgMzApLFxuICBoMTA4MDogbmV3IFZpZGVvUHJlc2V0KDE0NDAsIDEwODAsIDJfMzAwXzAwMCwgMzApLFxuICBoMTQ0MDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDE0NDAsIDNfODAwXzAwMCwgMzApLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IFNjcmVlblNoYXJlUHJlc2V0cyA9IHtcbiAgaDM2MGZwczM6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDM2MCwgMjAwXzAwMCwgMywgJ21lZGl1bScpLFxuICBoMzYwZnBzMTU6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDM2MCwgNDAwXzAwMCwgMTUsICdtZWRpdW0nKSxcbiAgaDcyMGZwczU6IG5ldyBWaWRlb1ByZXNldCgxMjgwLCA3MjAsIDgwMF8wMDAsIDUsICdtZWRpdW0nKSxcbiAgaDcyMGZwczE1OiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCAxXzUwMF8wMDAsIDE1LCAnbWVkaXVtJyksXG4gIGg3MjBmcHMzMDogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgMl8wMDBfMDAwLCAzMCwgJ21lZGl1bScpLFxuICBoMTA4MGZwczE1OiBuZXcgVmlkZW9QcmVzZXQoMTkyMCwgMTA4MCwgMl81MDBfMDAwLCAxNSwgJ21lZGl1bScpLFxuICBoMTA4MGZwczMwOiBuZXcgVmlkZW9QcmVzZXQoMTkyMCwgMTA4MCwgNV8wMDBfMDAwLCAzMCwgJ21lZGl1bScpLFxuICAvLyBvcmlnaW5hbCByZXNvbHV0aW9uLCB3aXRob3V0IHJlc2l6aW5nXG4gIG9yaWdpbmFsOiBuZXcgVmlkZW9QcmVzZXQoMCwgMCwgN18wMDBfMDAwLCAzMCwgJ21lZGl1bScpLFxufSBhcyBjb25zdDtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCIvKipcbiAqIEV2ZW50cyBhcmUgdGhlIHByaW1hcnkgd2F5IExpdmVLaXQgbm90aWZpZXMgeW91ciBhcHBsaWNhdGlvbiBvZiBjaGFuZ2VzLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgYXJlIGV2ZW50cyBlbWl0dGVkIGJ5IFtbUm9vbV1dLCBsaXN0ZW4gdG8gcm9vbSBldmVudHMgbGlrZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIHJvb20ub24oUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCAodHJhY2ssIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCkgPT4ge30pXG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgZW51bSBSb29tRXZlbnQge1xuICAvKipcbiAgICogV2hlbiB0aGUgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyIGhhcyBiZWVuIGVzdGFibGlzaGVkXG4gICAqL1xuICBDb25uZWN0ZWQgPSAnY29ubmVjdGVkJyxcblxuICAvKipcbiAgICogV2hlbiB0aGUgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyIGhhcyBiZWVuIGludGVycnVwdGVkIGFuZCBpdCdzIGF0dGVtcHRpbmdcbiAgICogdG8gcmVjb25uZWN0LlxuICAgKi9cbiAgUmVjb25uZWN0aW5nID0gJ3JlY29ubmVjdGluZycsXG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHNpZ25hbCBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gaW50ZXJydXB0ZWQuIFRoaXMgaXNuJ3Qgbm90aWNlYWJsZSB0byB1c2VycyBtb3N0IG9mIHRoZSB0aW1lLlxuICAgKiBJdCB3aWxsIHJlc29sdmUgd2l0aCBhIGBSb29tRXZlbnQuUmVjb25uZWN0ZWRgIG9uY2UgdGhlIHNpZ25hbCBjb25uZWN0aW9uIGhhcyBiZWVuIHJlLWVzdGFibGlzaGVkLlxuICAgKiBJZiBtZWRpYSBmYWlscyBhZGRpdGlvbmFsbHkgaXQgYW4gYWRkaXRpb25hbCBgUm9vbUV2ZW50LlJlY29ubmVjdGluZ2Agd2lsbCBiZSBlbWl0dGVkLlxuICAgKi9cbiAgU2lnbmFsUmVjb25uZWN0aW5nID0gJ3NpZ25hbFJlY29ubmVjdGluZycsXG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gYSByZWNvbm5lY3Rpb24gaGFzIGJlZW4gc3VjY2Vzc2Z1bC5cbiAgICovXG4gIFJlY29ubmVjdGVkID0gJ3JlY29ubmVjdGVkJyxcblxuICAvKipcbiAgICogV2hlbiBkaXNjb25uZWN0ZWQgZnJvbSByb29tLiBUaGlzIGZpcmVzIHdoZW4gcm9vbS5kaXNjb25uZWN0KCkgaXMgY2FsbGVkIG9yXG4gICAqIHdoZW4gYW4gdW5yZWNvdmVyYWJsZSBjb25uZWN0aW9uIGlzc3VlIGhhZCBvY2N1cmVkLlxuICAgKlxuICAgKiBEaXNjb25uZWN0UmVhc29uIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB3aHkgdGhlIHBhcnRpY2lwYW50IHdhcyBkaXNjb25uZWN0ZWQuIE5vdGFibGUgcmVhc29ucyBhcmVcbiAgICogLSBEVVBMSUNBVEVfSURFTlRJVFk6IGFub3RoZXIgY2xpZW50IHdpdGggdGhlIHNhbWUgaWRlbnRpdHkgaGFzIGpvaW5lZCB0aGUgcm9vbVxuICAgKiAtIFBBUlRJQ0lQQU5UX1JFTU9WRUQ6IHBhcnRpY2lwYW50IHdhcyByZW1vdmVkIGJ5IFJlbW92ZVBhcnRpY2lwYW50IEFQSVxuICAgKiAtIFJPT01fREVMRVRFRDogdGhlIHJvb20gaGFzIGVuZGVkIHZpYSBEZWxldGVSb29tIEFQSVxuICAgKlxuICAgKiBhcmdzOiAoW1tEaXNjb25uZWN0UmVhc29uXV0pXG4gICAqL1xuICBEaXNjb25uZWN0ZWQgPSAnZGlzY29ubmVjdGVkJyxcblxuICAvKipcbiAgICogV2hlbmV2ZXIgdGhlIGNvbm5lY3Rpb24gc3RhdGUgb2YgdGhlIHJvb20gY2hhbmdlc1xuICAgKlxuICAgKiBhcmdzOiAoW1tDb25uZWN0aW9uU3RhdGVdXSlcbiAgICovXG4gIENvbm5lY3Rpb25TdGF0ZUNoYW5nZWQgPSAnY29ubmVjdGlvblN0YXRlQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIFdoZW4gaW5wdXQgb3Igb3V0cHV0IGRldmljZXMgb24gdGhlIG1hY2hpbmUgaGF2ZSBjaGFuZ2VkLlxuICAgKi9cbiAgTWVkaWFEZXZpY2VzQ2hhbmdlZCA9ICdtZWRpYURldmljZXNDaGFuZ2VkJyxcblxuICAvKipcbiAgICogV2hlbiBhIFtbUmVtb3RlUGFydGljaXBhbnRdXSBqb2lucyAqYWZ0ZXIqIHRoZSBsb2NhbFxuICAgKiBwYXJ0aWNpcGFudC4gSXQgd2lsbCBub3QgZW1pdCBldmVudHMgZm9yIHBhcnRpY2lwYW50cyB0aGF0IGFyZSBhbHJlYWR5XG4gICAqIGluIHRoZSByb29tXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudENvbm5lY3RlZCA9ICdwYXJ0aWNpcGFudENvbm5lY3RlZCcsXG5cbiAgLyoqXG4gICAqIFdoZW4gYSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gbGVhdmVzICphZnRlciogdGhlIGxvY2FsXG4gICAqIHBhcnRpY2lwYW50IGhhcyBqb2luZWQuXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZCA9ICdwYXJ0aWNpcGFudERpc2Nvbm5lY3RlZCcsXG5cbiAgLyoqXG4gICAqIFdoZW4gYSBuZXcgdHJhY2sgaXMgcHVibGlzaGVkIHRvIHJvb20gKmFmdGVyKiB0aGUgbG9jYWxcbiAgICogcGFydGljaXBhbnQgaGFzIGpvaW5lZC4gSXQgd2lsbCBub3QgZmlyZSBmb3IgdHJhY2tzIHRoYXQgYXJlIGFscmVhZHkgcHVibGlzaGVkLlxuICAgKlxuICAgKiBBIHRyYWNrIHB1Ymxpc2hlZCBkb2Vzbid0IG1lYW4gdGhlIHBhcnRpY2lwYW50IGhhcyBzdWJzY3JpYmVkIHRvIGl0LiBJdCdzXG4gICAqIHNpbXBseSByZWZsZWN0aW5nIHRoZSBzdGF0ZSBvZiB0aGUgcm9vbS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBUcmFja1B1Ymxpc2hlZCA9ICd0cmFja1B1Ymxpc2hlZCcsXG5cbiAgLyoqXG4gICAqIFRoZSBbW0xvY2FsUGFydGljaXBhbnRdXSBoYXMgc3Vic2NyaWJlZCB0byBhIG5ldyB0cmFjay4gVGhpcyBldmVudCB3aWxsICoqYWx3YXlzKipcbiAgICogZmlyZSBhcyBsb25nIGFzIG5ldyB0cmFja3MgYXJlIHJlYWR5IGZvciB1c2UuXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrXV0sIFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBUcmFja1N1YnNjcmliZWQgPSAndHJhY2tTdWJzY3JpYmVkJyxcblxuICAvKipcbiAgICogQ291bGQgbm90IHN1YnNjcmliZSB0byBhIHRyYWNrXG4gICAqXG4gICAqIGFyZ3M6ICh0cmFjayBzaWQsIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkID0gJ3RyYWNrU3Vic2NyaXB0aW9uRmFpbGVkJyxcblxuICAvKipcbiAgICogQSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gaGFzIHVucHVibGlzaGVkIGEgdHJhY2tcbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBUcmFja1VucHVibGlzaGVkID0gJ3RyYWNrVW5wdWJsaXNoZWQnLFxuXG4gIC8qKlxuICAgKiBBIHN1YnNjcmliZWQgdHJhY2sgaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZS4gQ2xpZW50cyBzaG91bGQgbGlzdGVuIHRvIHRoaXNcbiAgICogZXZlbnQgYW5kIGVuc3VyZSB0aGV5IGRldGFjaCB0cmFja3MuXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrXV0sIFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBUcmFja1Vuc3Vic2NyaWJlZCA9ICd0cmFja1Vuc3Vic2NyaWJlZCcsXG5cbiAgLyoqXG4gICAqIEEgdHJhY2sgdGhhdCB3YXMgbXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqL1xuICBUcmFja011dGVkID0gJ3RyYWNrTXV0ZWQnLFxuXG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIHVubXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqL1xuICBUcmFja1VubXV0ZWQgPSAndHJhY2tVbm11dGVkJyxcblxuICAvKipcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgcHVibGlzaGVkIHN1Y2Nlc3NmdWxseS4gVGhpcyBldmVudCBpcyBoZWxwZnVsIHRvIGtub3dcbiAgICogd2hlbiB0byB1cGRhdGUgeW91ciBsb2NhbCBVSSB3aXRoIHRoZSBuZXdseSBwdWJsaXNoZWQgdHJhY2suXG4gICAqXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dLCBbW0xvY2FsUGFydGljaXBhbnRdXSlcbiAgICovXG4gIExvY2FsVHJhY2tQdWJsaXNoZWQgPSAnbG9jYWxUcmFja1B1Ymxpc2hlZCcsXG5cbiAgLyoqXG4gICAqIEEgbG9jYWwgdHJhY2sgd2FzIHVucHVibGlzaGVkLiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vdyB3aGVuIHRvIHJlbW92ZVxuICAgKiB0aGUgbG9jYWwgdHJhY2sgZnJvbSB5b3VyIFVJLlxuICAgKlxuICAgKiBXaGVuIGEgdXNlciBzdG9wcyBzaGFyaW5nIHRoZWlyIHNjcmVlbiBieSBwcmVzc2luZyBcIkVuZFwiIG9uIHRoZSBicm93c2VyIFVJLFxuICAgKiB0aGlzIGV2ZW50IHdpbGwgYWxzbyBmaXJlLlxuICAgKlxuICAgKiBhcmdzOiAoW1tMb2NhbFRyYWNrUHVibGljYXRpb25dXSwgW1tMb2NhbFBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBMb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSAnbG9jYWxUcmFja1VucHVibGlzaGVkJyxcblxuICAvKipcbiAgICogV2hlbiBhIGxvY2FsIGF1ZGlvIHRyYWNrIGlzIHB1Ymxpc2hlZCB0aGUgU0RLIGNoZWNrcyB3aGV0aGVyIHRoZXJlIGlzIGNvbXBsZXRlIHNpbGVuY2VcbiAgICogb24gdGhhdCB0cmFjayBhbmQgZW1pdHMgdGhlIExvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWQgZXZlbnQgaW4gdGhhdCBjYXNlLlxuICAgKiBUaGlzIGFsbG93cyBmb3IgYXBwbGljYXRpb25zIHRvIHNob3cgVUkgaW5mb3JtaW5nIHVzZXJzIHRoYXQgdGhleSBtaWdodCBoYXZlIHRvXG4gICAqIHJlc2V0IHRoZWlyIGF1ZGlvIGhhcmR3YXJlIG9yIGNoZWNrIGZvciBwcm9wZXIgZGV2aWNlIGNvbm5lY3Rpdml0eS5cbiAgICovXG4gIExvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWQgPSAnbG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZCcsXG5cbiAgLyoqXG4gICAqIEFjdGl2ZSBzcGVha2VycyBjaGFuZ2VkLiBMaXN0IG9mIHNwZWFrZXJzIGFyZSBvcmRlcmVkIGJ5IHRoZWlyIGF1ZGlvIGxldmVsLlxuICAgKiBsb3VkZXN0IHNwZWFrZXJzIGZpcnN0LiBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgTG9jYWxQYXJ0aWNpcGFudCB0b28uXG4gICAqXG4gICAqIFNwZWFrZXIgdXBkYXRlcyBhcmUgc2VudCBvbmx5IHRvIHRoZSBwdWJsaXNoaW5nIHBhcnRpY2lwYW50IGFuZCB0aGVpciBzdWJzY3JpYmVycy5cbiAgICpcbiAgICogYXJnczogKEFycmF5PFtbUGFydGljaXBhbnRdXT4pXG4gICAqL1xuICBBY3RpdmVTcGVha2Vyc0NoYW5nZWQgPSAnYWN0aXZlU3BlYWtlcnNDaGFuZ2VkJyxcblxuICAvKipcbiAgICogUGFydGljaXBhbnQgbWV0YWRhdGEgaXMgYSBzaW1wbGUgd2F5IGZvciBhcHAtc3BlY2lmaWMgc3RhdGUgdG8gYmUgcHVzaGVkIHRvXG4gICAqIGFsbCB1c2Vycy5cbiAgICogV2hlbiBSb29tU2VydmljZS5VcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIGlzIGNhbGxlZCB0byBjaGFuZ2UgYSBwYXJ0aWNpcGFudCdzXG4gICAqIHN0YXRlLCAqYWxsKiAgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgZmlyZSB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBhcmdzOiAocHJldk1ldGFkYXRhOiBzdHJpbmcsIFtbUGFydGljaXBhbnRdXSlcbiAgICpcbiAgICovXG4gIFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkID0gJ3BhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkJyxcblxuICAvKipcbiAgICogUGFydGljaXBhbnQncyBkaXNwbGF5IG5hbWUgY2hhbmdlZFxuICAgKlxuICAgKiBhcmdzOiAobmFtZTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqXG4gICAqL1xuICBQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkID0gJ3BhcnRpY2lwYW50TmFtZUNoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCBhdHRyaWJ1dGVzIGlzIGFuIGFwcC1zcGVjaWZpYyBrZXkgdmFsdWUgc3RhdGUgdG8gYmUgcHVzaGVkIHRvXG4gICAqIGFsbCB1c2Vycy5cbiAgICogV2hlbiBhIHBhcnRpY2lwYW50J3MgYXR0cmlidXRlcyBjaGFuZ2VkLCB0aGlzIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCB3aXRoIHRoZSBjaGFuZ2VkIGF0dHJpYnV0ZXMgYW5kIHRoZSBwYXJ0aWNpcGFudFxuICAgKiBhcmdzOiAoY2hhbmdlZEF0dHJpYnV0ZXM6IFtbUmVjb3JkPHN0cmluZywgc3RyaW5nXV0sIHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEF0dHJpYnV0ZXNDaGFuZ2VkID0gJ3BhcnRpY2lwYW50QXR0cmlidXRlc0NoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBSb29tIG1ldGFkYXRhIGlzIGEgc2ltcGxlIHdheSBmb3IgYXBwLXNwZWNpZmljIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xuICAgKiBhbGwgdXNlcnMuXG4gICAqIFdoZW4gUm9vbVNlcnZpY2UuVXBkYXRlUm9vbU1ldGFkYXRhIGlzIGNhbGxlZCB0byBjaGFuZ2UgYSByb29tJ3Mgc3RhdGUsXG4gICAqICphbGwqICBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCBmaXJlIHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIGFyZ3M6IChzdHJpbmcpXG4gICAqL1xuICBSb29tTWV0YWRhdGFDaGFuZ2VkID0gJ3Jvb21NZXRhZGF0YUNoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBEYXRhIHJlY2VpdmVkIGZyb20gYW5vdGhlciBwYXJ0aWNpcGFudC5cbiAgICogRGF0YSBwYWNrZXRzIHByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIHVzZSBMaXZlS2l0IHRvIHNlbmQvcmVjZWl2ZSBhcmJpdHJhcnkgcGF5bG9hZHMuXG4gICAqIEFsbCBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCByZWNlaXZlIHRoZSBtZXNzYWdlcyBzZW50IHRvIHRoZSByb29tLlxuICAgKlxuICAgKiBhcmdzOiAocGF5bG9hZDogVWludDhBcnJheSwgcGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSwga2luZDogW1tEYXRhUGFja2V0X0tpbmRdXSwgdG9waWM/OiBzdHJpbmcpXG4gICAqL1xuICBEYXRhUmVjZWl2ZWQgPSAnZGF0YVJlY2VpdmVkJyxcblxuICAvKipcbiAgICogU0lQIERUTUYgdG9uZXMgcmVjZWl2ZWQgZnJvbSBhbm90aGVyIHBhcnRpY2lwYW50LlxuICAgKlxuICAgKiBhcmdzOiAocGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSwgZHRtZjogW1tEYXRhUGFja2V0X0tpbmRdXSlcbiAgICovXG4gIFNpcERUTUZSZWNlaXZlZCA9ICdzaXBEVE1GUmVjZWl2ZWQnLFxuXG4gIC8qKlxuICAgKiBUcmFuc2NyaXB0aW9uIHJlY2VpdmVkIGZyb20gYSBwYXJ0aWNpcGFudCdzIHRyYWNrLlxuICAgKiBAYmV0YVxuICAgKi9cbiAgVHJhbnNjcmlwdGlvblJlY2VpdmVkID0gJ3RyYW5zY3JpcHRpb25SZWNlaXZlZCcsXG5cbiAgLyoqXG4gICAqIENvbm5lY3Rpb24gcXVhbGl0eSB3YXMgY2hhbmdlZCBmb3IgYSBQYXJ0aWNpcGFudC4gSXQnbGwgcmVjZWl2ZSB1cGRhdGVzXG4gICAqIGZyb20gdGhlIGxvY2FsIHBhcnRpY2lwYW50LCBhcyB3ZWxsIGFzIGFueSBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIHRoYXQgd2UgYXJlXG4gICAqIHN1YnNjcmliZWQgdG8uXG4gICAqXG4gICAqIGFyZ3M6IChjb25uZWN0aW9uUXVhbGl0eTogW1tDb25uZWN0aW9uUXVhbGl0eV1dLCBwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkID0gJ2Nvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIFN0cmVhbVN0YXRlIGluZGljYXRlcyBpZiBhIHN1YnNjcmliZWQgKHJlbW90ZSkgdHJhY2sgaGFzIGJlZW4gcGF1c2VkIGJ5IHRoZSBTRlVcbiAgICogKHR5cGljYWxseSB0aGlzIGhhcHBlbnMgYmVjYXVzZSBvZiBzdWJzY3JpYmVyJ3MgYmFuZHdpZHRoIGNvbnN0cmFpbnRzKVxuICAgKlxuICAgKiBXaGVuIGJhbmR3aWR0aCBjb25kaXRpb25zIGFsbG93LCB0aGUgdHJhY2sgd2lsbCBiZSByZXN1bWVkIGF1dG9tYXRpY2FsbHkuXG4gICAqIFRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkIHdpbGwgYWxzbyBiZSBlbWl0dGVkIHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgc3RyZWFtU3RhdGU6IFtbVHJhY2suU3RyZWFtU3RhdGVdXSxcbiAgICogICAgICAgIHBhcnRpY2lwYW50OiBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCA9ICd0cmFja1N0cmVhbVN0YXRlQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIE9uZSBvZiBzdWJzY3JpYmVkIHRyYWNrcyBoYXZlIGNoYW5nZWQgaXRzIHBlcm1pc3Npb25zIGZvciB0aGUgY3VycmVudFxuICAgKiBwYXJ0aWNpcGFudC4gSWYgcGVybWlzc2lvbiB3YXMgcmV2b2tlZCwgdGhlbiB0aGUgdHJhY2sgd2lsbCBubyBsb25nZXJcbiAgICogYmUgc3Vic2NyaWJlZC4gSWYgcGVybWlzc2lvbiB3YXMgZ3JhbnRlZCwgYSBUcmFja1N1YnNjcmliZWQgZXZlbnQgd2lsbFxuICAgKiBiZSBlbWl0dGVkLlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSxcbiAgICogICAgICAgIHN0YXR1czogW1tUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXNdXSxcbiAgICogICAgICAgIHBhcnRpY2lwYW50OiBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkID0gJ3RyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBPbmUgb2Ygc3Vic2NyaWJlZCB0cmFja3MgaGF2ZSBjaGFuZ2VkIGl0cyBzdGF0dXMgZm9yIHRoZSBjdXJyZW50XG4gICAqIHBhcnRpY2lwYW50LlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSxcbiAgICogICAgICAgIHN0YXR1czogW1tUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1c11dLFxuICAgKiAgICAgICAgcGFydGljaXBhbnQ6IFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCA9ICd0cmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBMaXZlS2l0IHdpbGwgYXR0ZW1wdCB0byBhdXRvcGxheSBhbGwgYXVkaW8gdHJhY2tzIHdoZW4geW91IGF0dGFjaCB0aGVtIHRvXG4gICAqIGF1ZGlvIGVsZW1lbnRzLiBIb3dldmVyLCBpZiB0aGF0IGZhaWxzLCB3ZSdsbCBub3RpZnkgeW91IHZpYSBBdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZC5cbiAgICogYFJvb20uY2FuUGxheWJhY2tBdWRpb2Agd2lsbCBpbmRpY2F0ZSBpZiBhdWRpbyBwbGF5YmFjayBpcyBwZXJtaXR0ZWQuXG4gICAqL1xuICBBdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCA9ICdhdWRpb1BsYXliYWNrQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIExpdmVLaXQgd2lsbCBhdHRlbXB0IHRvIGF1dG9wbGF5IGFsbCB2aWRlbyB0cmFja3Mgd2hlbiB5b3UgYXR0YWNoIHRoZW0gdG9cbiAgICogYSB2aWRlbyBlbGVtZW50LiBIb3dldmVyLCBpZiB0aGF0IGZhaWxzLCB3ZSdsbCBub3RpZnkgeW91IHZpYSBWaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZC5cbiAgICogQ2FsbGluZyBgcm9vbS5zdGFydFZpZGVvKClgIGluIGEgdXNlciBnZXN0dXJlIGV2ZW50IGhhbmRsZXIgd2lsbCByZXN1bWUgdGhlIHZpZGVvIHBsYXliYWNrLlxuICAgKi9cbiAgVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWQgPSAndmlkZW9QbGF5YmFja0NoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBXaGVuIHdlIGhhdmUgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgYXR0ZW1wdGluZyB0byBjcmVhdGUgYSB0cmFjay5cbiAgICogVGhlIGVycm9ycyB0YWtlIHBsYWNlIGluIGdldFVzZXJNZWRpYSgpLlxuICAgKiBVc2UgTWVkaWFEZXZpY2VGYWlsdXJlLmdldEZhaWx1cmUoZXJyb3IpIHRvIGdldCB0aGUgcmVhc29uIG9mIGZhaWx1cmUuXG4gICAqIFtbTG9jYWxQYXJ0aWNpcGFudC5sYXN0Q2FtZXJhRXJyb3JdXSBhbmQgW1tMb2NhbFBhcnRpY2lwYW50Lmxhc3RNaWNyb3Bob25lRXJyb3JdXVxuICAgKiB3aWxsIGluZGljYXRlIGlmIGl0IGhhZCBhbiBlcnJvciB3aGlsZSBjcmVhdGluZyB0aGUgYXVkaW8gb3IgdmlkZW8gdHJhY2sgcmVzcGVjdGl2ZWx5LlxuICAgKlxuICAgKiBhcmdzOiAoZXJyb3I6IEVycm9yKVxuICAgKi9cbiAgTWVkaWFEZXZpY2VzRXJyb3IgPSAnbWVkaWFEZXZpY2VzRXJyb3InLFxuXG4gIC8qKlxuICAgKiBBIHBhcnRpY2lwYW50J3MgcGVybWlzc2lvbiBoYXMgY2hhbmdlZC5cbiAgICogYXJnczogKHByZXZQZXJtaXNzaW9uczogW1tQYXJ0aWNpcGFudFBlcm1pc3Npb25dXSwgcGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkID0gJ3BhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkJyxcblxuICAvKipcbiAgICogU2lnbmFsIGNvbm5lY3RlZCwgY2FuIHB1Ymxpc2ggdHJhY2tzLlxuICAgKi9cbiAgU2lnbmFsQ29ubmVjdGVkID0gJ3NpZ25hbENvbm5lY3RlZCcsXG5cbiAgLyoqXG4gICAqIFJlY29yZGluZyBvZiBhIHJvb20gaGFzIHN0YXJ0ZWQvc3RvcHBlZC4gUm9vbS5pc1JlY29yZGluZyB3aWxsIGJlIHVwZGF0ZWQgdG9vLlxuICAgKiBhcmdzOiAoaXNSZWNvcmRpbmc6IGJvb2xlYW4pXG4gICAqL1xuICBSZWNvcmRpbmdTdGF0dXNDaGFuZ2VkID0gJ3JlY29yZGluZ1N0YXR1c0NoYW5nZWQnLFxuXG4gIFBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQgPSAncGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCcsXG5cbiAgRW5jcnlwdGlvbkVycm9yID0gJ2VuY3J5cHRpb25FcnJvcicsXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuZXZlciB0aGUgY3VycmVudCBidWZmZXIgc3RhdHVzIG9mIGEgZGF0YSBjaGFubmVsIGNoYW5nZXNcbiAgICogYXJnczogKGlzTG93OiBib29sZWFuLCBraW5kOiBbW0RhdGFQYWNrZXRfS2luZF1dKVxuICAgKi9cbiAgRENCdWZmZXJTdGF0dXNDaGFuZ2VkID0gJ2RjQnVmZmVyU3RhdHVzQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBieSBhIGNhbGwgdG8gcm9vbS5zd2l0Y2hBY3RpdmVEZXZpY2VcbiAgICogYXJnczogKGtpbmQ6IE1lZGlhRGV2aWNlS2luZCwgZGV2aWNlSWQ6IHN0cmluZylcbiAgICovXG4gIEFjdGl2ZURldmljZUNoYW5nZWQgPSAnYWN0aXZlRGV2aWNlQ2hhbmdlZCcsXG5cbiAgQ2hhdE1lc3NhZ2UgPSAnY2hhdE1lc3NhZ2UnLFxuICAvKipcbiAgICogZmlyZWQgd2hlbiB0aGUgZmlyc3QgcmVtb3RlIHBhcnRpY2lwYW50IGhhcyBzdWJzY3JpYmVkIHRvIHRoZSBsb2NhbFBhcnRpY2lwYW50J3MgdHJhY2tcbiAgICovXG4gIExvY2FsVHJhY2tTdWJzY3JpYmVkID0gJ2xvY2FsVHJhY2tTdWJzY3JpYmVkJyxcblxuICAvKipcbiAgICogZmlyZWQgd2hlbiB0aGUgY2xpZW50IHJlY2VpdmVzIGNvbm5lY3Rpb24gbWV0cmljcyBmcm9tIG90aGVyIHBhcnRpY2lwYW50c1xuICAgKi9cbiAgTWV0cmljc1JlY2VpdmVkID0gJ21ldHJpY3NSZWNlaXZlZCcsXG59XG5cbmV4cG9ydCBlbnVtIFBhcnRpY2lwYW50RXZlbnQge1xuICAvKipcbiAgICogV2hlbiBhIG5ldyB0cmFjayBpcyBwdWJsaXNoZWQgdG8gcm9vbSAqYWZ0ZXIqIHRoZSBsb2NhbFxuICAgKiBwYXJ0aWNpcGFudCBoYXMgam9pbmVkLiBJdCB3aWxsIG5vdCBmaXJlIGZvciB0cmFja3MgdGhhdCBhcmUgYWxyZWFkeSBwdWJsaXNoZWQuXG4gICAqXG4gICAqIEEgdHJhY2sgcHVibGlzaGVkIGRvZXNuJ3QgbWVhbiB0aGUgcGFydGljaXBhbnQgaGFzIHN1YnNjcmliZWQgdG8gaXQuIEl0J3NcbiAgICogc2ltcGx5IHJlZmxlY3RpbmcgdGhlIHN0YXRlIG9mIHRoZSByb29tLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBUcmFja1B1Ymxpc2hlZCA9ICd0cmFja1B1Ymxpc2hlZCcsXG5cbiAgLyoqXG4gICAqIFN1Y2Nlc3NmdWxseSBzdWJzY3JpYmVkIHRvIHRoZSBbW1JlbW90ZVBhcnRpY2lwYW50XV0ncyB0cmFjay5cbiAgICogVGhpcyBldmVudCB3aWxsICoqYWx3YXlzKiogZmlyZSBhcyBsb25nIGFzIG5ldyB0cmFja3MgYXJlIHJlYWR5IGZvciB1c2UuXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrXV0sIFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgVHJhY2tTdWJzY3JpYmVkID0gJ3RyYWNrU3Vic2NyaWJlZCcsXG5cbiAgLyoqXG4gICAqIENvdWxkIG5vdCBzdWJzY3JpYmUgdG8gYSB0cmFja1xuICAgKlxuICAgKiBhcmdzOiAodHJhY2sgc2lkKVxuICAgKi9cbiAgVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQgPSAndHJhY2tTdWJzY3JpcHRpb25GYWlsZWQnLFxuXG4gIC8qKlxuICAgKiBBIFtbUmVtb3RlUGFydGljaXBhbnRdXSBoYXMgdW5wdWJsaXNoZWQgYSB0cmFja1xuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBUcmFja1VucHVibGlzaGVkID0gJ3RyYWNrVW5wdWJsaXNoZWQnLFxuXG4gIC8qKlxuICAgKiBBIHN1YnNjcmliZWQgdHJhY2sgaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZS4gQ2xpZW50cyBzaG91bGQgbGlzdGVuIHRvIHRoaXNcbiAgICogZXZlbnQgYW5kIGVuc3VyZSB0aGV5IGRldGFjaCB0cmFja3MuXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrXV0sIFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgVHJhY2tVbnN1YnNjcmliZWQgPSAndHJhY2tVbnN1YnNjcmliZWQnLFxuXG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIG11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFRyYWNrTXV0ZWQgPSAndHJhY2tNdXRlZCcsXG5cbiAgLyoqXG4gICAqIEEgdHJhY2sgdGhhdCB3YXMgdW5tdXRlZCwgZmlyZXMgb24gYm90aCBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIGFuZCBbW0xvY2FsUGFydGljaXBhbnRdXVxuICAgKlxuICAgKiBhcmdzOiAoW1tUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBUcmFja1VubXV0ZWQgPSAndHJhY2tVbm11dGVkJyxcblxuICAvKipcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgcHVibGlzaGVkIHN1Y2Nlc3NmdWxseS4gVGhpcyBldmVudCBpcyBoZWxwZnVsIHRvIGtub3dcbiAgICogd2hlbiB0byB1cGRhdGUgeW91ciBsb2NhbCBVSSB3aXRoIHRoZSBuZXdseSBwdWJsaXNoZWQgdHJhY2suXG4gICAqXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgTG9jYWxUcmFja1B1Ymxpc2hlZCA9ICdsb2NhbFRyYWNrUHVibGlzaGVkJyxcblxuICAvKipcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgdW5wdWJsaXNoZWQuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93IHdoZW4gdG8gcmVtb3ZlXG4gICAqIHRoZSBsb2NhbCB0cmFjayBmcm9tIHlvdXIgVUkuXG4gICAqXG4gICAqIFdoZW4gYSB1c2VyIHN0b3BzIHNoYXJpbmcgdGhlaXIgc2NyZWVuIGJ5IHByZXNzaW5nIFwiRW5kXCIgb24gdGhlIGJyb3dzZXIgVUksXG4gICAqIHRoaXMgZXZlbnQgd2lsbCBhbHNvIGZpcmUuXG4gICAqXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgTG9jYWxUcmFja1VucHVibGlzaGVkID0gJ2xvY2FsVHJhY2tVbnB1Ymxpc2hlZCcsXG5cbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50IG1ldGFkYXRhIGlzIGEgc2ltcGxlIHdheSBmb3IgYXBwLXNwZWNpZmljIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xuICAgKiBhbGwgdXNlcnMuXG4gICAqIFdoZW4gUm9vbVNlcnZpY2UuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSBpcyBjYWxsZWQgdG8gY2hhbmdlIGEgcGFydGljaXBhbnQnc1xuICAgKiBzdGF0ZSwgKmFsbCogIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIGZpcmUgdGhpcyBldmVudC5cbiAgICogVG8gYWNjZXNzIHRoZSBjdXJyZW50IG1ldGFkYXRhLCBzZWUgW1tQYXJ0aWNpcGFudC5tZXRhZGF0YV1dLlxuICAgKlxuICAgKiBhcmdzOiAocHJldk1ldGFkYXRhOiBzdHJpbmcpXG4gICAqXG4gICAqL1xuICBQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCA9ICdwYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50J3MgZGlzcGxheSBuYW1lIGNoYW5nZWRcbiAgICpcbiAgICogYXJnczogKG5hbWU6IHN0cmluZywgW1tQYXJ0aWNpcGFudF1dKVxuICAgKlxuICAgKi9cbiAgUGFydGljaXBhbnROYW1lQ2hhbmdlZCA9ICdwYXJ0aWNpcGFudE5hbWVDaGFuZ2VkJyxcblxuICAvKipcbiAgICogRGF0YSByZWNlaXZlZCBmcm9tIHRoaXMgcGFydGljaXBhbnQgYXMgc2VuZGVyLlxuICAgKiBEYXRhIHBhY2tldHMgcHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gdXNlIExpdmVLaXQgdG8gc2VuZC9yZWNlaXZlIGFyYml0cmFyeSBwYXlsb2Fkcy5cbiAgICogQWxsIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIHJlY2VpdmUgdGhlIG1lc3NhZ2VzIHNlbnQgdG8gdGhlIHJvb20uXG4gICAqXG4gICAqIGFyZ3M6IChwYXlsb2FkOiBVaW50OEFycmF5LCBraW5kOiBbW0RhdGFQYWNrZXRfS2luZF1dKVxuICAgKi9cbiAgRGF0YVJlY2VpdmVkID0gJ2RhdGFSZWNlaXZlZCcsXG5cbiAgLyoqXG4gICAqIFNJUCBEVE1GIHRvbmVzIHJlY2VpdmVkIGZyb20gdGhpcyBwYXJ0aWNpcGFudCBhcyBzZW5kZXIuXG4gICAqXG4gICAqIGFyZ3M6IChkdG1mOiBbW0RhdGFQYWNrZXRfS2luZF1dKVxuICAgKi9cbiAgU2lwRFRNRlJlY2VpdmVkID0gJ3NpcERUTUZSZWNlaXZlZCcsXG5cbiAgLyoqXG4gICAqIFRyYW5zY3JpcHRpb24gcmVjZWl2ZWQgZnJvbSB0aGlzIHBhcnRpY2lwYW50IGFzIGRhdGEgc291cmNlLlxuICAgKiBAYmV0YVxuICAgKi9cbiAgVHJhbnNjcmlwdGlvblJlY2VpdmVkID0gJ3RyYW5zY3JpcHRpb25SZWNlaXZlZCcsXG5cbiAgLyoqXG4gICAqIEhhcyBzcGVha2luZyBzdGF0dXMgY2hhbmdlZCBmb3IgdGhlIGN1cnJlbnQgcGFydGljaXBhbnRcbiAgICpcbiAgICogYXJnczogKHNwZWFraW5nOiBib29sZWFuKVxuICAgKi9cbiAgSXNTcGVha2luZ0NoYW5nZWQgPSAnaXNTcGVha2luZ0NoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBDb25uZWN0aW9uIHF1YWxpdHkgd2FzIGNoYW5nZWQgZm9yIGEgUGFydGljaXBhbnQuIEl0J2xsIHJlY2VpdmUgdXBkYXRlc1xuICAgKiBmcm9tIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCwgYXMgd2VsbCBhcyBhbnkgW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyB0aGF0IHdlIGFyZVxuICAgKiBzdWJzY3JpYmVkIHRvLlxuICAgKlxuICAgKiBhcmdzOiAoY29ubmVjdGlvblF1YWxpdHk6IFtbQ29ubmVjdGlvblF1YWxpdHldXSlcbiAgICovXG4gIENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCA9ICdjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBTdHJlYW1TdGF0ZSBpbmRpY2F0ZXMgaWYgYSBzdWJzY3JpYmVkIHRyYWNrIGhhcyBiZWVuIHBhdXNlZCBieSB0aGUgU0ZVXG4gICAqICh0eXBpY2FsbHkgdGhpcyBoYXBwZW5zIGJlY2F1c2Ugb2Ygc3Vic2NyaWJlcidzIGJhbmR3aWR0aCBjb25zdHJhaW50cylcbiAgICpcbiAgICogV2hlbiBiYW5kd2lkdGggY29uZGl0aW9ucyBhbGxvdywgdGhlIHRyYWNrIHdpbGwgYmUgcmVzdW1lZCBhdXRvbWF0aWNhbGx5LlxuICAgKiBUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCB3aWxsIGFsc28gYmUgZW1pdHRlZCB3aGVuIHRoYXQgaGFwcGVucy5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIHN0cmVhbVN0YXRlOiBbW1RyYWNrLlN0cmVhbVN0YXRlXV0pXG4gICAqL1xuICBUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCA9ICd0cmFja1N0cmVhbVN0YXRlQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIE9uZSBvZiBzdWJzY3JpYmVkIHRyYWNrcyBoYXZlIGNoYW5nZWQgaXRzIHBlcm1pc3Npb25zIGZvciB0aGUgY3VycmVudFxuICAgKiBwYXJ0aWNpcGFudC4gSWYgcGVybWlzc2lvbiB3YXMgcmV2b2tlZCwgdGhlbiB0aGUgdHJhY2sgd2lsbCBubyBsb25nZXJcbiAgICogYmUgc3Vic2NyaWJlZC4gSWYgcGVybWlzc2lvbiB3YXMgZ3JhbnRlZCwgYSBUcmFja1N1YnNjcmliZWQgZXZlbnQgd2lsbFxuICAgKiBiZSBlbWl0dGVkLlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSxcbiAgICogICAgICAgIHN0YXR1czogW1tUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1c11dKVxuICAgKi9cbiAgVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCA9ICd0cmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkJyxcblxuICAvKipcbiAgICogT25lIG9mIHRoZSByZW1vdGUgcGFydGljaXBhbnRzIHB1YmxpY2F0aW9ucyBoYXMgY2hhbmdlZCBpdHMgc3Vic2NyaXB0aW9uIHN0YXR1cy5cbiAgICpcbiAgICovXG4gIFRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCA9ICd0cmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQnLFxuXG4gIC8vIGZpcmVkIG9ubHkgb24gTG9jYWxQYXJ0aWNpcGFudFxuICAvKiogQGludGVybmFsICovXG4gIE1lZGlhRGV2aWNlc0Vycm9yID0gJ21lZGlhRGV2aWNlc0Vycm9yJyxcblxuICAvLyBmaXJlZCBvbmx5IG9uIExvY2FsUGFydGljaXBhbnRcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBBdWRpb1N0cmVhbUFjcXVpcmVkID0gJ2F1ZGlvU3RyZWFtQWNxdWlyZWQnLFxuXG4gIC8qKlxuICAgKiBBIHBhcnRpY2lwYW50J3MgcGVybWlzc2lvbiBoYXMgY2hhbmdlZC5cbiAgICogYXJnczogKHByZXZQZXJtaXNzaW9uczogW1tQYXJ0aWNpcGFudFBlcm1pc3Npb25dXSlcbiAgICovXG4gIFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkID0gJ3BhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkJyxcblxuICAvKiogQGludGVybmFsICovXG4gIFBDVHJhY2tBZGRlZCA9ICdwY1RyYWNrQWRkZWQnLFxuXG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCBhdHRyaWJ1dGVzIGlzIGFuIGFwcC1zcGVjaWZpYyBrZXkgdmFsdWUgc3RhdGUgdG8gYmUgcHVzaGVkIHRvXG4gICAqIGFsbCB1c2Vycy5cbiAgICogV2hlbiBhIHBhcnRpY2lwYW50J3MgYXR0cmlidXRlcyBjaGFuZ2VkLCB0aGlzIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCB3aXRoIHRoZSBjaGFuZ2VkIGF0dHJpYnV0ZXNcbiAgICogYXJnczogKGNoYW5nZWRBdHRyaWJ1dGVzOiBbW1JlY29yZDxzdHJpbmcsIHN0cmluZ11dKVxuICAgKi9cbiAgQXR0cmlidXRlc0NoYW5nZWQgPSAnYXR0cmlidXRlc0NoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBmaXJlZCBvbiBsb2NhbCBwYXJ0aWNpcGFudCBvbmx5LCB3aGVuIHRoZSBmaXJzdCByZW1vdGUgcGFydGljaXBhbnQgaGFzIHN1YnNjcmliZWQgdG8gdGhlIHRyYWNrIHNwZWNpZmllZCBpbiB0aGUgcGF5bG9hZFxuICAgKi9cbiAgTG9jYWxUcmFja1N1YnNjcmliZWQgPSAnbG9jYWxUcmFja1N1YnNjcmliZWQnLFxuXG4gIC8qKiBvbmx5IGVtaXR0ZWQgb24gbG9jYWwgcGFydGljaXBhbnQgKi9cbiAgQ2hhdE1lc3NhZ2UgPSAnY2hhdE1lc3NhZ2UnLFxufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZW51bSBFbmdpbmVFdmVudCB7XG4gIFRyYW5zcG9ydHNDcmVhdGVkID0gJ3RyYW5zcG9ydHNDcmVhdGVkJyxcbiAgQ29ubmVjdGVkID0gJ2Nvbm5lY3RlZCcsXG4gIERpc2Nvbm5lY3RlZCA9ICdkaXNjb25uZWN0ZWQnLFxuICBSZXN1bWluZyA9ICdyZXN1bWluZycsXG4gIFJlc3VtZWQgPSAncmVzdW1lZCcsXG4gIFJlc3RhcnRpbmcgPSAncmVzdGFydGluZycsXG4gIFJlc3RhcnRlZCA9ICdyZXN0YXJ0ZWQnLFxuICBTaWduYWxSZXN1bWVkID0gJ3NpZ25hbFJlc3VtZWQnLFxuICBTaWduYWxSZXN0YXJ0ZWQgPSAnc2lnbmFsUmVzdGFydGVkJyxcbiAgQ2xvc2luZyA9ICdjbG9zaW5nJyxcbiAgTWVkaWFUcmFja0FkZGVkID0gJ21lZGlhVHJhY2tBZGRlZCcsXG4gIEFjdGl2ZVNwZWFrZXJzVXBkYXRlID0gJ2FjdGl2ZVNwZWFrZXJzVXBkYXRlJyxcbiAgRGF0YVBhY2tldFJlY2VpdmVkID0gJ2RhdGFQYWNrZXRSZWNlaXZlZCcsXG4gIFJUUFZpZGVvTWFwVXBkYXRlID0gJ3J0cFZpZGVvTWFwVXBkYXRlJyxcbiAgRENCdWZmZXJTdGF0dXNDaGFuZ2VkID0gJ2RjQnVmZmVyU3RhdHVzQ2hhbmdlZCcsXG4gIFBhcnRpY2lwYW50VXBkYXRlID0gJ3BhcnRpY2lwYW50VXBkYXRlJyxcbiAgUm9vbVVwZGF0ZSA9ICdyb29tVXBkYXRlJyxcbiAgU3BlYWtlcnNDaGFuZ2VkID0gJ3NwZWFrZXJzQ2hhbmdlZCcsXG4gIFN0cmVhbVN0YXRlQ2hhbmdlZCA9ICdzdHJlYW1TdGF0ZUNoYW5nZWQnLFxuICBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSA9ICdjb25uZWN0aW9uUXVhbGl0eVVwZGF0ZScsXG4gIFN1YnNjcmlwdGlvbkVycm9yID0gJ3N1YnNjcmlwdGlvbkVycm9yJyxcbiAgU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSA9ICdzdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlJyxcbiAgUmVtb3RlTXV0ZSA9ICdyZW1vdGVNdXRlJyxcbiAgU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSAnc3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUnLFxuICBMb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSAnbG9jYWxUcmFja1VucHVibGlzaGVkJyxcbiAgTG9jYWxUcmFja1N1YnNjcmliZWQgPSAnbG9jYWxUcmFja1N1YnNjcmliZWQnLFxuICBPZmZsaW5lID0gJ29mZmxpbmUnLFxuICBTaWduYWxSZXF1ZXN0UmVzcG9uc2UgPSAnc2lnbmFsUmVxdWVzdFJlc3BvbnNlJyxcbn1cblxuZXhwb3J0IGVudW0gVHJhY2tFdmVudCB7XG4gIE1lc3NhZ2UgPSAnbWVzc2FnZScsXG4gIE11dGVkID0gJ211dGVkJyxcbiAgVW5tdXRlZCA9ICd1bm11dGVkJyxcbiAgLyoqXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxUcmFja3NcbiAgICovXG4gIFJlc3RhcnRlZCA9ICdyZXN0YXJ0ZWQnLFxuICBFbmRlZCA9ICdlbmRlZCcsXG4gIFN1YnNjcmliZWQgPSAnc3Vic2NyaWJlZCcsXG4gIFVuc3Vic2NyaWJlZCA9ICd1bnN1YnNjcmliZWQnLFxuICAvKiogQGludGVybmFsICovXG4gIFVwZGF0ZVNldHRpbmdzID0gJ3VwZGF0ZVNldHRpbmdzJyxcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBVcGRhdGVTdWJzY3JpcHRpb24gPSAndXBkYXRlU3Vic2NyaXB0aW9uJyxcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBBdWRpb1BsYXliYWNrU3RhcnRlZCA9ICdhdWRpb1BsYXliYWNrU3RhcnRlZCcsXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgQXVkaW9QbGF5YmFja0ZhaWxlZCA9ICdhdWRpb1BsYXliYWNrRmFpbGVkJyxcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBPbmx5IGZpcmVzIG9uIExvY2FsQXVkaW9UcmFjayBpbnN0YW5jZXNcbiAgICovXG4gIEF1ZGlvU2lsZW5jZURldGVjdGVkID0gJ2F1ZGlvU2lsZW5jZURldGVjdGVkJyxcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBWaXNpYmlsaXR5Q2hhbmdlZCA9ICd2aXNpYmlsaXR5Q2hhbmdlZCcsXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCA9ICd2aWRlb0RpbWVuc2lvbnNDaGFuZ2VkJyxcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBWaWRlb1BsYXliYWNrU3RhcnRlZCA9ICd2aWRlb1BsYXliYWNrU3RhcnRlZCcsXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVmlkZW9QbGF5YmFja0ZhaWxlZCA9ICd2aWRlb1BsYXliYWNrRmFpbGVkJyxcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBFbGVtZW50QXR0YWNoZWQgPSAnZWxlbWVudEF0dGFjaGVkJyxcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBFbGVtZW50RGV0YWNoZWQgPSAnZWxlbWVudERldGFjaGVkJyxcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBPbmx5IGZpcmVzIG9uIExvY2FsVHJhY2tzXG4gICAqL1xuICBVcHN0cmVhbVBhdXNlZCA9ICd1cHN0cmVhbVBhdXNlZCcsXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogT25seSBmaXJlcyBvbiBMb2NhbFRyYWNrc1xuICAgKi9cbiAgVXBzdHJlYW1SZXN1bWVkID0gJ3Vwc3RyZWFtUmVzdW1lZCcsXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogRmlyZXMgb24gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblxuICAgKi9cbiAgU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQgPSAnc3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQnLFxuICAvKipcbiAgICogRmlyZXMgb24gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblxuICAgKi9cbiAgU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCA9ICdzdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkJyxcbiAgLyoqXG4gICAqIEZpcmVzIG9uIFJlbW90ZVRyYWNrUHVibGljYXRpb25cbiAgICovXG4gIFN1YnNjcmlwdGlvbkZhaWxlZCA9ICdzdWJzY3JpcHRpb25GYWlsZWQnLFxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBUcmFja1Byb2Nlc3NvclVwZGF0ZSA9ICd0cmFja1Byb2Nlc3NvclVwZGF0ZScsXG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgQXVkaW9UcmFja0ZlYXR1cmVVcGRhdGUgPSAnYXVkaW9UcmFja0ZlYXR1cmVVcGRhdGUnLFxuXG4gIC8qKlxuICAgKiBAYmV0YVxuICAgKi9cbiAgVHJhbnNjcmlwdGlvblJlY2VpdmVkID0gJ3RyYW5zY3JpcHRpb25SZWNlaXZlZCcsXG5cbiAgLyoqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIFRpbWVTeW5jVXBkYXRlID0gJ3RpbWVTeW5jVXBkYXRlJyxcbn1cbiIsImltcG9ydCB7XG4gIEF1ZGlvVHJhY2tGZWF0dXJlLFxuICBWaWRlb1F1YWxpdHkgYXMgUHJvdG9RdWFsaXR5LFxuICBTdHJlYW1TdGF0ZSBhcyBQcm90b1N0cmVhbVN0YXRlLFxuICBUcmFja1NvdXJjZSxcbiAgVHJhY2tUeXBlLFxufSBmcm9tICdAbGl2ZWtpdC9wcm90b2NvbCc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHR5cGUgVHlwZWRFdmVudEVtaXR0ZXIgZnJvbSAndHlwZWQtZW1pdHRlcic7XG5pbXBvcnQgdHlwZSB7IFNpZ25hbENsaWVudCB9IGZyb20gJy4uLy4uL2FwaS9TaWduYWxDbGllbnQnO1xuaW1wb3J0IGxvZywgeyBMb2dnZXJOYW1lcywgdHlwZSBTdHJ1Y3R1cmVkTG9nZ2VyLCBnZXRMb2dnZXIgfSBmcm9tICcuLi8uLi9sb2dnZXInO1xuaW1wb3J0IHsgVHJhY2tFdmVudCB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IExvZ2dlck9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpc0ZpcmVGb3gsIGlzU2FmYXJpLCBpc1dlYiB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgVHJhY2tQcm9jZXNzb3IgfSBmcm9tICcuL3Byb2Nlc3Nvci90eXBlcyc7XG5pbXBvcnQgeyBnZXRMb2dDb250ZXh0RnJvbVRyYWNrIH0gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IEJBQ0tHUk9VTkRfUkVBQ1RJT05fREVMQVkgPSA1MDAwO1xuXG4vLyBrZWVwIG9sZCBhdWRpbyBlbGVtZW50cyB3aGVuIGRldGFjaGVkLCB3ZSB3b3VsZCByZS11c2UgdGhlbSBzaW5jZSBvbiBpT1Ncbi8vIFNhZmFyaSB0cmFja3Mgd2hpY2ggYXVkaW8gZWxlbWVudHMgaGF2ZSBiZWVuIFwiYmxlc3NlZFwiIGJ5IHRoZSB1c2VyLlxuY29uc3QgcmVjeWNsZWRFbGVtZW50czogQXJyYXk8SFRNTEF1ZGlvRWxlbWVudD4gPSBbXTtcblxuZXhwb3J0IGVudW0gVmlkZW9RdWFsaXR5IHtcbiAgTE9XID0gUHJvdG9RdWFsaXR5LkxPVyxcbiAgTUVESVVNID0gUHJvdG9RdWFsaXR5Lk1FRElVTSxcbiAgSElHSCA9IFByb3RvUXVhbGl0eS5ISUdILFxufVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRyYWNrPFxuICBUcmFja0tpbmQgZXh0ZW5kcyBUcmFjay5LaW5kID0gVHJhY2suS2luZCxcbj4gZXh0ZW5kcyAoRXZlbnRFbWl0dGVyIGFzIG5ldyAoKSA9PiBUeXBlZEV2ZW50RW1pdHRlcjxUcmFja0V2ZW50Q2FsbGJhY2tzPikge1xuICByZWFkb25seSBraW5kOiBUcmFja0tpbmQ7XG5cbiAgYXR0YWNoZWRFbGVtZW50czogSFRNTE1lZGlhRWxlbWVudFtdID0gW107XG5cbiAgaXNNdXRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHNvdXJjZTogVHJhY2suU291cmNlO1xuXG4gIC8qKlxuICAgKiBzaWQgaXMgc2V0IGFmdGVyIHRyYWNrIGlzIHB1Ymxpc2hlZCB0byBzZXJ2ZXIsIG9yIGlmIGl0J3MgYSByZW1vdGUgdHJhY2tcbiAgICovXG4gIHNpZD86IFRyYWNrLlNJRDtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBtZWRpYVN0cmVhbT86IE1lZGlhU3RyZWFtO1xuXG4gIC8qKlxuICAgKiBpbmRpY2F0ZXMgY3VycmVudCBzdGF0ZSBvZiBzdHJlYW0sIGl0J2xsIGluZGljYXRlIGBwYXVzZWRgIGlmIHRoZSB0cmFja1xuICAgKiBoYXMgYmVlbiBwYXVzZWQgYnkgY29uZ2VzdGlvbiBjb250cm9sbGVyXG4gICAqL1xuICBzdHJlYW1TdGF0ZTogVHJhY2suU3RyZWFtU3RhdGUgPSBUcmFjay5TdHJlYW1TdGF0ZS5BY3RpdmU7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBydHBUaW1lc3RhbXA6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICBwcm90ZWN0ZWQgX21lZGlhU3RyZWFtVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2s7XG5cbiAgcHJvdGVjdGVkIF9tZWRpYVN0cmVhbUlEOiBzdHJpbmc7XG5cbiAgcHJvdGVjdGVkIGlzSW5CYWNrZ3JvdW5kOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBiYWNrZ3JvdW5kVGltZW91dDogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD4gfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBsb2dnZXJDb250ZXh0Q2I6IExvZ2dlck9wdGlvbnNbJ2xvZ2dlckNvbnRleHRDYiddO1xuXG4gIHByb3RlY3RlZCB0aW1lU3luY0hhbmRsZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gIHByb3RlY3RlZCBfY3VycmVudEJpdHJhdGU6IG51bWJlciA9IDA7XG5cbiAgcHJvdGVjdGVkIG1vbml0b3JJbnRlcnZhbD86IFJldHVyblR5cGU8dHlwZW9mIHNldEludGVydmFsPjtcblxuICBwcm90ZWN0ZWQgbG9nOiBTdHJ1Y3R1cmVkTG9nZ2VyID0gbG9nO1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihcbiAgICBtZWRpYVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgIGtpbmQ6IFRyYWNrS2luZCxcbiAgICBsb2dnZXJPcHRpb25zOiBMb2dnZXJPcHRpb25zID0ge30sXG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIobG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lID8/IExvZ2dlck5hbWVzLlRyYWNrKTtcbiAgICB0aGlzLmxvZ2dlckNvbnRleHRDYiA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyQ29udGV4dENiO1xuXG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgPSBtZWRpYVRyYWNrO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtSUQgPSBtZWRpYVRyYWNrLmlkO1xuICAgIHRoaXMuc291cmNlID0gVHJhY2suU291cmNlLlVua25vd247XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMubG9nZ2VyQ29udGV4dENiPy4oKSxcbiAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2sodGhpcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBjdXJyZW50IHJlY2VpdmUgYml0cyBwZXIgc2Vjb25kICovXG4gIGdldCBjdXJyZW50Qml0cmF0ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50Qml0cmF0ZTtcbiAgfVxuXG4gIGdldCBtZWRpYVN0cmVhbVRyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiB1c2VkIGZvciBrZWVwIG1lZGlhU3RyZWFtJ3MgZmlyc3QgaWQsIHNpbmNlIGl0J3MgaWQgbWlnaHQgY2hhbmdlXG4gICAqIGlmIHdlIGRpc2FibGUvZW5hYmxlIGEgdHJhY2tcbiAgICovXG4gIGdldCBtZWRpYVN0cmVhbUlEKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtSUQ7XG4gIH1cblxuICAvKipcbiAgICogY3JlYXRlcyBhIG5ldyBIVE1MQXVkaW9FbGVtZW50IG9yIEhUTUxWaWRlb0VsZW1lbnQsIGF0dGFjaGVzIHRvIGl0LCBhbmQgcmV0dXJucyBpdFxuICAgKi9cbiAgYXR0YWNoKCk6IEhUTUxNZWRpYUVsZW1lbnQ7XG5cbiAgLyoqXG4gICAqIGF0dGFjaGVzIHRyYWNrIHRvIGFuIGV4aXN0aW5nIEhUTUxBdWRpb0VsZW1lbnQgb3IgSFRNTFZpZGVvRWxlbWVudFxuICAgKi9cbiAgYXR0YWNoKGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50O1xuICBhdHRhY2goZWxlbWVudD86IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50IHtcbiAgICBsZXQgZWxlbWVudFR5cGUgPSAnYXVkaW8nO1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgIGVsZW1lbnRUeXBlID0gJ3ZpZGVvJztcbiAgICB9XG4gICAgaWYgKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPT09IDAgJiYgdGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICB0aGlzLmFkZEFwcFZpc2liaWxpdHlMaXN0ZW5lcigpO1xuICAgIH1cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICByZWN5Y2xlZEVsZW1lbnRzLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICBpZiAoZS5wYXJlbnRFbGVtZW50ID09PSBudWxsICYmICFlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIHBvb2xcbiAgICAgICAgICByZWN5Y2xlZEVsZW1lbnRzLnNwbGljZShyZWN5Y2xlZEVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudCA9IDxIVE1MTWVkaWFFbGVtZW50PmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmluY2x1ZGVzKGVsZW1lbnQpKSB7XG4gICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICAvLyBldmVuIGlmIHdlIGJlbGlldmUgaXQncyBhbHJlYWR5IGF0dGFjaGVkIHRvIHRoZSBlbGVtZW50LCBpdCdzIHBvc3NpYmxlXG4gICAgLy8gdGhlIGVsZW1lbnQncyBzcmNPYmplY3Qgd2FzIHNldCB0byBzb21ldGhpbmcgZWxzZSBvdXQgb2YgYmFuZC5cbiAgICAvLyB3ZSdsbCB3YW50IHRvIHJlLWF0dGFjaCBpdCBpbiB0aGF0IGNhc2VcbiAgICBhdHRhY2hUb0VsZW1lbnQodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbGVtZW50KTtcblxuICAgIC8vIGhhbmRsZSBhdXRvIHBsYXliYWNrIGZhaWx1cmVzXG4gICAgY29uc3QgYWxsTWVkaWFTdHJlYW1UcmFja3MgPSAoZWxlbWVudC5zcmNPYmplY3QgYXMgTWVkaWFTdHJlYW0pLmdldFRyYWNrcygpO1xuICAgIGNvbnN0IGhhc0F1ZGlvID0gYWxsTWVkaWFTdHJlYW1UcmFja3Muc29tZSgodHIpID0+IHRyLmtpbmQgPT09ICdhdWRpbycpO1xuXG4gICAgLy8gbWFudWFsbHkgcGxheSBtZWRpYSB0byBkZXRlY3QgYXV0byBwbGF5YmFjayBzdGF0dXNcbiAgICBlbGVtZW50XG4gICAgICAucGxheSgpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChoYXNBdWRpbyA/IFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja1N0YXJ0ZWQgOiBUcmFja0V2ZW50LlZpZGVvUGxheWJhY2tTdGFydGVkKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgaWYgKGUubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoaGFzQXVkaW8gPyBUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQgOiBUcmFja0V2ZW50LlZpZGVvUGxheWJhY2tGYWlsZWQsIGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgLy8gY29tbW9ubHkgdHJpZ2dlcmVkIGJ5IGFub3RoZXIgYHBsYXlgIHJlcXVlc3QsIG9ubHkgbG9nIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAgICAgICAgICBsb2cuZGVidWcoXG4gICAgICAgICAgICBgJHtoYXNBdWRpbyA/ICdhdWRpbycgOiAndmlkZW8nfSBwbGF5YmFjayBhYm9ydGVkLCBsaWtlbHkgZHVlIHRvIG5ldyBwbGF5IHJlcXVlc3RgLFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nLndhcm4oYGNvdWxkIG5vdCBwbGF5YmFjayAke2hhc0F1ZGlvID8gJ2F1ZGlvJyA6ICd2aWRlbyd9YCwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYXVkaW8gcGxheWJhY2sgaXNuJ3QgYWxsb3dlZCBtYWtlIHN1cmUgd2Ugc3RpbGwgcGxheSBiYWNrIHRoZSB2aWRlb1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaGFzQXVkaW8gJiZcbiAgICAgICAgICBlbGVtZW50ICYmXG4gICAgICAgICAgYWxsTWVkaWFTdHJlYW1UcmFja3Muc29tZSgodHIpID0+IHRyLmtpbmQgPT09ICd2aWRlbycpICYmXG4gICAgICAgICAgZS5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJ1xuICAgICAgICApIHtcbiAgICAgICAgICBlbGVtZW50Lm11dGVkID0gdHJ1ZTtcbiAgICAgICAgICBlbGVtZW50LnBsYXkoKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBjYXRjaCBmb3IgU2FmYXJpLCBleGNlZWRlZCBvcHRpb25zIGF0IHRoaXMgcG9pbnQgdG8gYXV0b21hdGljYWxseSBwbGF5IHRoZSBtZWRpYSBlbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRWxlbWVudEF0dGFjaGVkLCBlbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRhY2hlcyBmcm9tIGFsbCBhdHRhY2hlZCBlbGVtZW50c1xuICAgKi9cbiAgZGV0YWNoKCk6IEhUTUxNZWRpYUVsZW1lbnRbXTtcblxuICAvKipcbiAgICogRGV0YWNoIGZyb20gYSBzaW5nbGUgZWxlbWVudFxuICAgKiBAcGFyYW0gZWxlbWVudFxuICAgKi9cbiAgZGV0YWNoKGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50O1xuICBkZXRhY2goZWxlbWVudD86IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50IHwgSFRNTE1lZGlhRWxlbWVudFtdIHtcbiAgICB0cnkge1xuICAgICAgLy8gZGV0YWNoIGZyb20gYSBzaW5nbGUgZWxlbWVudFxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbGVtZW50KTtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICB0aGlzLnJlY3ljbGVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVsZW1lbnREZXRhY2hlZCwgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRldGFjaGVkOiBIVE1MTWVkaWFFbGVtZW50W10gPSBbXTtcbiAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKChlbG0pID0+IHtcbiAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbG0pO1xuICAgICAgICBkZXRhY2hlZC5wdXNoKGVsbSk7XG4gICAgICAgIHRoaXMucmVjeWNsZUVsZW1lbnQoZWxtKTtcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRWxlbWVudERldGFjaGVkLCBlbG0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHJlbW92ZSBhbGwgdHJhY2tzXG4gICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMgPSBbXTtcbiAgICAgIHJldHVybiBkZXRhY2hlZDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdG9wKCkge1xuICAgIHRoaXMuc3RvcE1vbml0b3IoKTtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBlbmFibGUoKSB7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBkaXNhYmxlKCkge1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICB9XG5cbiAgLyogQGludGVybmFsICovXG4gIGFic3RyYWN0IHN0YXJ0TW9uaXRvcihzaWduYWxDbGllbnQ/OiBTaWduYWxDbGllbnQpOiB2b2lkO1xuXG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzdG9wTW9uaXRvcigpIHtcbiAgICBpZiAodGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5tb25pdG9ySW50ZXJ2YWwpO1xuICAgIH1cbiAgICBpZiAodGhpcy50aW1lU3luY0hhbmRsZSkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy50aW1lU3luY0hhbmRsZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVMb2dnZXJPcHRpb25zKGxvZ2dlck9wdGlvbnM6IExvZ2dlck9wdGlvbnMpIHtcbiAgICBpZiAobG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSB7XG4gICAgICB0aGlzLmxvZyA9IGdldExvZ2dlcihsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpO1xuICAgIH1cbiAgICBpZiAobG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2IpIHtcbiAgICAgIHRoaXMubG9nZ2VyQ29udGV4dENiID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2I7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZWN5Y2xlRWxlbWVudChlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQXVkaW9FbGVtZW50KSB7XG4gICAgICAvLyB3ZSBvbmx5IG5lZWQgdG8gcmUtdXNlIGEgc2luZ2xlIGVsZW1lbnRcbiAgICAgIGxldCBzaG91bGRDYWNoZSA9IHRydWU7XG4gICAgICBlbGVtZW50LnBhdXNlKCk7XG4gICAgICByZWN5Y2xlZEVsZW1lbnRzLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgaWYgKCFlLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICBzaG91bGRDYWNoZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChzaG91bGRDYWNoZSkge1xuICAgICAgICByZWN5Y2xlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMuYmFja2dyb3VuZFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmJhY2tncm91bmRUaW1lb3V0KTtcbiAgICB9XG4gICAgLy8gZGVsYXkgYXBwIHZpc2liaWxpdHkgdXBkYXRlIGlmIGl0IGdvZXMgdG8gaGlkZGVuXG4gICAgLy8gdXBkYXRlIGltbWVkaWF0ZWx5IGlmIGl0IGNvbWVzIGJhY2sgdG8gZm9jdXNcbiAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJykge1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kVGltZW91dCA9IHNldFRpbWVvdXQoXG4gICAgICAgICgpID0+IHRoaXMuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSxcbiAgICAgICAgQkFDS0dST1VORF9SRUFDVElPTl9ERUxBWSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCkge1xuICAgIHRoaXMuaXNJbkJhY2tncm91bmQgPSBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nO1xuICAgIGlmICghdGhpcy5pc0luQmFja2dyb3VuZCAmJiB0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICgpID0+XG4gICAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goKGVsKSA9PlxuICAgICAgICAgICAgZWwucGxheSgpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgLyoqIGNhdGNoIGNsYXVzZSBuZWNlc3NhcnkgZm9yIFNhZmFyaSAqL1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKSxcbiAgICAgICAgMCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGFkZEFwcFZpc2liaWxpdHlMaXN0ZW5lcigpIHtcbiAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbic7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5hcHBWaXNpYmlsaXR5Q2hhbmdlZExpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCByZW1vdmVBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKSB7XG4gICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLmFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXR0YWNoVG9FbGVtZW50KHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLCBlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50KSB7XG4gIGxldCBtZWRpYVN0cmVhbTogTWVkaWFTdHJlYW07XG4gIGlmIChlbGVtZW50LnNyY09iamVjdCBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtKSB7XG4gICAgbWVkaWFTdHJlYW0gPSBlbGVtZW50LnNyY09iamVjdDtcbiAgfSBlbHNlIHtcbiAgICBtZWRpYVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgdHJhY2sgbWF0Y2hlcyBleGlzdGluZyB0cmFja1xuICBsZXQgZXhpc3RpbmdUcmFja3M6IE1lZGlhU3RyZWFtVHJhY2tbXTtcbiAgaWYgKHRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICBleGlzdGluZ1RyYWNrcyA9IG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCk7XG4gIH0gZWxzZSB7XG4gICAgZXhpc3RpbmdUcmFja3MgPSBtZWRpYVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpO1xuICB9XG4gIGlmICghZXhpc3RpbmdUcmFja3MuaW5jbHVkZXModHJhY2spKSB7XG4gICAgZXhpc3RpbmdUcmFja3MuZm9yRWFjaCgoZXQpID0+IHtcbiAgICAgIG1lZGlhU3RyZWFtLnJlbW92ZVRyYWNrKGV0KTtcbiAgICB9KTtcbiAgICBtZWRpYVN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG4gIH1cblxuICBpZiAoIWlzU2FmYXJpKCkgfHwgIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkpIHtcbiAgICAvLyB3aGVuIGluIGxvdyBwb3dlciBtb2RlIChhcHBsaWVzIHRvIGJvdGggbWFjT1MgYW5kIGlPUyksIFNhZmFyaSB3aWxsIHNob3cgYSBwbGF5L3BhdXNlIG92ZXJsYXlcbiAgICAvLyB3aGVuIGEgdmlkZW8gc3RhcnRzIHRoYXQgaGFzIHRoZSBgYXV0b3BsYXlgIGF0dHJpYnV0ZSBpcyBzZXQuXG4gICAgLy8gd2Ugd29yayBhcm91bmQgdGhpcyBieSBfbm90XyBzZXR0aW5nIHRoZSBhdXRvcGxheSBhdHRyaWJ1dGUgb24gc2FmYXJpIGFuZCBpbnN0ZWFkIGNhbGwgYHNldFRpbWVvdXQoKCkgPT4gZWwucGxheSgpLDApYCBmdXJ0aGVyIGRvd25cbiAgICBlbGVtZW50LmF1dG9wbGF5ID0gdHJ1ZTtcbiAgfVxuICAvLyBJbiBjYXNlIHRoZXJlIGFyZSBubyBhdWRpbyB0cmFja3MgcHJlc2VudCBvbiB0aGUgbWVkaWFzdHJlYW0sIHdlIHNldCB0aGUgZWxlbWVudCBhcyBtdXRlZCB0byBlbnN1cmUgYXV0b3BsYXkgd29ya3NcbiAgZWxlbWVudC5tdXRlZCA9IG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID09PSAwO1xuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICBlbGVtZW50LnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGF2b2lkIGZsaWNrZXJcbiAgaWYgKGVsZW1lbnQuc3JjT2JqZWN0ICE9PSBtZWRpYVN0cmVhbSkge1xuICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XG4gICAgaWYgKChpc1NhZmFyaSgpIHx8IGlzRmlyZUZveCgpKSAmJiBlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgLy8gRmlyZWZveCBhbHNvIGhhcyBhIHRpbWluZyBpc3N1ZSB3aGVyZSB2aWRlbyBkb2Vzbid0IGFjdHVhbGx5IGdldCBhdHRhY2hlZCB1bmxlc3NcbiAgICAgIC8vIHBlcmZvcm1lZCBvdXQtb2YtYmFuZFxuICAgICAgLy8gU2FmYXJpIDE1IGhhcyBhIGJ1ZyB3aGVyZSBpbiBjZXJ0YWluIGxheW91dHMsIHZpZGVvIGVsZW1lbnQgcmVuZGVyc1xuICAgICAgLy8gYmxhY2sgdW50aWwgdGhlIHBhZ2UgaXMgcmVzaXplZCBvciBvdGhlciBjaGFuZ2VzIHRha2UgcGxhY2UuXG4gICAgICAvLyBSZXNldHRpbmcgdGhlIHNyYyB0cmlnZ2VycyBpdCB0byByZW5kZXIuXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9ydW1zL3RocmVhZC82OTA1MjNcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBlbGVtZW50LnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xuICAgICAgICAvLyBTYWZhcmkgMTUgc29tZXRpbWVzIGZhaWxzIHRvIHN0YXJ0IGEgdmlkZW9cbiAgICAgICAgLy8gd2hlbiB0aGUgd2luZG93IGlzIGJhY2tncm91bmRlZCBiZWZvcmUgdGhlIGZpcnN0IGZyYW1lIGlzIGRyYXduXG4gICAgICAgIC8vIG1hbnVhbGx5IGNhbGxpbmcgcGxheSBoZXJlIHNlZW1zIHRvIGZpeCB0aGF0XG4gICAgICAgIGVsZW1lbnQucGxheSgpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAvKiogZG8gbm90aGluZyAqL1xuICAgICAgICB9KTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGV0YWNoVHJhY2sodHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQuc3JjT2JqZWN0IGluc3RhbmNlb2YgTWVkaWFTdHJlYW0pIHtcbiAgICBjb25zdCBtZWRpYVN0cmVhbSA9IGVsZW1lbnQuc3JjT2JqZWN0O1xuICAgIG1lZGlhU3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICBpZiAobWVkaWFTdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgbmFtZXNwYWNlIFRyYWNrIHtcbiAgZXhwb3J0IGVudW0gS2luZCB7XG4gICAgQXVkaW8gPSAnYXVkaW8nLFxuICAgIFZpZGVvID0gJ3ZpZGVvJyxcbiAgICBVbmtub3duID0gJ3Vua25vd24nLFxuICB9XG4gIGV4cG9ydCB0eXBlIFNJRCA9IHN0cmluZztcbiAgZXhwb3J0IGVudW0gU291cmNlIHtcbiAgICBDYW1lcmEgPSAnY2FtZXJhJyxcbiAgICBNaWNyb3Bob25lID0gJ21pY3JvcGhvbmUnLFxuICAgIFNjcmVlblNoYXJlID0gJ3NjcmVlbl9zaGFyZScsXG4gICAgU2NyZWVuU2hhcmVBdWRpbyA9ICdzY3JlZW5fc2hhcmVfYXVkaW8nLFxuICAgIFVua25vd24gPSAndW5rbm93bicsXG4gIH1cblxuICBleHBvcnQgZW51bSBTdHJlYW1TdGF0ZSB7XG4gICAgQWN0aXZlID0gJ2FjdGl2ZScsXG4gICAgUGF1c2VkID0gJ3BhdXNlZCcsXG4gICAgVW5rbm93biA9ICd1bmtub3duJyxcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgRGltZW5zaW9ucyB7XG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICBoZWlnaHQ6IG51bWJlcjtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGtpbmRUb1Byb3RvKGs6IEtpbmQpOiBUcmFja1R5cGUge1xuICAgIHN3aXRjaCAoaykge1xuICAgICAgY2FzZSBLaW5kLkF1ZGlvOlxuICAgICAgICByZXR1cm4gVHJhY2tUeXBlLkFVRElPO1xuICAgICAgY2FzZSBLaW5kLlZpZGVvOlxuICAgICAgICByZXR1cm4gVHJhY2tUeXBlLlZJREVPO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRklYTUUgdGhpcyB3YXMgVU5SRUNPR05JWkVEIGJlZm9yZVxuICAgICAgICByZXR1cm4gVHJhY2tUeXBlLkRBVEE7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBleHBvcnQgZnVuY3Rpb24ga2luZEZyb21Qcm90byh0OiBUcmFja1R5cGUpOiBLaW5kIHwgdW5kZWZpbmVkIHtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgVHJhY2tUeXBlLkFVRElPOlxuICAgICAgICByZXR1cm4gS2luZC5BdWRpbztcbiAgICAgIGNhc2UgVHJhY2tUeXBlLlZJREVPOlxuICAgICAgICByZXR1cm4gS2luZC5WaWRlbztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBLaW5kLlVua25vd247XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBleHBvcnQgZnVuY3Rpb24gc291cmNlVG9Qcm90byhzOiBTb3VyY2UpOiBUcmFja1NvdXJjZSB7XG4gICAgc3dpdGNoIChzKSB7XG4gICAgICBjYXNlIFNvdXJjZS5DYW1lcmE6XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5DQU1FUkE7XG4gICAgICBjYXNlIFNvdXJjZS5NaWNyb3Bob25lOlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuTUlDUk9QSE9ORTtcbiAgICAgIGNhc2UgU291cmNlLlNjcmVlblNoYXJlOlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFO1xuICAgICAgY2FzZSBTb3VyY2UuU2NyZWVuU2hhcmVBdWRpbzpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRV9BVURJTztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5VTktOT1dOO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHNvdXJjZUZyb21Qcm90byhzOiBUcmFja1NvdXJjZSk6IFNvdXJjZSB7XG4gICAgc3dpdGNoIChzKSB7XG4gICAgICBjYXNlIFRyYWNrU291cmNlLkNBTUVSQTpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5DYW1lcmE7XG4gICAgICBjYXNlIFRyYWNrU291cmNlLk1JQ1JPUEhPTkU6XG4gICAgICAgIHJldHVybiBTb3VyY2UuTWljcm9waG9uZTtcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFOlxuICAgICAgICByZXR1cm4gU291cmNlLlNjcmVlblNoYXJlO1xuICAgICAgY2FzZSBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkVfQVVESU86XG4gICAgICAgIHJldHVybiBTb3VyY2UuU2NyZWVuU2hhcmVBdWRpbztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBTb3VyY2UuVW5rbm93bjtcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGV4cG9ydCBmdW5jdGlvbiBzdHJlYW1TdGF0ZUZyb21Qcm90byhzOiBQcm90b1N0cmVhbVN0YXRlKTogU3RyZWFtU3RhdGUge1xuICAgIHN3aXRjaCAocykge1xuICAgICAgY2FzZSBQcm90b1N0cmVhbVN0YXRlLkFDVElWRTpcbiAgICAgICAgcmV0dXJuIFN0cmVhbVN0YXRlLkFjdGl2ZTtcbiAgICAgIGNhc2UgUHJvdG9TdHJlYW1TdGF0ZS5QQVVTRUQ6XG4gICAgICAgIHJldHVybiBTdHJlYW1TdGF0ZS5QYXVzZWQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUuVW5rbm93bjtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgVHJhY2tFdmVudENhbGxiYWNrcyA9IHtcbiAgbWVzc2FnZTogKCkgPT4gdm9pZDtcbiAgbXV0ZWQ6ICh0cmFjaz86IGFueSkgPT4gdm9pZDtcbiAgdW5tdXRlZDogKHRyYWNrPzogYW55KSA9PiB2b2lkO1xuICByZXN0YXJ0ZWQ6ICh0cmFjaz86IGFueSkgPT4gdm9pZDtcbiAgZW5kZWQ6ICh0cmFjaz86IGFueSkgPT4gdm9pZDtcbiAgdXBkYXRlU2V0dGluZ3M6ICgpID0+IHZvaWQ7XG4gIHVwZGF0ZVN1YnNjcmlwdGlvbjogKCkgPT4gdm9pZDtcbiAgYXVkaW9QbGF5YmFja1N0YXJ0ZWQ6ICgpID0+IHZvaWQ7XG4gIGF1ZGlvUGxheWJhY2tGYWlsZWQ6IChlcnJvcj86IEVycm9yKSA9PiB2b2lkO1xuICBhdWRpb1NpbGVuY2VEZXRlY3RlZDogKCkgPT4gdm9pZDtcbiAgdmlzaWJpbGl0eUNoYW5nZWQ6ICh2aXNpYmxlOiBib29sZWFuLCB0cmFjaz86IGFueSkgPT4gdm9pZDtcbiAgdmlkZW9EaW1lbnNpb25zQ2hhbmdlZDogKGRpbWVuc2lvbnM6IFRyYWNrLkRpbWVuc2lvbnMsIHRyYWNrPzogYW55KSA9PiB2b2lkO1xuICB2aWRlb1BsYXliYWNrU3RhcnRlZDogKCkgPT4gdm9pZDtcbiAgdmlkZW9QbGF5YmFja0ZhaWxlZDogKGVycm9yPzogRXJyb3IpID0+IHZvaWQ7XG4gIGVsZW1lbnRBdHRhY2hlZDogKGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpID0+IHZvaWQ7XG4gIGVsZW1lbnREZXRhY2hlZDogKGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpID0+IHZvaWQ7XG4gIHVwc3RyZWFtUGF1c2VkOiAodHJhY2s6IGFueSkgPT4gdm9pZDtcbiAgdXBzdHJlYW1SZXN1bWVkOiAodHJhY2s6IGFueSkgPT4gdm9pZDtcbiAgdHJhY2tQcm9jZXNzb3JVcGRhdGU6IChwcm9jZXNzb3I/OiBUcmFja1Byb2Nlc3NvcjxUcmFjay5LaW5kLCBhbnk+KSA9PiB2b2lkO1xuICBhdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZTogKHRyYWNrOiBhbnksIGZlYXR1cmU6IEF1ZGlvVHJhY2tGZWF0dXJlLCBlbmFibGVkOiBib29sZWFuKSA9PiB2b2lkO1xuICB0aW1lU3luY1VwZGF0ZTogKHVwZGF0ZTogeyB0aW1lc3RhbXA6IG51bWJlcjsgcnRwVGltZXN0YW1wOiBudW1iZXIgfSkgPT4gdm9pZDtcbn07XG4iLCJpbXBvcnQgeyBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlIH0gZnJvbSAnQGxpdmVraXQvcHJvdG9jb2wnO1xuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2xvbmVEZWVwJztcbmltcG9ydCB7IGlzU2FmYXJpLCBzbGVlcCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi9UcmFjayc7XG5pbXBvcnQgdHlwZSB7IFRyYWNrUHVibGljYXRpb24gfSBmcm9tICcuL1RyYWNrUHVibGljYXRpb24nO1xuaW1wb3J0IHtcbiAgdHlwZSBBdWRpb0NhcHR1cmVPcHRpb25zLFxuICB0eXBlIENyZWF0ZUxvY2FsVHJhY2tzT3B0aW9ucyxcbiAgdHlwZSBTY3JlZW5TaGFyZUNhcHR1cmVPcHRpb25zLFxuICB0eXBlIFZpZGVvQ2FwdHVyZU9wdGlvbnMsXG4gIHR5cGUgVmlkZW9Db2RlYyxcbiAgdmlkZW9Db2RlY3MsXG59IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgdHlwZSB7IEF1ZGlvVHJhY2sgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGVmYXVsdE9wdGlvbnMoXG4gIG9wdGlvbnM/OiBDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnMsXG4gIGF1ZGlvRGVmYXVsdHM/OiBBdWRpb0NhcHR1cmVPcHRpb25zLFxuICB2aWRlb0RlZmF1bHRzPzogVmlkZW9DYXB0dXJlT3B0aW9ucyxcbik6IENyZWF0ZUxvY2FsVHJhY2tzT3B0aW9ucyB7XG4gIGNvbnN0IG9wdHM6IENyZWF0ZUxvY2FsVHJhY2tzT3B0aW9ucyA9IGNsb25lRGVlcChvcHRpb25zKSA/PyB7fTtcbiAgaWYgKG9wdHMuYXVkaW8gPT09IHRydWUpIG9wdHMuYXVkaW8gPSB7fTtcbiAgaWYgKG9wdHMudmlkZW8gPT09IHRydWUpIG9wdHMudmlkZW8gPSB7fTtcblxuICAvLyB1c2UgZGVmYXVsdHNcbiAgaWYgKG9wdHMuYXVkaW8pIHtcbiAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhcbiAgICAgIG9wdHMuYXVkaW8gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgICBhdWRpb0RlZmF1bHRzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgICk7XG4gIH1cbiAgaWYgKG9wdHMudmlkZW8pIHtcbiAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhcbiAgICAgIG9wdHMudmlkZW8gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgICB2aWRlb0RlZmF1bHRzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG9wdHM7XG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nKFxuICBtYWluT2JqZWN0OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgb2JqZWN0VG9NZXJnZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4pOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB7XG4gIE9iamVjdC5rZXlzKG9iamVjdFRvTWVyZ2UpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmIChtYWluT2JqZWN0W2tleV0gPT09IHVuZGVmaW5lZCkgbWFpbk9iamVjdFtrZXldID0gb2JqZWN0VG9NZXJnZVtrZXldO1xuICB9KTtcbiAgcmV0dXJuIG1haW5PYmplY3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJhaW50c0Zvck9wdGlvbnMob3B0aW9uczogQ3JlYXRlTG9jYWxUcmFja3NPcHRpb25zKTogTWVkaWFTdHJlYW1Db25zdHJhaW50cyB7XG4gIGNvbnN0IGNvbnN0cmFpbnRzOiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzID0ge307XG5cbiAgaWYgKG9wdGlvbnMudmlkZW8pIHtcbiAgICAvLyBkZWZhdWx0IHZpZGVvIG9wdGlvbnNcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudmlkZW8gPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCB2aWRlb09wdGlvbnM6IE1lZGlhVHJhY2tDb25zdHJhaW50cyA9IHt9O1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdmlkZW9PcHRpb25zIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgICAgY29uc3Qgc291cmNlID0gb3B0aW9ucy52aWRlbyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgY2FzZSAncmVzb2x1dGlvbic6XG4gICAgICAgICAgICAvLyBmbGF0dGVuIFZpZGVvUmVzb2x1dGlvbiBmaWVsZHNcbiAgICAgICAgICAgIG1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nKHRhcmdldCwgc291cmNlLnJlc29sdXRpb24gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3RyYWludHMudmlkZW8gPSB2aWRlb09wdGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gb3B0aW9ucy52aWRlbztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3RyYWludHMudmlkZW8gPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmF1ZGlvKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmF1ZGlvID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3RyYWludHMuYXVkaW8gPSBvcHRpb25zLmF1ZGlvO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJhaW50cy5hdWRpbyA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNvbnN0cmFpbnRzO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgc2lsZW5jZSBvbiBhIGdpdmVuIFtbVHJhY2tdXSBpbnN0YW5jZS5cbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhY2sgc2VlbXMgdG8gYmUgZW50aXJlbHkgc2lsZW50LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGV0ZWN0U2lsZW5jZSh0cmFjazogQXVkaW9UcmFjaywgdGltZU9mZnNldCA9IDIwMCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCBjdHggPSBnZXROZXdBdWRpb0NvbnRleHQoKTtcbiAgaWYgKGN0eCkge1xuICAgIGNvbnN0IGFuYWx5c2VyID0gY3R4LmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgYW5hbHlzZXIuZmZ0U2l6ZSA9IDIwNDg7XG5cbiAgICBjb25zdCBidWZmZXJMZW5ndGggPSBhbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudDtcbiAgICBjb25zdCBkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJMZW5ndGgpO1xuICAgIGNvbnN0IHNvdXJjZSA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShuZXcgTWVkaWFTdHJlYW0oW3RyYWNrLm1lZGlhU3RyZWFtVHJhY2tdKSk7XG5cbiAgICBzb3VyY2UuY29ubmVjdChhbmFseXNlcik7XG4gICAgYXdhaXQgc2xlZXAodGltZU9mZnNldCk7XG4gICAgYW5hbHlzZXIuZ2V0Qnl0ZVRpbWVEb21haW5EYXRhKGRhdGFBcnJheSk7XG4gICAgY29uc3Qgc29tZU5vaXNlID0gZGF0YUFycmF5LnNvbWUoKHNhbXBsZSkgPT4gc2FtcGxlICE9PSAxMjggJiYgc2FtcGxlICE9PSAwKTtcbiAgICBjdHguY2xvc2UoKTtcbiAgICByZXR1cm4gIXNvbWVOb2lzZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXdBdWRpb0NvbnRleHQoKTogQXVkaW9Db250ZXh0IHwgdm9pZCB7XG4gIGNvbnN0IEF1ZGlvQ29udGV4dCA9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpO1xuICBpZiAoQXVkaW9Db250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBBdWRpb0NvbnRleHQoeyBsYXRlbmN5SGludDogJ2ludGVyYWN0aXZlJyB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24ga2luZFRvU291cmNlKGtpbmQ6IE1lZGlhRGV2aWNlS2luZCkge1xuICBpZiAoa2luZCA9PT0gJ2F1ZGlvaW5wdXQnKSB7XG4gICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xuICB9IGVsc2UgaWYgKGtpbmQgPT09ICd2aWRlb2lucHV0Jykge1xuICAgIHJldHVybiBUcmFjay5Tb3VyY2UuQ2FtZXJhO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBUcmFjay5Tb3VyY2UuVW5rbm93bjtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gc291cmNlVG9LaW5kKHNvdXJjZTogVHJhY2suU291cmNlKTogTWVkaWFEZXZpY2VLaW5kIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUpIHtcbiAgICByZXR1cm4gJ2F1ZGlvaW5wdXQnO1xuICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSkge1xuICAgIHJldHVybiAndmlkZW9pbnB1dCc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyhcbiAgb3B0aW9uczogU2NyZWVuU2hhcmVDYXB0dXJlT3B0aW9ucyxcbik6IERpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMge1xuICBsZXQgdmlkZW9Db25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzIHwgYm9vbGVhbiA9IG9wdGlvbnMudmlkZW8gPz8gdHJ1ZTtcbiAgLy8gdHJlYXQgMCBhcyB1bmNhcHBlZFxuICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uICYmIG9wdGlvbnMucmVzb2x1dGlvbi53aWR0aCA+IDAgJiYgb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodCA+IDApIHtcbiAgICB2aWRlb0NvbnN0cmFpbnRzID0gdHlwZW9mIHZpZGVvQ29uc3RyYWludHMgPT09ICdib29sZWFuJyA/IHt9IDogdmlkZW9Db25zdHJhaW50cztcbiAgICBpZiAoaXNTYWZhcmkoKSkge1xuICAgICAgdmlkZW9Db25zdHJhaW50cyA9IHtcbiAgICAgICAgLi4udmlkZW9Db25zdHJhaW50cyxcbiAgICAgICAgd2lkdGg6IHsgbWF4OiBvcHRpb25zLnJlc29sdXRpb24ud2lkdGggfSxcbiAgICAgICAgaGVpZ2h0OiB7IG1heDogb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodCB9LFxuICAgICAgICBmcmFtZVJhdGU6IG9wdGlvbnMucmVzb2x1dGlvbi5mcmFtZVJhdGUsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlb0NvbnN0cmFpbnRzID0ge1xuICAgICAgICAuLi52aWRlb0NvbnN0cmFpbnRzLFxuICAgICAgICB3aWR0aDogeyBpZGVhbDogb3B0aW9ucy5yZXNvbHV0aW9uLndpZHRoIH0sXG4gICAgICAgIGhlaWdodDogeyBpZGVhbDogb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodCB9LFxuICAgICAgICBmcmFtZVJhdGU6IG9wdGlvbnMucmVzb2x1dGlvbi5mcmFtZVJhdGUsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYXVkaW86IG9wdGlvbnMuYXVkaW8gPz8gZmFsc2UsXG4gICAgdmlkZW86IHZpZGVvQ29uc3RyYWludHMsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzdXBwb3J0IGZvciBleHBlcmltZW50YWwgZGlzcGxheSBtZWRpYSBmZWF0dXJlc1xuICAgIGNvbnRyb2xsZXI6IG9wdGlvbnMuY29udHJvbGxlcixcbiAgICBzZWxmQnJvd3NlclN1cmZhY2U6IG9wdGlvbnMuc2VsZkJyb3dzZXJTdXJmYWNlLFxuICAgIHN1cmZhY2VTd2l0Y2hpbmc6IG9wdGlvbnMuc3VyZmFjZVN3aXRjaGluZyxcbiAgICBzeXN0ZW1BdWRpbzogb3B0aW9ucy5zeXN0ZW1BdWRpbyxcbiAgICBwcmVmZXJDdXJyZW50VGFiOiBvcHRpb25zLnByZWZlckN1cnJlbnRUYWIsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyhtaW1lVHlwZTogc3RyaW5nKSB7XG4gIGNvbnN0IGNvZGVjID0gbWltZVR5cGUuc3BsaXQoJy8nKVsxXS50b0xvd2VyQ2FzZSgpIGFzIFZpZGVvQ29kZWM7XG4gIGlmICghdmlkZW9Db2RlY3MuaW5jbHVkZXMoY29kZWMpKSB7XG4gICAgdGhyb3cgRXJyb3IoYFZpZGVvIGNvZGVjIG5vdCBzdXBwb3J0ZWQ6ICR7Y29kZWN9YCk7XG4gIH1cbiAgcmV0dXJuIGNvZGVjO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhY2tQdWJsaWNhdGlvbkluZm88VCBleHRlbmRzIFRyYWNrUHVibGljYXRpb24+KFxuICB0cmFja3M6IFRbXSxcbik6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2VbXSB7XG4gIGNvbnN0IGluZm9zOiBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlW10gPSBbXTtcbiAgdHJhY2tzLmZvckVhY2goKHRyYWNrOiBUcmFja1B1YmxpY2F0aW9uKSA9PiB7XG4gICAgaWYgKHRyYWNrLnRyYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluZm9zLnB1c2goXG4gICAgICAgIG5ldyBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlKHtcbiAgICAgICAgICBjaWQ6IHRyYWNrLnRyYWNrLm1lZGlhU3RyZWFtSUQsXG4gICAgICAgICAgdHJhY2s6IHRyYWNrLnRyYWNrSW5mbyxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbmZvcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2s6IFRyYWNrIHwgVHJhY2tQdWJsaWNhdGlvbik6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgaWYgKHRyYWNrIGluc3RhbmNlb2YgVHJhY2spIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhY2tJRDogdHJhY2suc2lkLFxuICAgICAgc291cmNlOiB0cmFjay5zb3VyY2UsXG4gICAgICBtdXRlZDogdHJhY2suaXNNdXRlZCxcbiAgICAgIGVuYWJsZWQ6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCxcbiAgICAgIGtpbmQ6IHRyYWNrLmtpbmQsXG4gICAgICBzdHJlYW1JRDogdHJhY2subWVkaWFTdHJlYW1JRCxcbiAgICAgIHN0cmVhbVRyYWNrSUQ6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhY2tJRDogdHJhY2sudHJhY2tTaWQsXG4gICAgICBlbmFibGVkOiB0cmFjay5pc0VuYWJsZWQsXG4gICAgICBtdXRlZDogdHJhY2suaXNNdXRlZCxcbiAgICAgIHRyYWNrSW5mbzoge1xuICAgICAgICBtaW1lVHlwZTogdHJhY2subWltZVR5cGUsXG4gICAgICAgIG5hbWU6IHRyYWNrLnRyYWNrTmFtZSxcbiAgICAgICAgZW5jcnlwdGVkOiB0cmFjay5pc0VuY3J5cHRlZCxcbiAgICAgICAga2luZDogdHJhY2sua2luZCxcbiAgICAgICAgc291cmNlOiB0cmFjay5zb3VyY2UsXG4gICAgICAgIC4uLih0cmFjay50cmFjayA/IGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2sudHJhY2spIDoge30pLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c1N5bmNocm9uaXphdGlvblNvdXJjZXMoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2YgUlRDUnRwUmVjZWl2ZXIgIT09ICd1bmRlZmluZWQnICYmICdnZXRTeW5jaHJvbml6YXRpb25Tb3VyY2VzJyBpbiBSVENSdHBSZWNlaXZlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZBdHRyaWJ1dGVzKFxuICBvbGRWYWx1ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCB1bmRlZmluZWQsXG4gIG5ld1ZhbHVlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHVuZGVmaW5lZCxcbikge1xuICBpZiAob2xkVmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICBvbGRWYWx1ZXMgPSB7fTtcbiAgfVxuICBpZiAobmV3VmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICBuZXdWYWx1ZXMgPSB7fTtcbiAgfVxuICBjb25zdCBhbGxLZXlzID0gWy4uLk9iamVjdC5rZXlzKG5ld1ZhbHVlcyksIC4uLk9iamVjdC5rZXlzKG9sZFZhbHVlcyldO1xuICBjb25zdCBkaWZmOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgYWxsS2V5cykge1xuICAgIGlmIChvbGRWYWx1ZXNba2V5XSAhPT0gbmV3VmFsdWVzW2tleV0pIHtcbiAgICAgIGRpZmZba2V5XSA9IG5ld1ZhbHVlc1trZXldID8/ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaWZmO1xufVxuIiwiaW1wb3J0IHtcbiAgQ2hhdE1lc3NhZ2UgYXMgQ2hhdE1lc3NhZ2VNb2RlbCxcbiAgQ2xpZW50SW5mbyxcbiAgQ2xpZW50SW5mb19TREssXG4gIFRyYW5zY3JpcHRpb24gYXMgVHJhbnNjcmlwdGlvbk1vZGVsLFxufSBmcm9tICdAbGl2ZWtpdC9wcm90b2NvbCc7XG5pbXBvcnQgeyBnZXRCcm93c2VyIH0gZnJvbSAnLi4vdXRpbHMvYnJvd3NlclBhcnNlcic7XG5pbXBvcnQgeyBwcm90b2NvbFZlcnNpb24sIHZlcnNpb24gfSBmcm9tICcuLi92ZXJzaW9uJztcbmltcG9ydCBDcml0aWNhbFRpbWVycyBmcm9tICcuL3RpbWVycyc7XG5pbXBvcnQgdHlwZSBMb2NhbEF1ZGlvVHJhY2sgZnJvbSAnLi90cmFjay9Mb2NhbEF1ZGlvVHJhY2snO1xuaW1wb3J0IHR5cGUgUmVtb3RlQXVkaW9UcmFjayBmcm9tICcuL3RyYWNrL1JlbW90ZUF1ZGlvVHJhY2snO1xuaW1wb3J0IHsgdHlwZSBWaWRlb0NvZGVjLCB2aWRlb0NvZGVjcyB9IGZyb20gJy4vdHJhY2svb3B0aW9ucyc7XG5pbXBvcnQgeyBnZXROZXdBdWRpb0NvbnRleHQgfSBmcm9tICcuL3RyYWNrL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgQ2hhdE1lc3NhZ2UsIExpdmVLaXRSZWFjdE5hdGl2ZUluZm8sIFRyYW5zY3JpcHRpb25TZWdtZW50IH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IHNlcGFyYXRvciA9ICd8JztcbmV4cG9ydCBjb25zdCBkZEV4dGVuc2lvblVSSSA9XG4gICdodHRwczovL2FvbWVkaWFjb2RlYy5naXRodWIuaW8vYXYxLXJ0cC1zcGVjLyNkZXBlbmRlbmN5LWRlc2NyaXB0b3ItcnRwLWhlYWRlci1leHRlbnNpb24nO1xuXG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrU3RyZWFtSWQocGFja2VkOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHBhcnRzID0gcGFja2VkLnNwbGl0KHNlcGFyYXRvcik7XG4gIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIFtwYXJ0c1swXSwgcGFja2VkLnN1YnN0cihwYXJ0c1swXS5sZW5ndGggKyAxKV07XG4gIH1cbiAgcmV0dXJuIFtwYWNrZWQsICcnXTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNsZWVwKGR1cmF0aW9uOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKSk7XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c1RyYW5zY2VpdmVyKCkge1xuICByZXR1cm4gJ2FkZFRyYW5zY2VpdmVyJyBpbiBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c0FkZFRyYWNrKCkge1xuICByZXR1cm4gJ2FkZFRyYWNrJyBpbiBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c0FkYXB0aXZlU3RyZWFtKCkge1xuICByZXR1cm4gdHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyICE9PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c0R5bmFjYXN0KCkge1xuICByZXR1cm4gc3VwcG9ydHNUcmFuc2NlaXZlcigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNBVjEoKTogYm9vbGVhbiB7XG4gIGlmICghKCdnZXRDYXBhYmlsaXRpZXMnIGluIFJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICAvLyBTYWZhcmkgMTcgb24gaVBob25lMTQgcmVwb3J0cyBBVjEgY2FwYWJpbGl0eSwgYnV0IGRvZXMgbm90IGFjdHVhbGx5IHN1cHBvcnQgaXRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgY2FwYWJpbGl0aWVzID0gUlRDUnRwU2VuZGVyLmdldENhcGFiaWxpdGllcygndmlkZW8nKTtcbiAgbGV0IGhhc0FWMSA9IGZhbHNlO1xuICBpZiAoY2FwYWJpbGl0aWVzKSB7XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBjYXBhYmlsaXRpZXMuY29kZWNzKSB7XG4gICAgICBpZiAoY29kZWMubWltZVR5cGUgPT09ICd2aWRlby9BVjEnKSB7XG4gICAgICAgIGhhc0FWMSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzQVYxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNWUDkoKTogYm9vbGVhbiB7XG4gIGlmICghKCdnZXRDYXBhYmlsaXRpZXMnIGluIFJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRmlyZUZveCgpKSB7XG4gICAgLy8gdGVjaG5pY2FsbHkgc3BlYWtpbmcgRmlyZUZveCBzdXBwb3J0cyBWUDksIGJ1dCBTVkMgcHVibGlzaGluZyBpcyBicm9rZW5cbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNjMzODc2XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgICBpZiAoYnJvd3Nlcj8udmVyc2lvbiAmJiBjb21wYXJlVmVyc2lvbnMoYnJvd3Nlci52ZXJzaW9uLCAnMTYnKSA8IDApIHtcbiAgICAgIC8vIFNhZmFyaSAxNiBhbmQgYmVsb3cgZG9lcyBub3Qgc3VwcG9ydCBWUDlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY2FwYWJpbGl0aWVzID0gUlRDUnRwU2VuZGVyLmdldENhcGFiaWxpdGllcygndmlkZW8nKTtcbiAgbGV0IGhhc1ZQOSA9IGZhbHNlO1xuICBpZiAoY2FwYWJpbGl0aWVzKSB7XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBjYXBhYmlsaXRpZXMuY29kZWNzKSB7XG4gICAgICBpZiAoY29kZWMubWltZVR5cGUgPT09ICd2aWRlby9WUDknKSB7XG4gICAgICAgIGhhc1ZQOSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzVlA5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTVkNDb2RlYyhjb2RlYz86IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gY29kZWMgPT09ICdhdjEnIHx8IGNvZGVjID09PSAndnA5Jztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRzU2V0U2lua0lkKGVsbT86IEhUTUxNZWRpYUVsZW1lbnQpOiBib29sZWFuIHtcbiAgaWYgKCFkb2N1bWVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWVsbSkge1xuICAgIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XG4gIH1cbiAgcmV0dXJuICdzZXRTaW5rSWQnIGluIGVsbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQnJvd3NlclN1cHBvcnRlZCgpIHtcbiAgaWYgKHR5cGVvZiBSVENQZWVyQ29ubmVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRzVHJhbnNjZWl2ZXIoKSB8fCBzdXBwb3J0c0FkZFRyYWNrKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpcmVGb3goKTogYm9vbGVhbiB7XG4gIHJldHVybiBnZXRCcm93c2VyKCk/Lm5hbWUgPT09ICdGaXJlZm94Jztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2hyb21pdW1CYXNlZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIGdldEJyb3dzZXIoKT8ubmFtZSA9PT0gJ0Nocm9tZSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NhZmFyaSgpOiBib29sZWFuIHtcbiAgcmV0dXJuIGdldEJyb3dzZXIoKT8ubmFtZSA9PT0gJ1NhZmFyaSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NhZmFyaTE3KCk6IGJvb2xlYW4ge1xuICBjb25zdCBiID0gZ2V0QnJvd3NlcigpO1xuICByZXR1cm4gYj8ubmFtZSA9PT0gJ1NhZmFyaScgJiYgYi52ZXJzaW9uLnN0YXJ0c1dpdGgoJzE3LicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNNb2JpbGUoKTogYm9vbGVhbiB7XG4gIGlmICghaXNXZWIoKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiAoXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgdXNlckFnZW50RGF0YWAgaXMgbm90IHlldCBwYXJ0IG9mIHR5cGVzY3JpcHRcbiAgICBuYXZpZ2F0b3IudXNlckFnZW50RGF0YT8ubW9iaWxlID8/XG4gICAgL1RhYmxldHxpUGFkfE1vYmlsZXxBbmRyb2lkfEJsYWNrQmVycnkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRTJFRVNpbXVsY2FzdFN1cHBvcnRlZCgpIHtcbiAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgY29uc3Qgc3VwcG9ydGVkU2FmYXJpVmVyc2lvbiA9ICcxNy4yJzsgLy8gc2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yNTc4MDNcbiAgaWYgKGJyb3dzZXIpIHtcbiAgICBpZiAoYnJvd3Nlci5uYW1lICE9PSAnU2FmYXJpJyAmJiBicm93c2VyLm9zICE9PSAnaU9TJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGJyb3dzZXIub3MgPT09ICdpT1MnICYmXG4gICAgICBicm93c2VyLm9zVmVyc2lvbiAmJlxuICAgICAgY29tcGFyZVZlcnNpb25zKHN1cHBvcnRlZFNhZmFyaVZlcnNpb24sIGJyb3dzZXIub3NWZXJzaW9uKSA+PSAwXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYnJvd3Nlci5uYW1lID09PSAnU2FmYXJpJyAmJlxuICAgICAgY29tcGFyZVZlcnNpb25zKHN1cHBvcnRlZFNhZmFyaVZlcnNpb24sIGJyb3dzZXIudmVyc2lvbikgPj0gMFxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzV2ViKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKTogYm9vbGVhbiB7XG4gIC8vIG5hdmlnYXRvci5wcm9kdWN0IGlzIGRlcHJlY2F0ZWQgb24gYnJvd3NlcnMsIGJ1dCB3aWxsIGJlIHNldCBhcHByb3ByaWF0ZWx5IGZvciByZWFjdC1uYXRpdmUuXG4gIHJldHVybiBuYXZpZ2F0b3IucHJvZHVjdCA9PSAnUmVhY3ROYXRpdmUnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDbG91ZChzZXJ2ZXJVcmw6IFVSTCkge1xuICByZXR1cm4gKFxuICAgIHNlcnZlclVybC5ob3N0bmFtZS5lbmRzV2l0aCgnLmxpdmVraXQuY2xvdWQnKSB8fCBzZXJ2ZXJVcmwuaG9zdG5hbWUuZW5kc1dpdGgoJy5saXZla2l0LnJ1bicpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldExLUmVhY3ROYXRpdmVJbmZvKCk6IExpdmVLaXRSZWFjdE5hdGl2ZUluZm8gfCB1bmRlZmluZWQge1xuICAvLyBnbG9iYWwgZGVmaW5lZCBvbmx5IGZvciBSZWFjdE5hdGl2ZS5cbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAoZ2xvYmFsICYmIGdsb2JhbC5MaXZlS2l0UmVhY3ROYXRpdmVHbG9iYWwpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIGdsb2JhbC5MaXZlS2l0UmVhY3ROYXRpdmVHbG9iYWwgYXMgTGl2ZUtpdFJlYWN0TmF0aXZlSW5mbztcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWFjdE5hdGl2ZU9zKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmICghaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxldCBpbmZvID0gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKTtcbiAgaWYgKGluZm8pIHtcbiAgICByZXR1cm4gaW5mby5wbGF0Zm9ybTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZXZpY2VQaXhlbFJhdGlvKCk6IG51bWJlciB7XG4gIGlmIChpc1dlYigpKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICB9XG5cbiAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgIGxldCBpbmZvID0gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKTtcbiAgICBpZiAoaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9ucyh2MTogc3RyaW5nLCB2Mjogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgcGFydHMxID0gdjEuc3BsaXQoJy4nKTtcbiAgY29uc3QgcGFydHMyID0gdjIuc3BsaXQoJy4nKTtcbiAgY29uc3QgayA9IE1hdGgubWluKHBhcnRzMS5sZW5ndGgsIHBhcnRzMi5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGs7ICsraSkge1xuICAgIGNvbnN0IHAxID0gcGFyc2VJbnQocGFydHMxW2ldLCAxMCk7XG4gICAgY29uc3QgcDIgPSBwYXJzZUludChwYXJ0czJbaV0sIDEwKTtcbiAgICBpZiAocDEgPiBwMikgcmV0dXJuIDE7XG4gICAgaWYgKHAxIDwgcDIpIHJldHVybiAtMTtcbiAgICBpZiAoaSA9PT0gayAtIDEgJiYgcDEgPT09IHAyKSByZXR1cm4gMDtcbiAgfVxuICBpZiAodjEgPT09ICcnICYmIHYyICE9PSAnJykge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmICh2MiA9PT0gJycpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gcGFydHMxLmxlbmd0aCA9PSBwYXJ0czIubGVuZ3RoID8gMCA6IHBhcnRzMS5sZW5ndGggPCBwYXJ0czIubGVuZ3RoID8gLTEgOiAxO1xufVxuXG5mdW5jdGlvbiByb0Rpc3BhdGNoQ2FsbGJhY2soZW50cmllczogUmVzaXplT2JzZXJ2ZXJFbnRyeVtdKSB7XG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgIChlbnRyeS50YXJnZXQgYXMgT2JzZXJ2YWJsZU1lZGlhRWxlbWVudCkuaGFuZGxlUmVzaXplKGVudHJ5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpb0Rpc3BhdGNoQ2FsbGJhY2soZW50cmllczogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeVtdKSB7XG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgIChlbnRyeS50YXJnZXQgYXMgT2JzZXJ2YWJsZU1lZGlhRWxlbWVudCkuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQoZW50cnkpO1xuICB9XG59XG5cbmxldCByZXNpemVPYnNlcnZlcjogUmVzaXplT2JzZXJ2ZXIgfCBudWxsID0gbnVsbDtcbmV4cG9ydCBjb25zdCBnZXRSZXNpemVPYnNlcnZlciA9ICgpID0+IHtcbiAgaWYgKCFyZXNpemVPYnNlcnZlcikgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIocm9EaXNwYXRjaENhbGxiYWNrKTtcbiAgcmV0dXJuIHJlc2l6ZU9ic2VydmVyO1xufTtcblxubGV0IGludGVyc2VjdGlvbk9ic2VydmVyOiBJbnRlcnNlY3Rpb25PYnNlcnZlciB8IG51bGwgPSBudWxsO1xuZXhwb3J0IGNvbnN0IGdldEludGVyc2VjdGlvbk9ic2VydmVyID0gKCkgPT4ge1xuICBpZiAoIWludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaW9EaXNwYXRjaENhbGxiYWNrLCB7XG4gICAgICByb290OiBudWxsLFxuICAgICAgcm9vdE1hcmdpbjogJzBweCcsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGludGVyc2VjdGlvbk9ic2VydmVyO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBPYnNlcnZhYmxlTWVkaWFFbGVtZW50IGV4dGVuZHMgSFRNTE1lZGlhRWxlbWVudCB7XG4gIGhhbmRsZVJlc2l6ZTogKGVudHJ5OiBSZXNpemVPYnNlcnZlckVudHJ5KSA9PiB2b2lkO1xuICBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZDogKGVudHJ5OiBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5KSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpZW50SW5mbygpOiBDbGllbnRJbmZvIHtcbiAgY29uc3QgaW5mbyA9IG5ldyBDbGllbnRJbmZvKHtcbiAgICBzZGs6IENsaWVudEluZm9fU0RLLkpTLFxuICAgIHByb3RvY29sOiBwcm90b2NvbFZlcnNpb24sXG4gICAgdmVyc2lvbixcbiAgfSk7XG5cbiAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgIGluZm8ub3MgPSBnZXRSZWFjdE5hdGl2ZU9zKCkgPz8gJyc7XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbmxldCBlbXB0eVZpZGVvU3RyZWFtVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2sgfCB1bmRlZmluZWQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbXB0eVZpZGVvU3RyZWFtVHJhY2soKSB7XG4gIGlmICghZW1wdHlWaWRlb1N0cmVhbVRyYWNrKSB7XG4gICAgZW1wdHlWaWRlb1N0cmVhbVRyYWNrID0gY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKCk7XG4gIH1cbiAgcmV0dXJuIGVtcHR5VmlkZW9TdHJlYW1UcmFjay5jbG9uZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKFxuICB3aWR0aDogbnVtYmVyID0gMTYsXG4gIGhlaWdodDogbnVtYmVyID0gMTYsXG4gIGVuYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZSxcbiAgcGFpbnRDb250ZW50OiBib29sZWFuID0gZmFsc2UsXG4pIHtcbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIC8vIHRoZSBjYW52YXMgc2l6ZSBpcyBzZXQgdG8gMTYgYnkgZGVmYXVsdCwgYmVjYXVzZSBlbGVjdHJvbiBhcHBzIHNlZW0gdG8gZmFpbCB3aXRoIHNtYWxsZXIgdmFsdWVzXG4gIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY3R4Py5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBpZiAocGFpbnRDb250ZW50ICYmIGN0eCkge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgNTAsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdncmV5JztcbiAgICBjdHguZmlsbCgpO1xuICB9XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3QgZHVtbXlTdHJlYW0gPSBjYW52YXMuY2FwdHVyZVN0cmVhbSgpO1xuICBjb25zdCBbZHVtbXlUcmFja10gPSBkdW1teVN0cmVhbS5nZXRUcmFja3MoKTtcbiAgaWYgKCFkdW1teVRyYWNrKSB7XG4gICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgZW1wdHkgbWVkaWEgc3RyZWFtIHZpZGVvIHRyYWNrJyk7XG4gIH1cbiAgZHVtbXlUcmFjay5lbmFibGVkID0gZW5hYmxlZDtcblxuICByZXR1cm4gZHVtbXlUcmFjaztcbn1cblxubGV0IGVtcHR5QXVkaW9TdHJlYW1UcmFjazogTWVkaWFTdHJlYW1UcmFjayB8IHVuZGVmaW5lZDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjaygpIHtcbiAgaWYgKCFlbXB0eUF1ZGlvU3RyZWFtVHJhY2spIHtcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9ibG9nLm1vemlsbGEub3JnL3dlYnJ0Yy93YXJtLXVwLXdpdGgtcmVwbGFjZXRyYWNrL1xuICAgIGNvbnN0IGN0eCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAgICBjb25zdCBvc2NpbGxhdG9yID0gY3R4LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICBjb25zdCBnYWluID0gY3R4LmNyZWF0ZUdhaW4oKTtcbiAgICBnYWluLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgMCk7XG4gICAgY29uc3QgZHN0ID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24oKTtcbiAgICBvc2NpbGxhdG9yLmNvbm5lY3QoZ2Fpbik7XG4gICAgZ2Fpbi5jb25uZWN0KGRzdCk7XG4gICAgb3NjaWxsYXRvci5zdGFydCgpO1xuICAgIFtlbXB0eUF1ZGlvU3RyZWFtVHJhY2tdID0gZHN0LnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICAgIGlmICghZW1wdHlBdWRpb1N0cmVhbVRyYWNrKSB7XG4gICAgICB0aHJvdyBFcnJvcignQ291bGQgbm90IGdldCBlbXB0eSBtZWRpYSBzdHJlYW0gYXVkaW8gdHJhY2snKTtcbiAgICB9XG4gICAgZW1wdHlBdWRpb1N0cmVhbVRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gZW1wdHlBdWRpb1N0cmVhbVRyYWNrLmNsb25lKCk7XG59XG5cbmV4cG9ydCBjbGFzcyBGdXR1cmU8VD4ge1xuICBwcm9taXNlOiBQcm9taXNlPFQ+O1xuXG4gIHJlc29sdmU/OiAoYXJnOiBUKSA9PiB2b2lkO1xuXG4gIHJlamVjdD86IChlOiBhbnkpID0+IHZvaWQ7XG5cbiAgb25GaW5hbGx5PzogKCkgPT4gdm9pZDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBmdXR1cmVCYXNlPzogKHJlc29sdmU6IChhcmc6IFQpID0+IHZvaWQsIHJlamVjdDogKGU6IGFueSkgPT4gdm9pZCkgPT4gdm9pZCxcbiAgICBvbkZpbmFsbHk/OiAoKSA9PiB2b2lkLFxuICApIHtcbiAgICB0aGlzLm9uRmluYWxseSA9IG9uRmluYWxseTtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZTxUPihhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICBpZiAoZnV0dXJlQmFzZSkge1xuICAgICAgICBhd2FpdCBmdXR1cmVCYXNlKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSkuZmluYWxseSgoKSA9PiB0aGlzLm9uRmluYWxseT8uKCkpO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIEF1ZGlvQW5hbHlzZXJPcHRpb25zID0ge1xuICAvKipcbiAgICogSWYgc2V0IHRvIHRydWUsIHRoZSBhbmFseXNlciB3aWxsIHVzZSBhIGNsb25lZCB2ZXJzaW9uIG9mIHRoZSB1bmRlcmx5aW5nIG1lZGlhc3RyZWFtdHJhY2ssIHdoaWNoIHdvbid0IGJlIGltcGFjdGVkIGJ5IG11dGluZyB0aGUgdHJhY2suXG4gICAqIFVzZWZ1bCBmb3IgbG9jYWwgdHJhY2tzIHdoZW4gaW1wbGVtZW50aW5nIHRoaW5ncyBsaWtlIFwic2VlbXMgbGlrZSB5b3UncmUgbXV0ZWQsIGJ1dCB0cnlpbmcgdG8gc3BlYWtcIi5cbiAgICogRGVmYXVsdHMgdG8gZmFsc2VcbiAgICovXG4gIGNsb25lVHJhY2s/OiBib29sZWFuO1xuICAvKipcbiAgICogc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmFseXNlck5vZGUvZmZ0U2l6ZVxuICAgKi9cbiAgZmZ0U2l6ZT86IG51bWJlcjtcbiAgLyoqXG4gICAqIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5hbHlzZXJOb2RlL3Ntb290aGluZ1RpbWVDb25zdGFudFxuICAgKi9cbiAgc21vb3RoaW5nVGltZUNvbnN0YW50PzogbnVtYmVyO1xuICAvKipcbiAgICogc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmFseXNlck5vZGUvbWluRGVjaWJlbHNcbiAgICovXG4gIG1pbkRlY2liZWxzPzogbnVtYmVyO1xuICAvKipcbiAgICogc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmFseXNlck5vZGUvbWF4RGVjaWJlbHNcbiAgICovXG4gIG1heERlY2liZWxzPzogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGFuIGFuYWx5c2VyIHdlYiBhdWRpbyBub2RlIHRoYXQgaXMgYXR0YWNoZWQgdG8gdGhlIHByb3ZpZGVkIHRyYWNrLlxuICogQWRkaXRpb25hbGx5IHJldHVybnMgYSBjb252ZW5pZW5jZSBtZXRob2QgYGNhbGN1bGF0ZVZvbHVtZWAgdG8gcGVyZm9ybSBpbnN0YW50IHZvbHVtZSByZWFkaW5ncyBvbiB0aGF0IHRyYWNrLlxuICogQ2FsbCB0aGUgcmV0dXJuZWQgYGNsZWFudXBgIGZ1bmN0aW9uIHRvIGNsb3NlIHRoZSBhdWRpb0NvbnRleHQgdGhhdCBoYXMgYmVlbiBjcmVhdGVkIGZvciB0aGUgaW5zdGFuY2Ugb2YgdGhpcyBoZWxwZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUF1ZGlvQW5hbHlzZXIoXG4gIHRyYWNrOiBMb2NhbEF1ZGlvVHJhY2sgfCBSZW1vdGVBdWRpb1RyYWNrLFxuICBvcHRpb25zPzogQXVkaW9BbmFseXNlck9wdGlvbnMsXG4pIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBjbG9uZVRyYWNrOiBmYWxzZSxcbiAgICBmZnRTaXplOiAyMDQ4LFxuICAgIHNtb290aGluZ1RpbWVDb25zdGFudDogMC44LFxuICAgIG1pbkRlY2liZWxzOiAtMTAwLFxuICAgIG1heERlY2liZWxzOiAtODAsXG4gICAgLi4ub3B0aW9ucyxcbiAgfTtcbiAgY29uc3QgYXVkaW9Db250ZXh0ID0gZ2V0TmV3QXVkaW9Db250ZXh0KCk7XG5cbiAgaWYgKCFhdWRpb0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1ZGlvIENvbnRleHQgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXInKTtcbiAgfVxuICBjb25zdCBzdHJlYW1UcmFjayA9IG9wdHMuY2xvbmVUcmFjayA/IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suY2xvbmUoKSA6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2s7XG4gIGNvbnN0IG1lZGlhU3RyZWFtU291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG5ldyBNZWRpYVN0cmVhbShbc3RyZWFtVHJhY2tdKSk7XG4gIGNvbnN0IGFuYWx5c2VyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG4gIGFuYWx5c2VyLm1pbkRlY2liZWxzID0gb3B0cy5taW5EZWNpYmVscztcbiAgYW5hbHlzZXIubWF4RGVjaWJlbHMgPSBvcHRzLm1heERlY2liZWxzO1xuICBhbmFseXNlci5mZnRTaXplID0gb3B0cy5mZnRTaXplO1xuICBhbmFseXNlci5zbW9vdGhpbmdUaW1lQ29uc3RhbnQgPSBvcHRzLnNtb290aGluZ1RpbWVDb25zdGFudDtcblxuICBtZWRpYVN0cmVhbVNvdXJjZS5jb25uZWN0KGFuYWx5c2VyKTtcbiAgY29uc3QgZGF0YUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBjdXJyZW50IHZvbHVtZSBvZiB0aGUgdHJhY2sgaW4gdGhlIHJhbmdlIGZyb20gMCB0byAxXG4gICAqL1xuICBjb25zdCBjYWxjdWxhdGVWb2x1bWUgPSAoKSA9PiB7XG4gICAgYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoZGF0YUFycmF5KTtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGNvbnN0IGFtcGxpdHVkZSBvZiBkYXRhQXJyYXkpIHtcbiAgICAgIHN1bSArPSBNYXRoLnBvdyhhbXBsaXR1ZGUgLyAyNTUsIDIpO1xuICAgIH1cbiAgICBjb25zdCB2b2x1bWUgPSBNYXRoLnNxcnQoc3VtIC8gZGF0YUFycmF5Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHZvbHVtZTtcbiAgfTtcblxuICBjb25zdCBjbGVhbnVwID0gYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGF1ZGlvQ29udGV4dC5jbG9zZSgpO1xuICAgIGlmIChvcHRzLmNsb25lVHJhY2spIHtcbiAgICAgIHN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHsgY2FsY3VsYXRlVm9sdW1lLCBhbmFseXNlciwgY2xlYW51cCB9O1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgTXV0ZXgge1xuICBwcml2YXRlIF9sb2NraW5nOiBQcm9taXNlPHZvaWQ+O1xuXG4gIHByaXZhdGUgX2xvY2tzOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fbG9ja2luZyA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHRoaXMuX2xvY2tzID0gMDtcbiAgfVxuXG4gIGlzTG9ja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NrcyA+IDA7XG4gIH1cblxuICBsb2NrKCkge1xuICAgIHRoaXMuX2xvY2tzICs9IDE7XG5cbiAgICBsZXQgdW5sb2NrTmV4dDogKCkgPT4gdm9pZDtcblxuICAgIGNvbnN0IHdpbGxMb2NrID0gbmV3IFByb21pc2U8dm9pZD4oXG4gICAgICAocmVzb2x2ZSkgPT5cbiAgICAgICAgKHVubG9ja05leHQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fbG9ja3MgLT0gMTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pLFxuICAgICk7XG5cbiAgICBjb25zdCB3aWxsVW5sb2NrID0gdGhpcy5fbG9ja2luZy50aGVuKCgpID0+IHVubG9ja05leHQpO1xuXG4gICAgdGhpcy5fbG9ja2luZyA9IHRoaXMuX2xvY2tpbmcudGhlbigoKSA9PiB3aWxsTG9jayk7XG5cbiAgICByZXR1cm4gd2lsbFVubG9jaztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWaWRlb0NvZGVjKG1heWJlQ29kZWM6IHN0cmluZyk6IG1heWJlQ29kZWMgaXMgVmlkZW9Db2RlYyB7XG4gIHJldHVybiB2aWRlb0NvZGVjcy5pbmNsdWRlcyhtYXliZUNvZGVjIGFzIFZpZGVvQ29kZWMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwQ29uc3RyYWludChjb25zdHJhaW50OiBDb25zdHJhaW5ET01TdHJpbmcpOiBzdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gdW53cmFwQ29uc3RyYWludChjb25zdHJhaW50OiBDb25zdHJhaW5VTG9uZyk6IG51bWJlcjtcbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBDb25zdHJhaW50KGNvbnN0cmFpbnQ6IENvbnN0cmFpbkRPTVN0cmluZyB8IENvbnN0cmFpblVMb25nKTogc3RyaW5nIHwgbnVtYmVyIHtcbiAgaWYgKHR5cGVvZiBjb25zdHJhaW50ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY29uc3RyYWludCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gY29uc3RyYWludDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGNvbnN0cmFpbnQpKSB7XG4gICAgcmV0dXJuIGNvbnN0cmFpbnRbMF07XG4gIH1cbiAgaWYgKGNvbnN0cmFpbnQuZXhhY3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25zdHJhaW50LmV4YWN0KSkge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbnQuZXhhY3RbMF07XG4gICAgfVxuICAgIHJldHVybiBjb25zdHJhaW50LmV4YWN0O1xuICB9XG4gIGlmIChjb25zdHJhaW50LmlkZWFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uc3RyYWludC5pZGVhbCkpIHtcbiAgICAgIHJldHVybiBjb25zdHJhaW50LmlkZWFsWzBdO1xuICAgIH1cbiAgICByZXR1cm4gY29uc3RyYWludC5pZGVhbDtcbiAgfVxuICB0aHJvdyBFcnJvcignY291bGQgbm90IHVud3JhcCBjb25zdHJhaW50Jyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1dlYnNvY2tldFVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC9eKGh0dHApLywgJ3dzJyk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvSHR0cFVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aCgnd3MnKSkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvXih3cykvLCAnaHR0cCcpO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0VHJhbnNjcmlwdGlvblNlZ21lbnRzKFxuICB0cmFuc2NyaXB0aW9uOiBUcmFuc2NyaXB0aW9uTW9kZWwsXG4gIGZpcnN0UmVjZWl2ZWRUaW1lc01hcDogTWFwPHN0cmluZywgbnVtYmVyPixcbik6IFRyYW5zY3JpcHRpb25TZWdtZW50W10ge1xuICByZXR1cm4gdHJhbnNjcmlwdGlvbi5zZWdtZW50cy5tYXAoKHsgaWQsIHRleHQsIGxhbmd1YWdlLCBzdGFydFRpbWUsIGVuZFRpbWUsIGZpbmFsIH0pID0+IHtcbiAgICBjb25zdCBmaXJzdFJlY2VpdmVkVGltZSA9IGZpcnN0UmVjZWl2ZWRUaW1lc01hcC5nZXQoaWQpID8/IERhdGUubm93KCk7XG4gICAgY29uc3QgbGFzdFJlY2VpdmVkVGltZSA9IERhdGUubm93KCk7XG4gICAgaWYgKGZpbmFsKSB7XG4gICAgICBmaXJzdFJlY2VpdmVkVGltZXNNYXAuZGVsZXRlKGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlyc3RSZWNlaXZlZFRpbWVzTWFwLnNldChpZCwgZmlyc3RSZWNlaXZlZFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICB0ZXh0LFxuICAgICAgc3RhcnRUaW1lOiBOdW1iZXIucGFyc2VJbnQoc3RhcnRUaW1lLnRvU3RyaW5nKCkpLFxuICAgICAgZW5kVGltZTogTnVtYmVyLnBhcnNlSW50KGVuZFRpbWUudG9TdHJpbmcoKSksXG4gICAgICBmaW5hbCxcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgZmlyc3RSZWNlaXZlZFRpbWUsXG4gICAgICBsYXN0UmVjZWl2ZWRUaW1lLFxuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdENoYXRNZXNzYWdlKG1zZzogQ2hhdE1lc3NhZ2VNb2RlbCk6IENoYXRNZXNzYWdlIHtcbiAgY29uc3QgeyBpZCwgdGltZXN0YW1wLCBtZXNzYWdlLCBlZGl0VGltZXN0YW1wIH0gPSBtc2c7XG4gIHJldHVybiB7XG4gICAgaWQsXG4gICAgdGltZXN0YW1wOiBOdW1iZXIucGFyc2VJbnQodGltZXN0YW1wLnRvU3RyaW5nKCkpLFxuICAgIGVkaXRUaW1lc3RhbXA6IGVkaXRUaW1lc3RhbXAgPyBOdW1iZXIucGFyc2VJbnQoZWRpdFRpbWVzdGFtcC50b1N0cmluZygpKSA6IHVuZGVmaW5lZCxcbiAgICBtZXNzYWdlLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgTXV0ZXggfSBmcm9tICcuLi9yb29tL3V0aWxzJztcblxudHlwZSBRdWV1ZVRhc2s8VD4gPSAoKSA9PiBQcm9taXNlTGlrZTxUPjtcblxuZW51bSBRdWV1ZVRhc2tTdGF0dXMge1xuICAnV0FJVElORycsXG4gICdSVU5OSU5HJyxcbiAgJ0NPTVBMRVRFRCcsXG59XG5cbnR5cGUgUXVldWVUYXNrSW5mbyA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgZW5xdWV1ZWRBdDogbnVtYmVyO1xuICBleGVjdXRlZEF0PzogbnVtYmVyO1xuICBzdGF0dXM6IFF1ZXVlVGFza1N0YXR1cztcbn07XG5cbmV4cG9ydCBjbGFzcyBBc3luY1F1ZXVlIHtcbiAgcHJpdmF0ZSBwZW5kaW5nVGFza3M6IE1hcDxudW1iZXIsIFF1ZXVlVGFza0luZm8+O1xuXG4gIHByaXZhdGUgdGFza011dGV4OiBNdXRleDtcblxuICBwcml2YXRlIG5leHRUYXNrSW5kZXg6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnBlbmRpbmdUYXNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRhc2tNdXRleCA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMubmV4dFRhc2tJbmRleCA9IDA7XG4gIH1cblxuICBhc3luYyBydW48VD4odGFzazogUXVldWVUYXNrPFQ+KSB7XG4gICAgY29uc3QgdGFza0luZm86IFF1ZXVlVGFza0luZm8gPSB7XG4gICAgICBpZDogdGhpcy5uZXh0VGFza0luZGV4KyssXG4gICAgICBlbnF1ZXVlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgc3RhdHVzOiBRdWV1ZVRhc2tTdGF0dXMuV0FJVElORyxcbiAgICB9O1xuICAgIHRoaXMucGVuZGluZ1Rhc2tzLnNldCh0YXNrSW5mby5pZCwgdGFza0luZm8pO1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMudGFza011dGV4LmxvY2soKTtcbiAgICB0cnkge1xuICAgICAgdGFza0luZm8uZXhlY3V0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICB0YXNrSW5mby5zdGF0dXMgPSBRdWV1ZVRhc2tTdGF0dXMuUlVOTklORztcbiAgICAgIHJldHVybiBhd2FpdCB0YXNrKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRhc2tJbmZvLnN0YXR1cyA9IFF1ZXVlVGFza1N0YXR1cy5DT01QTEVURUQ7XG4gICAgICB0aGlzLnBlbmRpbmdUYXNrcy5kZWxldGUodGFza0luZm8uaWQpO1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZmx1c2goKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuKGFzeW5jICgpID0+IHt9KTtcbiAgfVxuXG4gIHNuYXBzaG90KCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucGVuZGluZ1Rhc2tzLnZhbHVlcygpKTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBLZXlQcm92aWRlck9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IEVOQ1JZUFRJT05fQUxHT1JJVEhNID0gJ0FFUy1HQ00nO1xuXG4vLyBIb3cgbWFueSBjb25zZWN1dGl2ZSBmcmFtZXMgY2FuIGZhaWwgZGVjcnlwdGluZyBiZWZvcmUgYSBwYXJ0aWN1bGFyIGtleSBnZXRzIG1hcmtlZCBhcyBpbnZhbGlkXG5leHBvcnQgY29uc3QgREVDUllQVElPTl9GQUlMVVJFX1RPTEVSQU5DRSA9IDEwO1xuXG4vLyBXZSBjb3B5IHRoZSBmaXJzdCBieXRlcyBvZiB0aGUgVlA4IHBheWxvYWQgdW5lbmNyeXB0ZWQuXG4vLyBGb3Iga2V5ZnJhbWVzIHRoaXMgaXMgMTAgYnl0ZXMsIGZvciBub24ta2V5ZnJhbWVzIChkZWx0YSkgMy4gU2VlXG4vLyAgIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2Mzg2I3NlY3Rpb24tOS4xXG4vLyBUaGlzIGFsbG93cyB0aGUgYnJpZGdlIHRvIGNvbnRpbnVlIGRldGVjdGluZyBrZXlmcmFtZXMgKG9ubHkgb25lIGJ5dGUgbmVlZGVkIGluIHRoZSBKVkIpXG4vLyBhbmQgaXMgYWxzbyBhIGJpdCBlYXNpZXIgZm9yIHRoZSBWUDggZGVjb2RlciAoaS5lLiBpdCBnZW5lcmF0ZXMgZnVubnkgZ2FyYmFnZSBwaWN0dXJlc1xuLy8gaW5zdGVhZCBvZiBiZWluZyB1bmFibGUgdG8gZGVjb2RlKS5cbi8vIFRoaXMgaXMgYSBiaXQgZm9yIHNob3cgYW5kIHdlIG1pZ2h0IHdhbnQgdG8gcmVkdWNlIHRvIDEgdW5jb25kaXRpb25hbGx5IGluIHRoZSBmaW5hbCB2ZXJzaW9uLlxuLy9cbi8vIEZvciBhdWRpbyAod2hlcmUgZnJhbWUudHlwZSBpcyBub3Qgc2V0KSB3ZSBkbyBub3QgZW5jcnlwdCB0aGUgb3B1cyBUT0MgYnl0ZTpcbi8vICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3MTYjc2VjdGlvbi0zLjFcbmV4cG9ydCBjb25zdCBVTkVOQ1JZUFRFRF9CWVRFUyA9IHtcbiAga2V5OiAxMCxcbiAgZGVsdGE6IDMsXG4gIGF1ZGlvOiAxLCAvLyBmcmFtZS50eXBlIGlzIG5vdCBzZXQgb24gYXVkaW8sIHNvIHRoaXMgaXMgc2V0IG1hbnVhbGx5XG4gIGVtcHR5OiAwLFxufSBhcyBjb25zdDtcblxuLyogV2UgdXNlIGEgMTIgYnl0ZSBiaXQgSVYuIFRoaXMgaXMgc2lnbmFsbGVkIGluIHBsYWluIHRvZ2V0aGVyIHdpdGggdGhlXG4gcGFja2V0LiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9lbmNyeXB0I3BhcmFtZXRlcnMgKi9cbmV4cG9ydCBjb25zdCBJVl9MRU5HVEggPSAxMjtcblxuLy8gZmxhZyBzZXQgdG8gaW5kaWNhdGUgdGhhdCBlMmVlIGhhcyBiZWVuIHNldHVwIGZvciBzZW5kZXIvcmVjZWl2ZXI7XG5leHBvcnQgY29uc3QgRTJFRV9GTEFHID0gJ2xrX2UyZWUnO1xuXG5leHBvcnQgY29uc3QgU0FMVCA9ICdMS0ZyYW1lRW5jcnlwdGlvbktleSc7XG5cbmV4cG9ydCBjb25zdCBLRVlfUFJPVklERVJfREVGQVVMVFM6IEtleVByb3ZpZGVyT3B0aW9ucyA9IHtcbiAgc2hhcmVkS2V5OiBmYWxzZSxcbiAgcmF0Y2hldFNhbHQ6IFNBTFQsXG4gIHJhdGNoZXRXaW5kb3dTaXplOiA4LFxuICBmYWlsdXJlVG9sZXJhbmNlOiBERUNSWVBUSU9OX0ZBSUxVUkVfVE9MRVJBTkNFLFxuICBrZXlyaW5nU2l6ZTogMTYsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgTUFYX1NJRl9DT1VOVCA9IDEwMDtcbmV4cG9ydCBjb25zdCBNQVhfU0lGX0RVUkFUSU9OID0gMjAwMDtcbiIsImltcG9ydCB7IFJlcXVlc3RSZXNwb25zZV9SZWFzb24gfSBmcm9tICdAbGl2ZWtpdC9wcm90b2NvbCc7XG5cbmV4cG9ydCBjbGFzcyBMaXZla2l0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvZGU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihjb2RlOiBudW1iZXIsIG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlIHx8ICdhbiBlcnJvciBoYXMgb2NjdXJlZCcpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gQ29ubmVjdGlvbkVycm9yUmVhc29uIHtcbiAgTm90QWxsb3dlZCxcbiAgU2VydmVyVW5yZWFjaGFibGUsXG4gIEludGVybmFsRXJyb3IsXG4gIENhbmNlbGxlZCxcbiAgTGVhdmVSZXF1ZXN0LFxufVxuXG5leHBvcnQgY2xhc3MgQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgc3RhdHVzPzogbnVtYmVyO1xuXG4gIHJlYXNvbj86IENvbm5lY3Rpb25FcnJvclJlYXNvbjtcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nLCByZWFzb24/OiBDb25uZWN0aW9uRXJyb3JSZWFzb24sIHN0YXR1cz86IG51bWJlcikge1xuICAgIHN1cGVyKDEsIG1lc3NhZ2UpO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZT86IHN0cmluZykge1xuICAgIHN1cGVyKDIxLCBtZXNzYWdlID8/ICdkZXZpY2UgaXMgdW5zdXBwb3J0ZWQnKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVHJhY2tJbnZhbGlkRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIoMjAsIG1lc3NhZ2UgPz8gJ3RyYWNrIGlzIGludmFsaWQnKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVW5zdXBwb3J0ZWRTZXJ2ZXIgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIoMTAsIG1lc3NhZ2UgPz8gJ3Vuc3VwcG9ydGVkIHNlcnZlcicpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZT86IHN0cmluZykge1xuICAgIHN1cGVyKDEyLCBtZXNzYWdlID8/ICd1bmV4cGVjdGVkIGNvbm5lY3Rpb24gc3RhdGUnKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTmVnb3RpYXRpb25FcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcigxMywgbWVzc2FnZSA/PyAndW5hYmxlIHRvIG5lZ290aWF0ZScpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQdWJsaXNoRGF0YUVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZT86IHN0cmluZykge1xuICAgIHN1cGVyKDEzLCBtZXNzYWdlID8/ICd1bmFibGUgdG8gcHVibGlzaCBkYXRhJyk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgUmVxdWVzdEVycm9yUmVhc29uID1cbiAgfCBFeGNsdWRlPFJlcXVlc3RSZXNwb25zZV9SZWFzb24sIFJlcXVlc3RSZXNwb25zZV9SZWFzb24uT0s+XG4gIHwgJ1RpbWVvdXRFcnJvcic7XG5cbmV4cG9ydCBjbGFzcyBTaWduYWxSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICByZWFzb246IFJlcXVlc3RFcnJvclJlYXNvbjtcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHJlYXNvbjogUmVxdWVzdEVycm9yUmVhc29uKSB7XG4gICAgc3VwZXIoMTUsIG1lc3NhZ2UpO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB9XG59XG5cbmV4cG9ydCBlbnVtIE1lZGlhRGV2aWNlRmFpbHVyZSB7XG4gIC8vIHVzZXIgcmVqZWN0ZWQgcGVybWlzc2lvbnNcbiAgUGVybWlzc2lvbkRlbmllZCA9ICdQZXJtaXNzaW9uRGVuaWVkJyxcbiAgLy8gZGV2aWNlIGlzIG5vdCBhdmFpbGFibGVcbiAgTm90Rm91bmQgPSAnTm90Rm91bmQnLFxuICAvLyBkZXZpY2UgaXMgaW4gdXNlLiBPbiBXaW5kb3dzLCBvbmx5IGEgc2luZ2xlIHRhYiBtYXkgZ2V0IGFjY2VzcyB0byBhIGRldmljZSBhdCBhIHRpbWUuXG4gIERldmljZUluVXNlID0gJ0RldmljZUluVXNlJyxcbiAgT3RoZXIgPSAnT3RoZXInLFxufVxuXG5leHBvcnQgbmFtZXNwYWNlIE1lZGlhRGV2aWNlRmFpbHVyZSB7XG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRGYWlsdXJlKGVycm9yOiBhbnkpOiBNZWRpYURldmljZUZhaWx1cmUgfCB1bmRlZmluZWQge1xuICAgIGlmIChlcnJvciAmJiAnbmFtZScgaW4gZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90Rm91bmRFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ0RldmljZXNOb3RGb3VuZEVycm9yJykge1xuICAgICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLk5vdEZvdW5kO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdQZXJtaXNzaW9uRGVuaWVkRXJyb3InKSB7XG4gICAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuUGVybWlzc2lvbkRlbmllZDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90UmVhZGFibGVFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ1RyYWNrU3RhcnRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5EZXZpY2VJblVzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuT3RoZXI7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBMaXZla2l0RXJyb3IgfSBmcm9tICcuLi9yb29tL2Vycm9ycyc7XG5cbmV4cG9ydCBlbnVtIENyeXB0b3JFcnJvclJlYXNvbiB7XG4gIEludmFsaWRLZXkgPSAwLFxuICBNaXNzaW5nS2V5ID0gMSxcbiAgSW50ZXJuYWxFcnJvciA9IDIsXG59XG5cbmV4cG9ydCBjbGFzcyBDcnlwdG9yRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICByZWFzb246IENyeXB0b3JFcnJvclJlYXNvbjtcblxuICBwYXJ0aWNpcGFudElkZW50aXR5Pzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U/OiBzdHJpbmcsXG4gICAgcmVhc29uOiBDcnlwdG9yRXJyb3JSZWFzb24gPSBDcnlwdG9yRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvcixcbiAgICBwYXJ0aWNpcGFudElkZW50aXR5Pzogc3RyaW5nLFxuICApIHtcbiAgICBzdXBlcig0MCwgbWVzc2FnZSk7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5wYXJ0aWNpcGFudElkZW50aXR5ID0gcGFydGljaXBhbnRJZGVudGl0eTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgUGFydGljaXBhbnQgZnJvbSAnLi4vcm9vbS9wYXJ0aWNpcGFudC9QYXJ0aWNpcGFudCc7XG5pbXBvcnQgdHlwZSB7IENyeXB0b3JFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB0eXBlIHsgS2V5SW5mbyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZW51bSBLZXlQcm92aWRlckV2ZW50IHtcbiAgU2V0S2V5ID0gJ3NldEtleScsXG4gIFJhdGNoZXRSZXF1ZXN0ID0gJ3JhdGNoZXRSZXF1ZXN0JyxcbiAgS2V5UmF0Y2hldGVkID0gJ2tleVJhdGNoZXRlZCcsXG59XG5cbmV4cG9ydCB0eXBlIEtleVByb3ZpZGVyQ2FsbGJhY2tzID0ge1xuICBbS2V5UHJvdmlkZXJFdmVudC5TZXRLZXldOiAoa2V5SW5mbzogS2V5SW5mbykgPT4gdm9pZDtcbiAgW0tleVByb3ZpZGVyRXZlbnQuUmF0Y2hldFJlcXVlc3RdOiAocGFydGljaXBhbnRJZGVudGl0eT86IHN0cmluZywga2V5SW5kZXg/OiBudW1iZXIpID0+IHZvaWQ7XG4gIFtLZXlQcm92aWRlckV2ZW50LktleVJhdGNoZXRlZF06IChtYXRlcmlhbDogQ3J5cHRvS2V5LCBrZXlJbmRleD86IG51bWJlcikgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBlbnVtIEtleUhhbmRsZXJFdmVudCB7XG4gIEtleVJhdGNoZXRlZCA9ICdrZXlSYXRjaGV0ZWQnLFxufVxuXG5leHBvcnQgdHlwZSBQYXJ0aWNpcGFudEtleUhhbmRsZXJDYWxsYmFja3MgPSB7XG4gIFtLZXlIYW5kbGVyRXZlbnQuS2V5UmF0Y2hldGVkXTogKFxuICAgIG1hdGVyaWFsOiBDcnlwdG9LZXksXG4gICAgcGFydGljaXBhbnRJZGVudGl0eTogc3RyaW5nLFxuICAgIGtleUluZGV4PzogbnVtYmVyLFxuICApID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgZW51bSBFbmNyeXB0aW9uRXZlbnQge1xuICBQYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkID0gJ3BhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQnLFxuICBFbmNyeXB0aW9uRXJyb3IgPSAnZW5jcnlwdGlvbkVycm9yJyxcbn1cblxuZXhwb3J0IHR5cGUgRTJFRU1hbmFnZXJDYWxsYmFja3MgPSB7XG4gIFtFbmNyeXB0aW9uRXZlbnQuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZF06IChcbiAgICBlbmFibGVkOiBib29sZWFuLFxuICAgIHBhcnRpY2lwYW50OiBQYXJ0aWNpcGFudCxcbiAgKSA9PiB2b2lkO1xuICBbRW5jcnlwdGlvbkV2ZW50LkVuY3J5cHRpb25FcnJvcl06IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgdHlwZSBDcnlwdG9yQ2FsbGJhY2tzID0ge1xuICBbQ3J5cHRvckV2ZW50LkVycm9yXTogKGVycm9yOiBDcnlwdG9yRXJyb3IpID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgZW51bSBDcnlwdG9yRXZlbnQge1xuICBFcnJvciA9ICdjcnlwdG9yRXJyb3InLFxufVxuIiwiaW1wb3J0IHsgRU5DUllQVElPTl9BTEdPUklUSE0gfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0UyRUVTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiBpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQoKSB8fCBpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2NyaXB0VHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW5zZXJ0YWJsZVN0cmVhbVN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93LlJUQ1J0cFNlbmRlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmNyZWF0ZUVuY29kZWRTdHJlYW1zICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWaWRlb0ZyYW1lKFxuICBmcmFtZTogUlRDRW5jb2RlZEF1ZGlvRnJhbWUgfCBSVENFbmNvZGVkVmlkZW9GcmFtZSxcbik6IGZyYW1lIGlzIFJUQ0VuY29kZWRWaWRlb0ZyYW1lIHtcbiAgcmV0dXJuICd0eXBlJyBpbiBmcmFtZTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGltcG9ydEtleShcbiAga2V5Qnl0ZXM6IFVpbnQ4QXJyYXkgfCBBcnJheUJ1ZmZlcixcbiAgYWxnb3JpdGhtOiBzdHJpbmcgfCB7IG5hbWU6IHN0cmluZyB9ID0geyBuYW1lOiBFTkNSWVBUSU9OX0FMR09SSVRITSB9LFxuICB1c2FnZTogJ2Rlcml2ZScgfCAnZW5jcnlwdCcgPSAnZW5jcnlwdCcsXG4pIHtcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9pbXBvcnRLZXlcbiAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICdyYXcnLFxuICAgIGtleUJ5dGVzLFxuICAgIGFsZ29yaXRobSxcbiAgICBmYWxzZSxcbiAgICB1c2FnZSA9PT0gJ2Rlcml2ZScgPyBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10gOiBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddLFxuICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nKHBhc3N3b3JkOiBzdHJpbmcpIHtcbiAgbGV0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gIGNvbnN0IGtleU1hdGVyaWFsID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gICAgJ3JhdycsXG4gICAgZW5jLmVuY29kZShwYXNzd29yZCksXG4gICAge1xuICAgICAgbmFtZTogJ1BCS0RGMicsXG4gICAgfSxcbiAgICBmYWxzZSxcbiAgICBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10sXG4gICk7XG5cbiAgcmV0dXJuIGtleU1hdGVyaWFsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlS2V5TWF0ZXJpYWxGcm9tQnVmZmVyKGNyeXB0b0J1ZmZlcjogQXJyYXlCdWZmZXIpIHtcbiAgY29uc3Qga2V5TWF0ZXJpYWwgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3JywgY3J5cHRvQnVmZmVyLCAnSEtERicsIGZhbHNlLCBbXG4gICAgJ2Rlcml2ZUJpdHMnLFxuICAgICdkZXJpdmVLZXknLFxuICBdKTtcblxuICByZXR1cm4ga2V5TWF0ZXJpYWw7XG59XG5cbmZ1bmN0aW9uIGdldEFsZ29PcHRpb25zKGFsZ29yaXRobU5hbWU6IHN0cmluZywgc2FsdDogc3RyaW5nKSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGNvbnN0IGVuY29kZWRTYWx0ID0gdGV4dEVuY29kZXIuZW5jb2RlKHNhbHQpO1xuICBzd2l0Y2ggKGFsZ29yaXRobU5hbWUpIHtcbiAgICBjYXNlICdIS0RGJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdIS0RGJyxcbiAgICAgICAgc2FsdDogZW5jb2RlZFNhbHQsXG4gICAgICAgIGhhc2g6ICdTSEEtMjU2JyxcbiAgICAgICAgaW5mbzogbmV3IEFycmF5QnVmZmVyKDEyOCksXG4gICAgICB9O1xuICAgIGNhc2UgJ1BCS0RGMic6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdQQktERjInLFxuICAgICAgICBzYWx0OiBlbmNvZGVkU2FsdCxcbiAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxuICAgICAgICBpdGVyYXRpb25zOiAxMDAwMDAsXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBhbGdvcml0aG0gJHthbGdvcml0aG1OYW1lfSBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWRgKTtcbiAgfVxufVxuXG4vKipcbiAqIERlcml2ZXMgYSBzZXQgb2Yga2V5cyBmcm9tIHRoZSBtYXN0ZXIga2V5LlxuICogU2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1vbWFyYS1zZnJhbWUtMDAjc2VjdGlvbi00LjMuMVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVyaXZlS2V5cyhtYXRlcmlhbDogQ3J5cHRvS2V5LCBzYWx0OiBzdHJpbmcpIHtcbiAgY29uc3QgYWxnb3JpdGhtT3B0aW9ucyA9IGdldEFsZ29PcHRpb25zKG1hdGVyaWFsLmFsZ29yaXRobS5uYW1lLCBzYWx0KTtcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL2Rlcml2ZUtleSNIS0RGXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ia2RmUGFyYW1zXG4gIGNvbnN0IGVuY3J5cHRpb25LZXkgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRlcml2ZUtleShcbiAgICBhbGdvcml0aG1PcHRpb25zLFxuICAgIG1hdGVyaWFsLFxuICAgIHtcbiAgICAgIG5hbWU6IEVOQ1JZUFRJT05fQUxHT1JJVEhNLFxuICAgICAgbGVuZ3RoOiAxMjgsXG4gICAgfSxcbiAgICBmYWxzZSxcbiAgICBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddLFxuICApO1xuXG4gIHJldHVybiB7IG1hdGVyaWFsLCBlbmNyeXB0aW9uS2V5IH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFMkVFS2V5KCk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMzIpKTtcbn1cblxuLyoqXG4gKiBSYXRjaGV0cyBhIGtleS4gU2VlXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtb21hcmEtc2ZyYW1lLTAwI3NlY3Rpb24tNC4zLjUuMVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmF0Y2hldChtYXRlcmlhbDogQ3J5cHRvS2V5LCBzYWx0OiBzdHJpbmcpOiBQcm9taXNlPEFycmF5QnVmZmVyPiB7XG4gIGNvbnN0IGFsZ29yaXRobU9wdGlvbnMgPSBnZXRBbGdvT3B0aW9ucyhtYXRlcmlhbC5hbGdvcml0aG0ubmFtZSwgc2FsdCk7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9kZXJpdmVCaXRzXG4gIHJldHVybiBjcnlwdG8uc3VidGxlLmRlcml2ZUJpdHMoYWxnb3JpdGhtT3B0aW9ucywgbWF0ZXJpYWwsIDI1Nik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZWVkc1Jic3BVbmVzY2FwaW5nKGZyYW1lRGF0YTogVWludDhBcnJheSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lRGF0YS5sZW5ndGggLSAzOyBpKyspIHtcbiAgICBpZiAoZnJhbWVEYXRhW2ldID09IDAgJiYgZnJhbWVEYXRhW2kgKyAxXSA9PSAwICYmIGZyYW1lRGF0YVtpICsgMl0gPT0gMykgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSYnNwKHN0cmVhbTogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBkYXRhT3V0OiBudW1iZXJbXSA9IFtdO1xuICB2YXIgbGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJlYW0ubGVuZ3RoOyApIHtcbiAgICAvLyBCZSBjYXJlZnVsIGFib3V0IG92ZXIvdW5kZXJmbG93IGhlcmUuIGJ5dGVfbGVuZ3RoXyAtIDMgY2FuIHVuZGVyZmxvdywgYW5kXG4gICAgLy8gaSArIDMgY2FuIG92ZXJmbG93LCBidXQgYnl0ZV9sZW5ndGhfIC0gaSBjYW4ndCwgYmVjYXVzZSBpIDwgYnl0ZV9sZW5ndGhfXG4gICAgLy8gYWJvdmUsIGFuZCB0aGF0IGV4cHJlc3Npb24gd2lsbCBwcm9kdWNlIHRoZSBudW1iZXIgb2YgYnl0ZXMgbGVmdCBpblxuICAgIC8vIHRoZSBzdHJlYW0gaW5jbHVkaW5nIHRoZSBieXRlIGF0IGkuXG4gICAgaWYgKGxlbmd0aCAtIGkgPj0gMyAmJiAhc3RyZWFtW2ldICYmICFzdHJlYW1baSArIDFdICYmIHN0cmVhbVtpICsgMl0gPT0gMykge1xuICAgICAgLy8gVHdvIHJic3AgYnl0ZXMuXG4gICAgICBkYXRhT3V0LnB1c2goc3RyZWFtW2krK10pO1xuICAgICAgZGF0YU91dC5wdXNoKHN0cmVhbVtpKytdKTtcbiAgICAgIC8vIFNraXAgdGhlIGVtdWxhdGlvbiBieXRlLlxuICAgICAgaSsrO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTaW5nbGUgcmJzcCBieXRlLlxuICAgICAgZGF0YU91dC5wdXNoKHN0cmVhbVtpKytdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGFPdXQpO1xufVxuXG5jb25zdCBrWmVyb3NJblN0YXJ0U2VxdWVuY2UgPSAyO1xuY29uc3Qga0VtdWxhdGlvbkJ5dGUgPSAzO1xuXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVSYnNwKGRhdGFfaW46IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgZGF0YU91dDogbnVtYmVyW10gPSBbXTtcbiAgdmFyIG51bUNvbnNlY3V0aXZlWmVyb3MgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFfaW4ubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnl0ZSA9IGRhdGFfaW5baV07XG4gICAgaWYgKGJ5dGUgPD0ga0VtdWxhdGlvbkJ5dGUgJiYgbnVtQ29uc2VjdXRpdmVaZXJvcyA+PSBrWmVyb3NJblN0YXJ0U2VxdWVuY2UpIHtcbiAgICAgIC8vIE5lZWQgdG8gZXNjYXBlLlxuICAgICAgZGF0YU91dC5wdXNoKGtFbXVsYXRpb25CeXRlKTtcbiAgICAgIG51bUNvbnNlY3V0aXZlWmVyb3MgPSAwO1xuICAgIH1cbiAgICBkYXRhT3V0LnB1c2goYnl0ZSk7XG4gICAgaWYgKGJ5dGUgPT0gMCkge1xuICAgICAgKytudW1Db25zZWN1dGl2ZVplcm9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1Db25zZWN1dGl2ZVplcm9zID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGFPdXQpO1xufVxuIiwiaW1wb3J0IHsgTUFYX1NJRl9DT1VOVCwgTUFYX1NJRl9EVVJBVElPTiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBjbGFzcyBTaWZHdWFyZCB7XG4gIHByaXZhdGUgY29uc2VjdXRpdmVTaWZDb3VudCA9IDA7XG5cbiAgcHJpdmF0ZSBzaWZTZXF1ZW5jZVN0YXJ0ZWRBdDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgbGFzdFNpZlJlY2VpdmVkQXQ6IG51bWJlciA9IDA7XG5cbiAgcHJpdmF0ZSB1c2VyRnJhbWVzU2luY2VTaWY6IG51bWJlciA9IDA7XG5cbiAgcmVjb3JkU2lmKCkge1xuICAgIHRoaXMuY29uc2VjdXRpdmVTaWZDb3VudCArPSAxO1xuICAgIHRoaXMuc2lmU2VxdWVuY2VTdGFydGVkQXQgPz89IERhdGUubm93KCk7XG4gICAgdGhpcy5sYXN0U2lmUmVjZWl2ZWRBdCA9IERhdGUubm93KCk7XG4gIH1cblxuICByZWNvcmRVc2VyRnJhbWUoKSB7XG4gICAgaWYgKHRoaXMuc2lmU2VxdWVuY2VTdGFydGVkQXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVzZXJGcmFtZXNTaW5jZVNpZiArPSAxO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAvLyByZXNldCBpZiB3ZSByZWNlaXZlZCBtb3JlIHVzZXIgZnJhbWVzIHRoYW4gU0lGc1xuICAgICAgdGhpcy51c2VyRnJhbWVzU2luY2VTaWYgPiB0aGlzLmNvbnNlY3V0aXZlU2lmQ291bnQgfHxcbiAgICAgIC8vIGFsc28gcmVzZXQgaWYgd2UgZ290IGEgbmV3IHVzZXIgZnJhbWUgYW5kIHRoZSBsYXRlc3QgU0lGIGZyYW1lIGhhc24ndCBiZWVuIHVwZGF0ZWQgaW4gYSB3aGlsZVxuICAgICAgRGF0ZS5ub3coKSAtIHRoaXMubGFzdFNpZlJlY2VpdmVkQXQgPiBNQVhfU0lGX0RVUkFUSU9OXG4gICAgKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICB9XG5cbiAgaXNTaWZBbGxvd2VkKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmNvbnNlY3V0aXZlU2lmQ291bnQgPCBNQVhfU0lGX0NPVU5UICYmXG4gICAgICAodGhpcy5zaWZTZXF1ZW5jZVN0YXJ0ZWRBdCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIERhdGUubm93KCkgLSB0aGlzLnNpZlNlcXVlbmNlU3RhcnRlZEF0IDwgTUFYX1NJRl9EVVJBVElPTilcbiAgICApO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy51c2VyRnJhbWVzU2luY2VTaWYgPSAwO1xuICAgIHRoaXMuY29uc2VjdXRpdmVTaWZDb3VudCA9IDA7XG4gICAgdGhpcy5zaWZTZXF1ZW5jZVN0YXJ0ZWRBdCA9IHVuZGVmaW5lZDtcbiAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4vLyBUT0RPIGNvZGUgaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Yy9zYW1wbGVzL2Jsb2IvZ2gtcGFnZXMvc3JjL2NvbnRlbnQvaW5zZXJ0YWJsZS1zdHJlYW1zL2VuZHRvZW5kLWVuY3J5cHRpb24vanMvd29ya2VyLmpzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHR5cGUgVHlwZWRFdmVudEVtaXR0ZXIgZnJvbSAndHlwZWQtZW1pdHRlcic7XG5pbXBvcnQgeyB3b3JrZXJMb2dnZXIgfSBmcm9tICcuLi8uLi9sb2dnZXInO1xuaW1wb3J0IHR5cGUgeyBWaWRlb0NvZGVjIH0gZnJvbSAnLi4vLi4vcm9vbS90cmFjay9vcHRpb25zJztcbmltcG9ydCB7IEVOQ1JZUFRJT05fQUxHT1JJVEhNLCBJVl9MRU5HVEgsIFVORU5DUllQVEVEX0JZVEVTIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IENyeXB0b3JFcnJvciwgQ3J5cHRvckVycm9yUmVhc29uIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IHR5cGUgQ3J5cHRvckNhbGxiYWNrcywgQ3J5cHRvckV2ZW50IH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgRGVjb2RlUmF0Y2hldE9wdGlvbnMsIEtleVByb3ZpZGVyT3B0aW9ucywgS2V5U2V0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZGVyaXZlS2V5cywgaXNWaWRlb0ZyYW1lLCBuZWVkc1Jic3BVbmVzY2FwaW5nLCBwYXJzZVJic3AsIHdyaXRlUmJzcCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgUGFydGljaXBhbnRLZXlIYW5kbGVyIH0gZnJvbSAnLi9QYXJ0aWNpcGFudEtleUhhbmRsZXInO1xuaW1wb3J0IHsgU2lmR3VhcmQgfSBmcm9tICcuL1NpZkd1YXJkJztcblxuZXhwb3J0IGNvbnN0IGVuY3J5cHRpb25FbmFibGVkTWFwOiBNYXA8c3RyaW5nLCBib29sZWFuPiA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGludGVyZmFjZSBGcmFtZUNyeXB0b3JDb25zdHJ1Y3RvciB7XG4gIG5ldyAob3B0cz86IHVua25vd24pOiBCYXNlRnJhbWVDcnlwdG9yO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zZm9ybWVySW5mbyB7XG4gIHJlYWRhYmxlOiBSZWFkYWJsZVN0cmVhbTtcbiAgd3JpdGFibGU6IFdyaXRhYmxlU3RyZWFtO1xuICB0cmFuc2Zvcm1lcjogVHJhbnNmb3JtU3RyZWFtO1xuICBhYm9ydENvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEJhc2VGcmFtZUNyeXB0b3IgZXh0ZW5kcyAoRXZlbnRFbWl0dGVyIGFzIG5ldyAoKSA9PiBUeXBlZEV2ZW50RW1pdHRlcjxDcnlwdG9yQ2FsbGJhY2tzPikge1xuICBwcm90ZWN0ZWQgZW5jb2RlRnVuY3Rpb24oXG4gICAgZW5jb2RlZEZyYW1lOiBSVENFbmNvZGVkVmlkZW9GcmFtZSB8IFJUQ0VuY29kZWRBdWRpb0ZyYW1lLFxuICAgIGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLFxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIHRocm93IEVycm9yKCdub3QgaW1wbGVtZW50ZWQgZm9yIHN1YmNsYXNzJyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZGVjb2RlRnVuY3Rpb24oXG4gICAgZW5jb2RlZEZyYW1lOiBSVENFbmNvZGVkVmlkZW9GcmFtZSB8IFJUQ0VuY29kZWRBdWRpb0ZyYW1lLFxuICAgIGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLFxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIHRocm93IEVycm9yKCdub3QgaW1wbGVtZW50ZWQgZm9yIHN1YmNsYXNzJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDcnlwdG9yIGlzIHJlc3BvbnNpYmxlIGZvciBlbi0vZGVjcnlwdGluZyBtZWRpYSBmcmFtZXMuXG4gKiBFYWNoIENyeXB0b3IgaW5zdGFuY2UgaXMgcmVzcG9uc2libGUgZm9yIGVuLS9kZWNyeXB0aW5nIGEgc2luZ2xlIG1lZGlhU3RyZWFtVHJhY2suXG4gKi9cbmV4cG9ydCBjbGFzcyBGcmFtZUNyeXB0b3IgZXh0ZW5kcyBCYXNlRnJhbWVDcnlwdG9yIHtcbiAgcHJpdmF0ZSBzZW5kQ291bnRzOiBNYXA8bnVtYmVyLCBudW1iZXI+O1xuXG4gIHByaXZhdGUgcGFydGljaXBhbnRJZGVudGl0eTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgdHJhY2tJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUga2V5czogUGFydGljaXBhbnRLZXlIYW5kbGVyO1xuXG4gIHByaXZhdGUgdmlkZW9Db2RlYz86IFZpZGVvQ29kZWM7XG5cbiAgcHJpdmF0ZSBydHBNYXA6IE1hcDxudW1iZXIsIFZpZGVvQ29kZWM+O1xuXG4gIHByaXZhdGUga2V5UHJvdmlkZXJPcHRpb25zOiBLZXlQcm92aWRlck9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIHVzZWQgZm9yIGRldGVjdGluZyBzZXJ2ZXIgaW5qZWN0ZWQgdW5lbmNyeXB0ZWQgZnJhbWVzXG4gICAqL1xuICBwcml2YXRlIHNpZlRyYWlsZXI6IFVpbnQ4QXJyYXk7XG5cbiAgcHJpdmF0ZSBzaWZHdWFyZDogU2lmR3VhcmQ7XG5cbiAgcHJpdmF0ZSBkZXRlY3RlZENvZGVjPzogVmlkZW9Db2RlYztcblxuICBjb25zdHJ1Y3RvcihvcHRzOiB7XG4gICAga2V5czogUGFydGljaXBhbnRLZXlIYW5kbGVyO1xuICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHN0cmluZztcbiAgICBrZXlQcm92aWRlck9wdGlvbnM6IEtleVByb3ZpZGVyT3B0aW9ucztcbiAgICBzaWZUcmFpbGVyPzogVWludDhBcnJheTtcbiAgfSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZW5kQ291bnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMua2V5cyA9IG9wdHMua2V5cztcbiAgICB0aGlzLnBhcnRpY2lwYW50SWRlbnRpdHkgPSBvcHRzLnBhcnRpY2lwYW50SWRlbnRpdHk7XG4gICAgdGhpcy5ydHBNYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5rZXlQcm92aWRlck9wdGlvbnMgPSBvcHRzLmtleVByb3ZpZGVyT3B0aW9ucztcbiAgICB0aGlzLnNpZlRyYWlsZXIgPSBvcHRzLnNpZlRyYWlsZXIgPz8gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICB0aGlzLnNpZkd1YXJkID0gbmV3IFNpZkd1YXJkKCk7XG4gIH1cblxuICBwcml2YXRlIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXJ0aWNpcGFudDogdGhpcy5wYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgbWVkaWFUcmFja0lkOiB0aGlzLnRyYWNrSWQsXG4gICAgICBmYWxsYmFja0NvZGVjOiB0aGlzLnZpZGVvQ29kZWMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ24gYSBkaWZmZXJlbnQgcGFydGljaXBhbnQgdG8gdGhlIGNyeXB0b3IuXG4gICAqIHVzZWZ1bCBmb3IgdHJhbnNjZWl2ZXIgcmUtdXNlXG4gICAqIEBwYXJhbSBpZFxuICAgKiBAcGFyYW0ga2V5c1xuICAgKi9cbiAgc2V0UGFydGljaXBhbnQoaWQ6IHN0cmluZywga2V5czogUGFydGljaXBhbnRLZXlIYW5kbGVyKSB7XG4gICAgd29ya2VyTG9nZ2VyLmRlYnVnKCdzZXR0aW5nIG5ldyBwYXJ0aWNpcGFudCBvbiBjcnlwdG9yJywge1xuICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgcGFydGljaXBhbnQ6IGlkLFxuICAgIH0pO1xuICAgIGlmICh0aGlzLnBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICAgIHdvcmtlckxvZ2dlci5lcnJvcihcbiAgICAgICAgJ2NyeXB0b3IgaGFzIGFscmVhZHkgYSBwYXJ0aWNpcGFudCBzZXQsIHBhcnRpY2lwYW50IHNob3VsZCBoYXZlIGJlZW4gdW5zZXQgYmVmb3JlJyxcbiAgICAgICAge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMucGFydGljaXBhbnRJZGVudGl0eSA9IGlkO1xuICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgdGhpcy5zaWZHdWFyZC5yZXNldCgpO1xuICB9XG5cbiAgdW5zZXRQYXJ0aWNpcGFudCgpIHtcbiAgICB3b3JrZXJMb2dnZXIuZGVidWcoJ3Vuc2V0dGluZyBwYXJ0aWNpcGFudCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgdGhpcy5wYXJ0aWNpcGFudElkZW50aXR5ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaXNFbmFibGVkKCkge1xuICAgIGlmICh0aGlzLnBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICAgIHJldHVybiBlbmNyeXB0aW9uRW5hYmxlZE1hcC5nZXQodGhpcy5wYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBnZXRQYXJ0aWNpcGFudElkZW50aXR5KCkge1xuICAgIHJldHVybiB0aGlzLnBhcnRpY2lwYW50SWRlbnRpdHk7XG4gIH1cblxuICBnZXRUcmFja0lkKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB2aWRlbyBjb2RlYyB1c2VkIGJ5IHRoZSBtZWRpYVN0cmVhbVRyYWNrXG4gICAqIEBwYXJhbSBjb2RlY1xuICAgKi9cbiAgc2V0VmlkZW9Db2RlYyhjb2RlYzogVmlkZW9Db2RlYykge1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IGNvZGVjO1xuICB9XG5cbiAgLyoqXG4gICAqIHJ0cCBwYXlsb2FkIHR5cGUgbWFwIHVzZWQgZm9yIGZpZ3VyaW5nIG91dCBjb2RlYyBvZiBwYXlsb2FkIHR5cGUgd2hlbiBlbmNvZGluZ1xuICAgKiBAcGFyYW0gbWFwXG4gICAqL1xuICBzZXRSdHBNYXAobWFwOiBNYXA8bnVtYmVyLCBWaWRlb0NvZGVjPikge1xuICAgIHRoaXMucnRwTWFwID0gbWFwO1xuICB9XG5cbiAgc2V0dXBUcmFuc2Zvcm0oXG4gICAgb3BlcmF0aW9uOiAnZW5jb2RlJyB8ICdkZWNvZGUnLFxuICAgIHJlYWRhYmxlOiBSZWFkYWJsZVN0cmVhbTxSVENFbmNvZGVkVmlkZW9GcmFtZSB8IFJUQ0VuY29kZWRBdWRpb0ZyYW1lPixcbiAgICB3cml0YWJsZTogV3JpdGFibGVTdHJlYW08UlRDRW5jb2RlZFZpZGVvRnJhbWUgfCBSVENFbmNvZGVkQXVkaW9GcmFtZT4sXG4gICAgdHJhY2tJZDogc3RyaW5nLFxuICAgIGNvZGVjPzogVmlkZW9Db2RlYyxcbiAgKSB7XG4gICAgaWYgKGNvZGVjKSB7XG4gICAgICB3b3JrZXJMb2dnZXIuaW5mbygnc2V0dGluZyBjb2RlYyBvbiBjcnlwdG9yIHRvJywgeyBjb2RlYyB9KTtcbiAgICAgIHRoaXMudmlkZW9Db2RlYyA9IGNvZGVjO1xuICAgIH1cblxuICAgIHdvcmtlckxvZ2dlci5kZWJ1ZygnU2V0dGluZyB1cCBmcmFtZSBjcnlwdG9yIHRyYW5zZm9ybScsIHtcbiAgICAgIG9wZXJhdGlvbixcbiAgICAgIHBhc3NlZFRyYWNrSWQ6IHRyYWNrSWQsXG4gICAgICBjb2RlYyxcbiAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICB9KTtcblxuICAgIGNvbnN0IHRyYW5zZm9ybUZuID0gb3BlcmF0aW9uID09PSAnZW5jb2RlJyA/IHRoaXMuZW5jb2RlRnVuY3Rpb24gOiB0aGlzLmRlY29kZUZ1bmN0aW9uO1xuICAgIGNvbnN0IHRyYW5zZm9ybVN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1Gbi5iaW5kKHRoaXMpLFxuICAgIH0pO1xuXG4gICAgcmVhZGFibGVcbiAgICAgIC5waXBlVGhyb3VnaCh0cmFuc2Zvcm1TdHJlYW0pXG4gICAgICAucGlwZVRvKHdyaXRhYmxlKVxuICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHdvcmtlckxvZ2dlci53YXJuKGUpO1xuICAgICAgICB0aGlzLmVtaXQoXG4gICAgICAgICAgQ3J5cHRvckV2ZW50LkVycm9yLFxuICAgICAgICAgIGUgaW5zdGFuY2VvZiBDcnlwdG9yRXJyb3JcbiAgICAgICAgICAgID8gZVxuICAgICAgICAgICAgOiBuZXcgQ3J5cHRvckVycm9yKGUubWVzc2FnZSwgdW5kZWZpbmVkLCB0aGlzLnBhcnRpY2lwYW50SWRlbnRpdHkpLFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgdGhpcy50cmFja0lkID0gdHJhY2tJZDtcbiAgfVxuXG4gIHNldFNpZlRyYWlsZXIodHJhaWxlcjogVWludDhBcnJheSkge1xuICAgIHdvcmtlckxvZ2dlci5kZWJ1Zygnc2V0dGluZyBTSUYgdHJhaWxlcicsIHsgLi4udGhpcy5sb2dDb250ZXh0LCB0cmFpbGVyIH0pO1xuICAgIHRoaXMuc2lmVHJhaWxlciA9IHRyYWlsZXI7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGluamVjdGVkIGluIGEgc3RyZWFtIGFuZCB3aWxsIGVuY3J5cHQgdGhlIGdpdmVuIGVuY29kZWQgZnJhbWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JUQ0VuY29kZWRWaWRlb0ZyYW1lfFJUQ0VuY29kZWRBdWRpb0ZyYW1lfSBlbmNvZGVkRnJhbWUgLSBFbmNvZGVkIHZpZGVvIGZyYW1lLlxuICAgKiBAcGFyYW0ge1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyfSBjb250cm9sbGVyIC0gVHJhbnNwb3J0U3RyZWFtQ29udHJvbGxlci5cbiAgICpcbiAgICogVGhlIFZQOCBwYXlsb2FkIGRlc2NyaXB0b3IgZGVzY3JpYmVkIGluXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NzQxI3NlY3Rpb24tNC4yXG4gICAqIGlzIHBhcnQgb2YgdGhlIFJUUCBwYWNrZXQgYW5kIG5vdCBwYXJ0IG9mIHRoZSBmcmFtZSBhbmQgaXMgbm90IGNvbnRyb2xsYWJsZSBieSB1cy5cbiAgICogVGhpcyBpcyBmaW5lIGFzIHRoZSBTRlUga2VlcHMgaGF2aW5nIGFjY2VzcyB0byBpdCBmb3Igcm91dGluZy5cbiAgICpcbiAgICogVGhlIGVuY3J5cHRlZCBmcmFtZSBpcyBmb3JtZWQgYXMgZm9sbG93czpcbiAgICogMSkgRmluZCB1bmVuY3J5cHRlZCBieXRlIGxlbmd0aCwgZGVwZW5kaW5nIG9uIHRoZSBjb2RlYywgZnJhbWUgdHlwZSBhbmQga2luZC5cbiAgICogMikgRm9ybSB0aGUgR0NNIElWIGZvciB0aGUgZnJhbWUgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKiAzKSBFbmNyeXB0IHRoZSByZXN0IG9mIHRoZSBmcmFtZSB1c2luZyBBRVMtR0NNLlxuICAgKiA0KSBBbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIGVuY3J5cHRlZCBmcmFtZS5cbiAgICogNSkgQ29weSB0aGUgdW5lbmNyeXB0ZWQgYnl0ZXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBlbmNyeXB0ZWQgZnJhbWUuXG4gICAqIDYpIEFwcGVuZCB0aGUgY2lwaGVydGV4dCB0byB0aGUgZW5jcnlwdGVkIGZyYW1lLlxuICAgKiA3KSBBcHBlbmQgdGhlIElWLlxuICAgKiA4KSBBcHBlbmQgYSBzaW5nbGUgYnl0ZSBmb3IgdGhlIGtleSBpZGVudGlmaWVyLlxuICAgKiA5KSBFbnF1ZXVlIHRoZSBlbmNyeXB0ZWQgZnJhbWUgZm9yIHNlbmRpbmcuXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgZW5jb2RlRnVuY3Rpb24oXG4gICAgZW5jb2RlZEZyYW1lOiBSVENFbmNvZGVkVmlkZW9GcmFtZSB8IFJUQ0VuY29kZWRBdWRpb0ZyYW1lLFxuICAgIGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLFxuICApIHtcbiAgICBpZiAoXG4gICAgICAhdGhpcy5pc0VuYWJsZWQoKSB8fFxuICAgICAgLy8gc2tpcCBmb3IgZW5jcnlwdGlvbiBmb3IgZW1wdHkgZHR4IGZyYW1lc1xuICAgICAgZW5jb2RlZEZyYW1lLmRhdGEuYnl0ZUxlbmd0aCA9PT0gMFxuICAgICkge1xuICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkRnJhbWUpO1xuICAgIH1cbiAgICBjb25zdCBrZXlTZXQgPSB0aGlzLmtleXMuZ2V0S2V5U2V0KCk7XG4gICAgaWYgKCFrZXlTZXQpIHtcbiAgICAgIHRoaXMuZW1pdChcbiAgICAgICAgQ3J5cHRvckV2ZW50LkVycm9yLFxuICAgICAgICBuZXcgQ3J5cHRvckVycm9yKFxuICAgICAgICAgIGBrZXkgc2V0IG5vdCBmb3VuZCBmb3IgJHtcbiAgICAgICAgICAgIHRoaXMucGFydGljaXBhbnRJZGVudGl0eVxuICAgICAgICAgIH0gYXQgaW5kZXggJHt0aGlzLmtleXMuZ2V0Q3VycmVudEtleUluZGV4KCl9YCxcbiAgICAgICAgICBDcnlwdG9yRXJyb3JSZWFzb24uTWlzc2luZ0tleSxcbiAgICAgICAgICB0aGlzLnBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgICksXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGVuY3J5cHRpb25LZXkgfSA9IGtleVNldDtcbiAgICBjb25zdCBrZXlJbmRleCA9IHRoaXMua2V5cy5nZXRDdXJyZW50S2V5SW5kZXgoKTtcblxuICAgIGlmIChlbmNyeXB0aW9uS2V5KSB7XG4gICAgICBjb25zdCBpdiA9IHRoaXMubWFrZUlWKFxuICAgICAgICBlbmNvZGVkRnJhbWUuZ2V0TWV0YWRhdGEoKS5zeW5jaHJvbml6YXRpb25Tb3VyY2UgPz8gLTEsXG4gICAgICAgIGVuY29kZWRGcmFtZS50aW1lc3RhbXAsXG4gICAgICApO1xuICAgICAgbGV0IGZyYW1lSW5mbyA9IHRoaXMuZ2V0VW5lbmNyeXB0ZWRCeXRlcyhlbmNvZGVkRnJhbWUpO1xuXG4gICAgICAvLyBUaNGWcyBpcyBub3QgZW5jcnlwdGVkIGFuZCBjb250YWlucyB0aGUgVlA4IHBheWxvYWQgZGVzY3JpcHRvciBvciB0aGUgT3B1cyBUT0MgYnl0ZS5cbiAgICAgIGNvbnN0IGZyYW1lSGVhZGVyID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEZyYW1lLmRhdGEsIDAsIGZyYW1lSW5mby51bmVuY3J5cHRlZEJ5dGVzKTtcblxuICAgICAgLy8gRnJhbWUgdHJhaWxlciBjb250YWlucyB0aGUgUnxJVl9MRU5HVEggYW5kIGtleSBpbmRleFxuICAgICAgY29uc3QgZnJhbWVUcmFpbGVyID0gbmV3IFVpbnQ4QXJyYXkoMik7XG5cbiAgICAgIGZyYW1lVHJhaWxlclswXSA9IElWX0xFTkdUSDtcbiAgICAgIGZyYW1lVHJhaWxlclsxXSA9IGtleUluZGV4O1xuXG4gICAgICAvLyBDb25zdHJ1Y3QgZnJhbWUgdHJhaWxlci4gU2ltaWxhciB0byB0aGUgZnJhbWUgaGVhZGVyIGRlc2NyaWJlZCBpblxuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LW9tYXJhLXNmcmFtZS0wMCNzZWN0aW9uLTQuMlxuICAgICAgLy8gYnV0IHdlIHB1dCBpdCBhdCB0aGUgZW5kLlxuICAgICAgLy9cbiAgICAgIC8vIC0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0rLS0tLS0tLS0tKy0tLS1cbiAgICAgIC8vIHBheWxvYWQgIHxJVi4uLihsZW5ndGggPSBJVl9MRU5HVEgpfFJ8SVZfTEVOR1RIfEtJRCB8XG4gICAgICAvLyAtLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstKy0tLS0tLS0tLSstLS0tXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjaXBoZXJUZXh0ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5lbmNyeXB0KFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IEVOQ1JZUFRJT05fQUxHT1JJVEhNLFxuICAgICAgICAgICAgaXYsXG4gICAgICAgICAgICBhZGRpdGlvbmFsRGF0YTogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEZyYW1lLmRhdGEsIDAsIGZyYW1lSGVhZGVyLmJ5dGVMZW5ndGgpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5jcnlwdGlvbktleSxcbiAgICAgICAgICBuZXcgVWludDhBcnJheShlbmNvZGVkRnJhbWUuZGF0YSwgZnJhbWVJbmZvLnVuZW5jcnlwdGVkQnl0ZXMpLFxuICAgICAgICApO1xuXG4gICAgICAgIGxldCBuZXdEYXRhV2l0aG91dEhlYWRlciA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgIGNpcGhlclRleHQuYnl0ZUxlbmd0aCArIGl2LmJ5dGVMZW5ndGggKyBmcmFtZVRyYWlsZXIuYnl0ZUxlbmd0aCxcbiAgICAgICAgKTtcbiAgICAgICAgbmV3RGF0YVdpdGhvdXRIZWFkZXIuc2V0KG5ldyBVaW50OEFycmF5KGNpcGhlclRleHQpKTsgLy8gYWRkIGNpcGhlcnRleHQuXG4gICAgICAgIG5ld0RhdGFXaXRob3V0SGVhZGVyLnNldChuZXcgVWludDhBcnJheShpdiksIGNpcGhlclRleHQuYnl0ZUxlbmd0aCk7IC8vIGFwcGVuZCBJVi5cbiAgICAgICAgbmV3RGF0YVdpdGhvdXRIZWFkZXIuc2V0KGZyYW1lVHJhaWxlciwgY2lwaGVyVGV4dC5ieXRlTGVuZ3RoICsgaXYuYnl0ZUxlbmd0aCk7IC8vIGFwcGVuZCBmcmFtZSB0cmFpbGVyLlxuXG4gICAgICAgIGlmIChmcmFtZUluZm8uaXNIMjY0KSB7XG4gICAgICAgICAgbmV3RGF0YVdpdGhvdXRIZWFkZXIgPSB3cml0ZVJic3AobmV3RGF0YVdpdGhvdXRIZWFkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShmcmFtZUhlYWRlci5ieXRlTGVuZ3RoICsgbmV3RGF0YVdpdGhvdXRIZWFkZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIG5ld0RhdGEuc2V0KGZyYW1lSGVhZGVyKTtcbiAgICAgICAgbmV3RGF0YS5zZXQobmV3RGF0YVdpdGhvdXRIZWFkZXIsIGZyYW1lSGVhZGVyLmJ5dGVMZW5ndGgpO1xuXG4gICAgICAgIGVuY29kZWRGcmFtZS5kYXRhID0gbmV3RGF0YS5idWZmZXI7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkRnJhbWUpO1xuICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgIC8vIFRPRE86IHN1cmZhY2UgdGhpcyB0byB0aGUgYXBwLlxuICAgICAgICB3b3JrZXJMb2dnZXIuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtlckxvZ2dlci5kZWJ1ZygnZmFpbGVkIHRvIGVuY3J5cHQsIGVtaXR0aW5nIGVycm9yJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMuZW1pdChcbiAgICAgICAgQ3J5cHRvckV2ZW50LkVycm9yLFxuICAgICAgICBuZXcgQ3J5cHRvckVycm9yKFxuICAgICAgICAgIGBlbmNyeXB0aW9uIGtleSBtaXNzaW5nIGZvciBlbmNvZGluZ2AsXG4gICAgICAgICAgQ3J5cHRvckVycm9yUmVhc29uLk1pc3NpbmdLZXksXG4gICAgICAgICAgdGhpcy5wYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGluamVjdGVkIGluIGEgc3RyZWFtIGFuZCB3aWxsIGRlY3J5cHQgdGhlIGdpdmVuIGVuY29kZWQgZnJhbWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JUQ0VuY29kZWRWaWRlb0ZyYW1lfFJUQ0VuY29kZWRBdWRpb0ZyYW1lfSBlbmNvZGVkRnJhbWUgLSBFbmNvZGVkIHZpZGVvIGZyYW1lLlxuICAgKiBAcGFyYW0ge1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyfSBjb250cm9sbGVyIC0gVHJhbnNwb3J0U3RyZWFtQ29udHJvbGxlci5cbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBkZWNvZGVGdW5jdGlvbihcbiAgICBlbmNvZGVkRnJhbWU6IFJUQ0VuY29kZWRWaWRlb0ZyYW1lIHwgUlRDRW5jb2RlZEF1ZGlvRnJhbWUsXG4gICAgY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIsXG4gICkge1xuICAgIGlmIChcbiAgICAgICF0aGlzLmlzRW5hYmxlZCgpIHx8XG4gICAgICAvLyBza2lwIGZvciBkZWNyeXB0aW9uIGZvciBlbXB0eSBkdHggZnJhbWVzXG4gICAgICBlbmNvZGVkRnJhbWUuZGF0YS5ieXRlTGVuZ3RoID09PSAwXG4gICAgKSB7XG4gICAgICB3b3JrZXJMb2dnZXIuZGVidWcoJ3NraXBwaW5nIGVtcHR5IGZyYW1lJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMuc2lmR3VhcmQucmVjb3JkVXNlckZyYW1lKCk7XG4gICAgICByZXR1cm4gY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZWRGcmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRnJhbWVTZXJ2ZXJJbmplY3RlZChlbmNvZGVkRnJhbWUuZGF0YSwgdGhpcy5zaWZUcmFpbGVyKSkge1xuICAgICAgd29ya2VyTG9nZ2VyLmRlYnVnKCdlbnF1ZXVlIFNJRicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLnNpZkd1YXJkLnJlY29yZFNpZigpO1xuXG4gICAgICBpZiAodGhpcy5zaWZHdWFyZC5pc1NpZkFsbG93ZWQoKSkge1xuICAgICAgICBlbmNvZGVkRnJhbWUuZGF0YSA9IGVuY29kZWRGcmFtZS5kYXRhLnNsaWNlKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgZW5jb2RlZEZyYW1lLmRhdGEuYnl0ZUxlbmd0aCAtIHRoaXMuc2lmVHJhaWxlci5ieXRlTGVuZ3RoLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZWRGcmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3b3JrZXJMb2dnZXIud2FybignU0lGIGxpbWl0IHJlYWNoZWQsIGRyb3BwaW5nIGZyYW1lJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaWZHdWFyZC5yZWNvcmRVc2VyRnJhbWUoKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGVuY29kZWRGcmFtZS5kYXRhKTtcbiAgICBjb25zdCBrZXlJbmRleCA9IGRhdGFbZW5jb2RlZEZyYW1lLmRhdGEuYnl0ZUxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKHRoaXMua2V5cy5oYXNJbnZhbGlkS2V5QXRJbmRleChrZXlJbmRleCkpIHtcbiAgICAgIC8vIGRyb3AgZnJhbWVcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5rZXlzLmdldEtleVNldChrZXlJbmRleCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWRGcmFtZSA9IGF3YWl0IHRoaXMuZGVjcnlwdEZyYW1lKGVuY29kZWRGcmFtZSwga2V5SW5kZXgpO1xuICAgICAgICB0aGlzLmtleXMuZGVjcnlwdGlvblN1Y2Nlc3Moa2V5SW5kZXgpO1xuICAgICAgICBpZiAoZGVjb2RlZEZyYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZW5xdWV1ZShkZWNvZGVkRnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDcnlwdG9yRXJyb3IgJiYgZXJyb3IucmVhc29uID09PSBDcnlwdG9yRXJyb3JSZWFzb24uSW52YWxpZEtleSkge1xuICAgICAgICAgIC8vIGVtaXQgYW4gZXJyb3IgaWYgdGhlIGtleSBoYW5kbGVyIHRoaW5rcyB3ZSBoYXZlIGEgdmFsaWQga2V5XG4gICAgICAgICAgaWYgKHRoaXMua2V5cy5oYXNWYWxpZEtleSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KENyeXB0b3JFdmVudC5FcnJvciwgZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5rZXlzLmRlY3J5cHRpb25GYWlsdXJlKGtleUluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd29ya2VyTG9nZ2VyLndhcm4oJ2RlY29kaW5nIGZyYW1lIGZhaWxlZCcsIHsgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1pdCBhbiBlcnJvciBpZiB0aGUga2V5IGluZGV4IGlzIG91dCBvZiBib3VuZHMgYnV0IHRoZSBrZXkgaGFuZGxlciB0aGlua3Mgd2Ugc3RpbGwgaGF2ZSBhIHZhbGlkIGtleVxuICAgICAgd29ya2VyTG9nZ2VyLndhcm4oYHNraXBwaW5nIGRlY3J5cHRpb24gZHVlIHRvIG1pc3Npbmcga2V5IGF0IGluZGV4ICR7a2V5SW5kZXh9YCk7XG4gICAgICB0aGlzLmVtaXQoXG4gICAgICAgIENyeXB0b3JFdmVudC5FcnJvcixcbiAgICAgICAgbmV3IENyeXB0b3JFcnJvcihcbiAgICAgICAgICBgbWlzc2luZyBrZXkgYXQgaW5kZXggJHtrZXlJbmRleH0gZm9yIHBhcnRpY2lwYW50ICR7dGhpcy5wYXJ0aWNpcGFudElkZW50aXR5fWAsXG4gICAgICAgICAgQ3J5cHRvckVycm9yUmVhc29uLk1pc3NpbmdLZXksXG4gICAgICAgICAgdGhpcy5wYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICAgIHRoaXMua2V5cy5kZWNyeXB0aW9uRmFpbHVyZShrZXlJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRoYXQgd2lsbCBkZWNyeXB0IHRoZSBnaXZlbiBlbmNvZGVkIGZyYW1lLiBJZiB0aGUgZGVjcnlwdGlvbiBmYWlscywgaXQgd2lsbFxuICAgKiByYXRjaGV0IHRoZSBrZXkgZm9yIHVwIHRvIFJBVENIRVRfV0lORE9XX1NJWkUgdGltZXMuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGRlY3J5cHRGcmFtZShcbiAgICBlbmNvZGVkRnJhbWU6IFJUQ0VuY29kZWRWaWRlb0ZyYW1lIHwgUlRDRW5jb2RlZEF1ZGlvRnJhbWUsXG4gICAga2V5SW5kZXg6IG51bWJlcixcbiAgICBpbml0aWFsTWF0ZXJpYWw6IEtleVNldCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbiAgICByYXRjaGV0T3B0czogRGVjb2RlUmF0Y2hldE9wdGlvbnMgPSB7IHJhdGNoZXRDb3VudDogMCB9LFxuICApOiBQcm9taXNlPFJUQ0VuY29kZWRWaWRlb0ZyYW1lIHwgUlRDRW5jb2RlZEF1ZGlvRnJhbWUgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCBrZXlTZXQgPSB0aGlzLmtleXMuZ2V0S2V5U2V0KGtleUluZGV4KTtcbiAgICBpZiAoIXJhdGNoZXRPcHRzLmVuY3J5cHRpb25LZXkgJiYgIWtleVNldCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgbm8gZW5jcnlwdGlvbiBrZXkgZm91bmQgZm9yIGRlY3J5cHRpb24gb2YgJHt0aGlzLnBhcnRpY2lwYW50SWRlbnRpdHl9YCk7XG4gICAgfVxuICAgIGxldCBmcmFtZUluZm8gPSB0aGlzLmdldFVuZW5jcnlwdGVkQnl0ZXMoZW5jb2RlZEZyYW1lKTtcblxuICAgIC8vIENvbnN0cnVjdCBmcmFtZSB0cmFpbGVyLiBTaW1pbGFyIHRvIHRoZSBmcmFtZSBoZWFkZXIgZGVzY3JpYmVkIGluXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LW9tYXJhLXNmcmFtZS0wMCNzZWN0aW9uLTQuMlxuICAgIC8vIGJ1dCB3ZSBwdXQgaXQgYXQgdGhlIGVuZC5cbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0rLS0tLS0tLS0tKy0tLS1cbiAgICAvLyBwYXlsb2FkICB8SVYuLi4obGVuZ3RoID0gSVZfTEVOR1RIKXxSfElWX0xFTkdUSHxLSUQgfFxuICAgIC8vIC0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0rLS0tLS0tLS0tKy0tLS1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBmcmFtZUhlYWRlciA9IG5ldyBVaW50OEFycmF5KGVuY29kZWRGcmFtZS5kYXRhLCAwLCBmcmFtZUluZm8udW5lbmNyeXB0ZWRCeXRlcyk7XG4gICAgICB2YXIgZW5jcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICBlbmNvZGVkRnJhbWUuZGF0YSxcbiAgICAgICAgZnJhbWVIZWFkZXIubGVuZ3RoLFxuICAgICAgICBlbmNvZGVkRnJhbWUuZGF0YS5ieXRlTGVuZ3RoIC0gZnJhbWVIZWFkZXIubGVuZ3RoLFxuICAgICAgKTtcbiAgICAgIGlmIChmcmFtZUluZm8uaXNIMjY0ICYmIG5lZWRzUmJzcFVuZXNjYXBpbmcoZW5jcnlwdGVkRGF0YSkpIHtcbiAgICAgICAgZW5jcnlwdGVkRGF0YSA9IHBhcnNlUmJzcChlbmNyeXB0ZWREYXRhKTtcbiAgICAgICAgY29uc3QgbmV3VWludDggPSBuZXcgVWludDhBcnJheShmcmFtZUhlYWRlci5ieXRlTGVuZ3RoICsgZW5jcnlwdGVkRGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgbmV3VWludDguc2V0KGZyYW1lSGVhZGVyKTtcbiAgICAgICAgbmV3VWludDguc2V0KGVuY3J5cHRlZERhdGEsIGZyYW1lSGVhZGVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICBlbmNvZGVkRnJhbWUuZGF0YSA9IG5ld1VpbnQ4LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZnJhbWVUcmFpbGVyID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEZyYW1lLmRhdGEsIGVuY29kZWRGcmFtZS5kYXRhLmJ5dGVMZW5ndGggLSAyLCAyKTtcblxuICAgICAgY29uc3QgaXZMZW5ndGggPSBmcmFtZVRyYWlsZXJbMF07XG4gICAgICBjb25zdCBpdiA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICBlbmNvZGVkRnJhbWUuZGF0YSxcbiAgICAgICAgZW5jb2RlZEZyYW1lLmRhdGEuYnl0ZUxlbmd0aCAtIGl2TGVuZ3RoIC0gZnJhbWVUcmFpbGVyLmJ5dGVMZW5ndGgsXG4gICAgICAgIGl2TGVuZ3RoLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgY2lwaGVyVGV4dFN0YXJ0ID0gZnJhbWVIZWFkZXIuYnl0ZUxlbmd0aDtcbiAgICAgIGNvbnN0IGNpcGhlclRleHRMZW5ndGggPVxuICAgICAgICBlbmNvZGVkRnJhbWUuZGF0YS5ieXRlTGVuZ3RoIC1cbiAgICAgICAgKGZyYW1lSGVhZGVyLmJ5dGVMZW5ndGggKyBpdkxlbmd0aCArIGZyYW1lVHJhaWxlci5ieXRlTGVuZ3RoKTtcblxuICAgICAgY29uc3QgcGxhaW5UZXh0ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kZWNyeXB0KFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogRU5DUllQVElPTl9BTEdPUklUSE0sXG4gICAgICAgICAgaXYsXG4gICAgICAgICAgYWRkaXRpb25hbERhdGE6IG5ldyBVaW50OEFycmF5KGVuY29kZWRGcmFtZS5kYXRhLCAwLCBmcmFtZUhlYWRlci5ieXRlTGVuZ3RoKSxcbiAgICAgICAgfSxcbiAgICAgICAgcmF0Y2hldE9wdHMuZW5jcnlwdGlvbktleSA/PyBrZXlTZXQhLmVuY3J5cHRpb25LZXksXG4gICAgICAgIG5ldyBVaW50OEFycmF5KGVuY29kZWRGcmFtZS5kYXRhLCBjaXBoZXJUZXh0U3RhcnQsIGNpcGhlclRleHRMZW5ndGgpLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgbmV3RGF0YSA9IG5ldyBBcnJheUJ1ZmZlcihmcmFtZUhlYWRlci5ieXRlTGVuZ3RoICsgcGxhaW5UZXh0LmJ5dGVMZW5ndGgpO1xuICAgICAgY29uc3QgbmV3VWludDggPSBuZXcgVWludDhBcnJheShuZXdEYXRhKTtcblxuICAgICAgbmV3VWludDguc2V0KG5ldyBVaW50OEFycmF5KGVuY29kZWRGcmFtZS5kYXRhLCAwLCBmcmFtZUhlYWRlci5ieXRlTGVuZ3RoKSk7XG4gICAgICBuZXdVaW50OC5zZXQobmV3IFVpbnQ4QXJyYXkocGxhaW5UZXh0KSwgZnJhbWVIZWFkZXIuYnl0ZUxlbmd0aCk7XG5cbiAgICAgIGVuY29kZWRGcmFtZS5kYXRhID0gbmV3RGF0YTtcblxuICAgICAgcmV0dXJuIGVuY29kZWRGcmFtZTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBpZiAodGhpcy5rZXlQcm92aWRlck9wdGlvbnMucmF0Y2hldFdpbmRvd1NpemUgPiAwKSB7XG4gICAgICAgIGlmIChyYXRjaGV0T3B0cy5yYXRjaGV0Q291bnQgPCB0aGlzLmtleVByb3ZpZGVyT3B0aW9ucy5yYXRjaGV0V2luZG93U2l6ZSkge1xuICAgICAgICAgIHdvcmtlckxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgIGByYXRjaGV0aW5nIGtleSBhdHRlbXB0ICR7cmF0Y2hldE9wdHMucmF0Y2hldENvdW50fSBvZiAke1xuICAgICAgICAgICAgICB0aGlzLmtleVByb3ZpZGVyT3B0aW9ucy5yYXRjaGV0V2luZG93U2l6ZVxuICAgICAgICAgICAgfSwgZm9yIGtpbmQgJHtlbmNvZGVkRnJhbWUgaW5zdGFuY2VvZiBSVENFbmNvZGVkQXVkaW9GcmFtZSA/ICdhdWRpbycgOiAndmlkZW8nfWAsXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGxldCByYXRjaGV0ZWRLZXlTZXQ6IEtleVNldCB8IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoKGluaXRpYWxNYXRlcmlhbCA/PyBrZXlTZXQpID09PSB0aGlzLmtleXMuZ2V0S2V5U2V0KGtleUluZGV4KSkge1xuICAgICAgICAgICAgLy8gb25seSByYXRjaGV0IGlmIHRoZSBjdXJyZW50bHkgc2V0IGtleSBpcyBzdGlsbCB0aGUgc2FtZSBhcyB0aGUgb25lIHVzZWQgdG8gZGVjcnlwdCB0aGlzIGZyYW1lXG4gICAgICAgICAgICAvLyBpZiBub3QsIGl0IG1pZ2h0IGJlIHRoYXQgYSBkaWZmZXJlbnQgZnJhbWUgaGFzIGFscmVhZHkgcmF0Y2hldGVkIGFuZCB3ZSB0cnkgd2l0aCB0aGF0IG9uZSBmaXJzdFxuICAgICAgICAgICAgY29uc3QgbmV3TWF0ZXJpYWwgPSBhd2FpdCB0aGlzLmtleXMucmF0Y2hldEtleShrZXlJbmRleCwgZmFsc2UpO1xuXG4gICAgICAgICAgICByYXRjaGV0ZWRLZXlTZXQgPSBhd2FpdCBkZXJpdmVLZXlzKG5ld01hdGVyaWFsLCB0aGlzLmtleVByb3ZpZGVyT3B0aW9ucy5yYXRjaGV0U2FsdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZnJhbWUgPSBhd2FpdCB0aGlzLmRlY3J5cHRGcmFtZShlbmNvZGVkRnJhbWUsIGtleUluZGV4LCBpbml0aWFsTWF0ZXJpYWwgfHwga2V5U2V0LCB7XG4gICAgICAgICAgICByYXRjaGV0Q291bnQ6IHJhdGNoZXRPcHRzLnJhdGNoZXRDb3VudCArIDEsXG4gICAgICAgICAgICBlbmNyeXB0aW9uS2V5OiByYXRjaGV0ZWRLZXlTZXQ/LmVuY3J5cHRpb25LZXksXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGZyYW1lICYmIHJhdGNoZXRlZEtleVNldCkge1xuICAgICAgICAgICAgLy8gYmVmb3JlIHVwZGF0aW5nIHRoZSBrZXlzLCBtYWtlIHN1cmUgdGhhdCB0aGUga2V5U2V0IHVzZWQgZm9yIHRoaXMgZnJhbWUgaXMgc3RpbGwgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRseSBzZXQga2V5XG4gICAgICAgICAgICAvLyBpZiBpdCdzIG5vdCwgYSBuZXcga2V5IG1pZ2h0IGhhdmUgYmVlbiBzZXQgYWxyZWFkeSwgd2hpY2ggd2UgZG9uJ3Qgd2FudCB0byBvdmVycmlkZVxuICAgICAgICAgICAgaWYgKChpbml0aWFsTWF0ZXJpYWwgPz8ga2V5U2V0KSA9PT0gdGhpcy5rZXlzLmdldEtleVNldChrZXlJbmRleCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5rZXlzLnNldEtleVNldChyYXRjaGV0ZWRLZXlTZXQsIGtleUluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgICAgLy8gZGVjcnlwdGlvbiB3YXMgc3VjY2Vzc2Z1bCwgc2V0IHRoZSBuZXcga2V5IGluZGV4IHRvIHJlZmxlY3QgdGhlIHJhdGNoZXRlZCBrZXkgc2V0XG4gICAgICAgICAgICAgIHRoaXMua2V5cy5zZXRDdXJyZW50S2V5SW5kZXgoa2V5SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQmVjYXVzZSB3ZSBvbmx5IHNldCBhIG5ldyBrZXkgb25jZSBkZWNyeXB0aW9uIGhhcyBiZWVuIHN1Y2Nlc3NmdWwsXG4gICAgICAgICAgICogd2UgY2FuIGJlIHN1cmUgdGhhdCB3ZSBkb24ndCBuZWVkIHRvIHJlc2V0IHRoZSBrZXkgdG8gdGhlIGluaXRpYWwgbWF0ZXJpYWwgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAqIGFzIHRoZSBrZXkgaGFzIG5vdCBiZWVuIHVwZGF0ZWQgb24gdGhlIGtleUhhbmRsZXIgaW5zdGFuY2VcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIHdvcmtlckxvZ2dlci53YXJuKCdtYXhpbXVtIHJhdGNoZXQgYXR0ZW1wdHMgZXhjZWVkZWQnKTtcbiAgICAgICAgICB0aHJvdyBuZXcgQ3J5cHRvckVycm9yKFxuICAgICAgICAgICAgYHZhbGlkIGtleSBtaXNzaW5nIGZvciBwYXJ0aWNpcGFudCAke3RoaXMucGFydGljaXBhbnRJZGVudGl0eX1gLFxuICAgICAgICAgICAgQ3J5cHRvckVycm9yUmVhc29uLkludmFsaWRLZXksXG4gICAgICAgICAgICB0aGlzLnBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IENyeXB0b3JFcnJvcihcbiAgICAgICAgICBgRGVjcnlwdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICAgIENyeXB0b3JFcnJvclJlYXNvbi5JbnZhbGlkS2V5LFxuICAgICAgICAgIHRoaXMucGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IHRoZSBJViB1c2VkIGZvciBBRVMtR0NNIGFuZCBzZW50IChpbiBwbGFpbikgd2l0aCB0aGUgcGFja2V0IHNpbWlsYXIgdG9cbiAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc3MTQjc2VjdGlvbi04LjFcbiAgICogSXQgY29uY2F0ZW5hdGVzXG4gICAqIC0gdGhlIDMyIGJpdCBzeW5jaHJvbml6YXRpb24gc291cmNlIChTU1JDKSBnaXZlbiBvbiB0aGUgZW5jb2RlZCBmcmFtZSxcbiAgICogLSB0aGUgMzIgYml0IHJ0cCB0aW1lc3RhbXAgZ2l2ZW4gb24gdGhlIGVuY29kZWQgZnJhbWUsXG4gICAqIC0gYSBzZW5kIGNvdW50ZXIgdGhhdCBpcyBzcGVjaWZpYyB0byB0aGUgU1NSQy4gU3RhcnRzIGF0IGEgcmFuZG9tIG51bWJlci5cbiAgICogVGhlIHNlbmQgY291bnRlciBpcyBlc3NlbnRpYWxseSB0aGUgcGljdHVyZUlkIGJ1dCB3ZSBjdXJyZW50bHkgaGF2ZSB0byBpbXBsZW1lbnQgdGhpcyBvdXJzZWx2ZXMuXG4gICAqIFRoZXJlIGlzIG5vIFhPUiB3aXRoIGEgc2FsdC4gTm90ZSB0aGF0IHRoaXMgSVYgbGVha3MgdGhlIFNTUkMgdG8gdGhlIHJlY2VpdmVyIGJ1dCBzaW5jZSB0aGlzIGlzXG4gICAqIHJhbmRvbWx5IGdlbmVyYXRlZCBhbmQgU0ZVcyBtYXkgbm90IHJld3JpdGUgdGhpcyBpcyBjb25zaWRlcmVkIGFjY2VwdGFibGUuXG4gICAqIFRoZSBTU1JDIGlzIHVzZWQgdG8gYWxsb3cgZGVtdWx0aXBsZXhpbmcgbXVsdGlwbGUgc3RyZWFtcyB3aXRoIHRoZSBzYW1lIGtleSwgYXMgZGVzY3JpYmVkIGluXG4gICAqICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM3MTEjc2VjdGlvbi00LjEuMVxuICAgKiBUaGUgUlRQIHRpbWVzdGFtcCBpcyAzMiBiaXRzIGFuZCBhZHZhbmNlcyBieSB0aGUgY29kZWMgY2xvY2sgcmF0ZSAoOTBraHogZm9yIHZpZGVvLCA0OGtoeiBmb3JcbiAgICogb3B1cyBhdWRpbykgZXZlcnkgc2Vjb25kLiBGb3IgdmlkZW8gaXQgcm9sbHMgb3ZlciByb3VnaGx5IGV2ZXJ5IDEzIGhvdXJzLlxuICAgKiBUaGUgc2VuZCBjb3VudGVyIHdpbGwgYWR2YW5jZSBhdCB0aGUgZnJhbWUgcmF0ZSAoMzBmcHMgZm9yIHZpZGVvLCA1MGZwcyBmb3IgMjBtcyBvcHVzIGF1ZGlvKVxuICAgKiBldmVyeSBzZWNvbmQuIEl0IHdpbGwgdGFrZSBhIGxvbmcgdGltZSB0byByb2xsIG92ZXIuXG4gICAqXG4gICAqIFNlZSBhbHNvIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BZXNHY21QYXJhbXNcbiAgICovXG4gIHByaXZhdGUgbWFrZUlWKHN5bmNocm9uaXphdGlvblNvdXJjZTogbnVtYmVyLCB0aW1lc3RhbXA6IG51bWJlcikge1xuICAgIGNvbnN0IGl2ID0gbmV3IEFycmF5QnVmZmVyKElWX0xFTkdUSCk7XG4gICAgY29uc3QgaXZWaWV3ID0gbmV3IERhdGFWaWV3KGl2KTtcblxuICAgIC8vIGhhdmluZyB0byBrZWVwIG91ciBvd24gc2VuZCBjb3VudCAoc2ltaWxhciB0byBhIHBpY3R1cmUgaWQpIGlzIG5vdCBpZGVhbC5cbiAgICBpZiAoIXRoaXMuc2VuZENvdW50cy5oYXMoc3luY2hyb25pemF0aW9uU291cmNlKSkge1xuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIGEgcmFuZG9tIG9mZnNldCwgc2ltaWxhciB0byB0aGUgUlRQIHNlcXVlbmNlIG51bWJlci5cbiAgICAgIHRoaXMuc2VuZENvdW50cy5zZXQoc3luY2hyb25pemF0aW9uU291cmNlLCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweGZmZmYpKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZW5kQ291bnQgPSB0aGlzLnNlbmRDb3VudHMuZ2V0KHN5bmNocm9uaXphdGlvblNvdXJjZSkgPz8gMDtcblxuICAgIGl2Vmlldy5zZXRVaW50MzIoMCwgc3luY2hyb25pemF0aW9uU291cmNlKTtcbiAgICBpdlZpZXcuc2V0VWludDMyKDQsIHRpbWVzdGFtcCk7XG4gICAgaXZWaWV3LnNldFVpbnQzMig4LCB0aW1lc3RhbXAgLSAoc2VuZENvdW50ICUgMHhmZmZmKSk7XG5cbiAgICB0aGlzLnNlbmRDb3VudHMuc2V0KHN5bmNocm9uaXphdGlvblNvdXJjZSwgc2VuZENvdW50ICsgMSk7XG5cbiAgICByZXR1cm4gaXY7XG4gIH1cblxuICBwcml2YXRlIGdldFVuZW5jcnlwdGVkQnl0ZXMoZnJhbWU6IFJUQ0VuY29kZWRWaWRlb0ZyYW1lIHwgUlRDRW5jb2RlZEF1ZGlvRnJhbWUpOiB7XG4gICAgdW5lbmNyeXB0ZWRCeXRlczogbnVtYmVyO1xuICAgIGlzSDI2NDogYm9vbGVhbjtcbiAgfSB7XG4gICAgdmFyIGZyYW1lSW5mbyA9IHsgdW5lbmNyeXB0ZWRCeXRlczogMCwgaXNIMjY0OiBmYWxzZSB9O1xuICAgIGlmIChpc1ZpZGVvRnJhbWUoZnJhbWUpKSB7XG4gICAgICBsZXQgZGV0ZWN0ZWRDb2RlYyA9IHRoaXMuZ2V0VmlkZW9Db2RlYyhmcmFtZSkgPz8gdGhpcy52aWRlb0NvZGVjO1xuICAgICAgaWYgKGRldGVjdGVkQ29kZWMgIT09IHRoaXMuZGV0ZWN0ZWRDb2RlYykge1xuICAgICAgICB3b3JrZXJMb2dnZXIuZGVidWcoJ2RldGVjdGVkIGRpZmZlcmVudCBjb2RlYycsIHtcbiAgICAgICAgICBkZXRlY3RlZENvZGVjLFxuICAgICAgICAgIG9sZENvZGVjOiB0aGlzLmRldGVjdGVkQ29kZWMsXG4gICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZXRlY3RlZENvZGVjID0gZGV0ZWN0ZWRDb2RlYztcbiAgICAgIH1cblxuICAgICAgaWYgKGRldGVjdGVkQ29kZWMgPT09ICdhdjEnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtkZXRlY3RlZENvZGVjfSBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgZW5kIHRvIGVuZCBlbmNyeXB0aW9uYCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZXRlY3RlZENvZGVjID09PSAndnA4Jykge1xuICAgICAgICBmcmFtZUluZm8udW5lbmNyeXB0ZWRCeXRlcyA9IFVORU5DUllQVEVEX0JZVEVTW2ZyYW1lLnR5cGVdO1xuICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZENvZGVjID09PSAndnA5Jykge1xuICAgICAgICBmcmFtZUluZm8udW5lbmNyeXB0ZWRCeXRlcyA9IDA7XG4gICAgICAgIHJldHVybiBmcmFtZUluZm87XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShmcmFtZS5kYXRhKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5hbHVJbmRpY2VzID0gZmluZE5BTFVJbmRpY2VzKGRhdGEpO1xuXG4gICAgICAgIC8vIGlmIHRoZSBkZXRlY3RlZCBjb2RlYyBpcyB1bmRlZmluZWQgd2UgdGVzdCB3aGV0aGVyIGl0IF9sb29rc18gbGlrZSBhIGgyNjQgZnJhbWUgYXMgYSBiZXN0IGd1ZXNzXG4gICAgICAgIGZyYW1lSW5mby5pc0gyNjQgPVxuICAgICAgICAgIGRldGVjdGVkQ29kZWMgPT09ICdoMjY0JyB8fFxuICAgICAgICAgIG5hbHVJbmRpY2VzLnNvbWUoKG5hbHVJbmRleCkgPT5cbiAgICAgICAgICAgIFtOQUxVVHlwZS5TTElDRV9JRFIsIE5BTFVUeXBlLlNMSUNFX05PTl9JRFJdLmluY2x1ZGVzKHBhcnNlTkFMVVR5cGUoZGF0YVtuYWx1SW5kZXhdKSksXG4gICAgICAgICAgKTtcblxuICAgICAgICBpZiAoZnJhbWVJbmZvLmlzSDI2NCkge1xuICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgbmFsdUluZGljZXMpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gcGFyc2VOQUxVVHlwZShkYXRhW2luZGV4XSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBOQUxVVHlwZS5TTElDRV9JRFI6XG4gICAgICAgICAgICAgIGNhc2UgTkFMVVR5cGUuU0xJQ0VfTk9OX0lEUjpcbiAgICAgICAgICAgICAgICBmcmFtZUluZm8udW5lbmNyeXB0ZWRCeXRlcyA9IGluZGV4ICsgMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWVJbmZvO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb3VsZCBub3QgZmluZCBOQUxVJyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbm8gb3AsIHdlIGp1c3QgY29udGludWUgYW5kIGZhbGxiYWNrIHRvIHZwOFxuICAgICAgfVxuXG4gICAgICBmcmFtZUluZm8udW5lbmNyeXB0ZWRCeXRlcyA9IFVORU5DUllQVEVEX0JZVEVTW2ZyYW1lLnR5cGVdO1xuICAgICAgcmV0dXJuIGZyYW1lSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhbWVJbmZvLnVuZW5jcnlwdGVkQnl0ZXMgPSBVTkVOQ1JZUFRFRF9CWVRFUy5hdWRpbztcbiAgICAgIHJldHVybiBmcmFtZUluZm87XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGluc3BlY3RzIGZyYW1lIHBheWxvYWR0eXBlIGlmIGF2YWlsYWJsZSBhbmQgbWFwcyBpdCB0byB0aGUgY29kZWMgc3BlY2lmaWVkIGluIHJ0cE1hcFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRWaWRlb0NvZGVjKGZyYW1lOiBSVENFbmNvZGVkVmlkZW9GcmFtZSk6IFZpZGVvQ29kZWMgfCB1bmRlZmluZWQge1xuICAgIGlmICh0aGlzLnJ0cE1hcC5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBwYXlsb2FkVHlwZSA9IGZyYW1lLmdldE1ldGFkYXRhKCkucGF5bG9hZFR5cGU7XG4gICAgY29uc3QgY29kZWMgPSBwYXlsb2FkVHlwZSA/IHRoaXMucnRwTWFwLmdldChwYXlsb2FkVHlwZSkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGNvZGVjO1xuICB9XG59XG5cbi8qKlxuICogU2xpY2UgdGhlIE5BTFVzIHByZXNlbnQgaW4gdGhlIHN1cHBsaWVkIGJ1ZmZlciwgYXNzdW1pbmcgaXQgaXMgYWxyZWFkeSBieXRlLWFsaWduZWRcbiAqIGNvZGUgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRvb3plL2gyNjQtZnJhbWUtcGFyc2VyL2Jsb2IvbWFpbi9saWIvTmFsVW5pdHMudHMgdG8gcmV0dXJuIGluZGljZXMgb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE5BTFVJbmRpY2VzKHN0cmVhbTogVWludDhBcnJheSk6IG51bWJlcltdIHtcbiAgY29uc3QgcmVzdWx0OiBudW1iZXJbXSA9IFtdO1xuICBsZXQgc3RhcnQgPSAwLFxuICAgIHBvcyA9IDAsXG4gICAgc2VhcmNoTGVuZ3RoID0gc3RyZWFtLmxlbmd0aCAtIDI7XG4gIHdoaWxlIChwb3MgPCBzZWFyY2hMZW5ndGgpIHtcbiAgICAvLyBza2lwIHVudGlsIGVuZCBvZiBjdXJyZW50IE5BTFVcbiAgICB3aGlsZSAoXG4gICAgICBwb3MgPCBzZWFyY2hMZW5ndGggJiZcbiAgICAgICEoc3RyZWFtW3Bvc10gPT09IDAgJiYgc3RyZWFtW3BvcyArIDFdID09PSAwICYmIHN0cmVhbVtwb3MgKyAyXSA9PT0gMSlcbiAgICApXG4gICAgICBwb3MrKztcbiAgICBpZiAocG9zID49IHNlYXJjaExlbmd0aCkgcG9zID0gc3RyZWFtLmxlbmd0aDtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb3MgZnJvbSBjdXJyZW50IE5BTFVcbiAgICBsZXQgZW5kID0gcG9zO1xuICAgIHdoaWxlIChlbmQgPiBzdGFydCAmJiBzdHJlYW1bZW5kIC0gMV0gPT09IDApIGVuZC0tO1xuICAgIC8vIHNhdmUgY3VycmVudCBOQUxVXG4gICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICBpZiAoZW5kICE9PSBzdGFydCkgdGhyb3cgVHlwZUVycm9yKCdieXRlIHN0cmVhbSBjb250YWlucyBsZWFkaW5nIGRhdGEnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2goc3RhcnQpO1xuICAgIH1cbiAgICAvLyBiZWdpbiBuZXcgTkFMVVxuICAgIHN0YXJ0ID0gcG9zID0gcG9zICsgMztcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VOQUxVVHlwZShzdGFydEJ5dGU6IG51bWJlcik6IE5BTFVUeXBlIHtcbiAgcmV0dXJuIHN0YXJ0Qnl0ZSAmIGtOYWx1VHlwZU1hc2s7XG59XG5cbmNvbnN0IGtOYWx1VHlwZU1hc2sgPSAweDFmO1xuXG5leHBvcnQgZW51bSBOQUxVVHlwZSB7XG4gIC8qKiBDb2RlZCBzbGljZSBvZiBhIG5vbi1JRFIgcGljdHVyZSAqL1xuICBTTElDRV9OT05fSURSID0gMSxcbiAgLyoqIENvZGVkIHNsaWNlIGRhdGEgcGFydGl0aW9uIEEgKi9cbiAgU0xJQ0VfUEFSVElUSU9OX0EgPSAyLFxuICAvKiogQ29kZWQgc2xpY2UgZGF0YSBwYXJ0aXRpb24gQiAqL1xuICBTTElDRV9QQVJUSVRJT05fQiA9IDMsXG4gIC8qKiBDb2RlZCBzbGljZSBkYXRhIHBhcnRpdGlvbiBDICovXG4gIFNMSUNFX1BBUlRJVElPTl9DID0gNCxcbiAgLyoqIENvZGVkIHNsaWNlIG9mIGFuIElEUiBwaWN0dXJlICovXG4gIFNMSUNFX0lEUiA9IDUsXG4gIC8qKiBTdXBwbGVtZW50YWwgZW5oYW5jZW1lbnQgaW5mb3JtYXRpb24gKi9cbiAgU0VJID0gNixcbiAgLyoqIFNlcXVlbmNlIHBhcmFtZXRlciBzZXQgKi9cbiAgU1BTID0gNyxcbiAgLyoqIFBpY3R1cmUgcGFyYW1ldGVyIHNldCAqL1xuICBQUFMgPSA4LFxuICAvKiogQWNjZXNzIHVuaXQgZGVsaW1pdGVyICovXG4gIEFVRCA9IDksXG4gIC8qKiBFbmQgb2Ygc2VxdWVuY2UgKi9cbiAgRU5EX1NFUSA9IDEwLFxuICAvKiogRW5kIG9mIHN0cmVhbSAqL1xuICBFTkRfU1RSRUFNID0gMTEsXG4gIC8qKiBGaWxsZXIgZGF0YSAqL1xuICBGSUxMRVJfREFUQSA9IDEyLFxuICAvKiogU2VxdWVuY2UgcGFyYW1ldGVyIHNldCBleHRlbnNpb24gKi9cbiAgU1BTX0VYVCA9IDEzLFxuICAvKiogUHJlZml4IE5BTCB1bml0ICovXG4gIFBSRUZJWF9OQUxVID0gMTQsXG4gIC8qKiBTdWJzZXQgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCAqL1xuICBTVUJTRVRfU1BTID0gMTUsXG4gIC8qKiBEZXB0aCBwYXJhbWV0ZXIgc2V0ICovXG4gIERQUyA9IDE2LFxuXG4gIC8vIDE3LCAxOCByZXNlcnZlZFxuXG4gIC8qKiBDb2RlZCBzbGljZSBvZiBhbiBhdXhpbGlhcnkgY29kZWQgcGljdHVyZSB3aXRob3V0IHBhcnRpdGlvbmluZyAqL1xuICBTTElDRV9BVVggPSAxOSxcbiAgLyoqIENvZGVkIHNsaWNlIGV4dGVuc2lvbiAqL1xuICBTTElDRV9FWFQgPSAyMCxcbiAgLyoqIENvZGVkIHNsaWNlIGV4dGVuc2lvbiBmb3IgYSBkZXB0aCB2aWV3IGNvbXBvbmVudCBvciBhIDNELUFWQyB0ZXh0dXJlIHZpZXcgY29tcG9uZW50ICovXG4gIFNMSUNFX0xBWUVSX0VYVCA9IDIxLFxuXG4gIC8vIDIyLCAyMyByZXNlcnZlZFxufVxuXG4vKipcbiAqIHdlIHVzZSBhIG1hZ2ljIGZyYW1lIHRyYWlsZXIgdG8gZGV0ZWN0IHdoZXRoZXIgYSBmcmFtZSBpcyBpbmplY3RlZFxuICogYnkgdGhlIGxpdmVraXQgc2VydmVyIGFuZCB0aHVzIHRvIGJlIHRyZWF0ZWQgYXMgdW5lbmNyeXB0ZWRcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGcmFtZVNlcnZlckluamVjdGVkKGZyYW1lRGF0YTogQXJyYXlCdWZmZXIsIHRyYWlsZXJCeXRlczogVWludDhBcnJheSk6IGJvb2xlYW4ge1xuICBpZiAodHJhaWxlckJ5dGVzLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZnJhbWVUcmFpbGVyID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgZnJhbWVEYXRhLnNsaWNlKGZyYW1lRGF0YS5ieXRlTGVuZ3RoIC0gdHJhaWxlckJ5dGVzLmJ5dGVMZW5ndGgpLFxuICApO1xuICByZXR1cm4gdHJhaWxlckJ5dGVzLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlID09PSBmcmFtZVRyYWlsZXJbaW5kZXhdKTtcbn1cbiIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgdHlwZSBUeXBlZEV2ZW50RW1pdHRlciBmcm9tICd0eXBlZC1lbWl0dGVyJztcbmltcG9ydCB7IHdvcmtlckxvZ2dlciB9IGZyb20gJy4uLy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBLZXlIYW5kbGVyRXZlbnQsIHR5cGUgUGFydGljaXBhbnRLZXlIYW5kbGVyQ2FsbGJhY2tzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgS2V5UHJvdmlkZXJPcHRpb25zLCBLZXlTZXQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBkZXJpdmVLZXlzLCBpbXBvcnRLZXksIHJhdGNoZXQgfSBmcm9tICcuLi91dGlscyc7XG5cbi8vIFRPRE8gUGFydGljaXBhbnRLZXlIYW5kbGVycyBjdXJyZW50bHkgZG9uJ3QgZ2V0IGRlc3Ryb3llZCBvbiBwYXJ0aWNpcGFudCBkaXNjb25uZWN0XG4vLyB3ZSBjb3VsZCBkbyB0aGlzIGJ5IGhhdmluZyBhIHNlcGFyYXRlIHdvcmtlciBtZXNzYWdlIG9uIHBhcnRpY2lwYW50IGRpc2Nvbm5lY3RlZC5cblxuLyoqXG4gKiBQYXJ0aWNpcGFudEtleUhhbmRsZXIgaXMgcmVzcG9uc2libGUgZm9yIHByb3ZpZGluZyBhIGNyeXB0b3IgaW5zdGFuY2Ugd2l0aCB0aGVcbiAqIGVuLS9kZWNyeXB0aW9uIGtleSBvZiBhIHBhcnRpY2lwYW50LiBJdCBhc3N1bWVzIHRoYXQgYWxsIHRyYWNrcyBvZiBhIHNwZWNpZmljIHBhcnRpY2lwYW50XG4gKiBhcmUgZW5jcnlwdGVkIHdpdGggdGhlIHNhbWUga2V5LlxuICogQWRkaXRpb25hbGx5IGl0IGV4cG9zZXMgYSBtZXRob2QgdG8gcmF0Y2hldCBhIGtleSB3aGljaCBjYW4gYmUgdXNlZCBieSB0aGUgY3J5cHRvciBlaXRoZXIgYXV0b21hdGljYWxseVxuICogaWYgZGVjcnlwdGlvbiBmYWlscyBvciBjYW4gYmUgdHJpZ2dlcmVkIG1hbnVhbGx5IG9uIGJvdGggc2VuZGVyIGFuZCByZWNlaXZlciBzaWRlLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFBhcnRpY2lwYW50S2V5SGFuZGxlciBleHRlbmRzIChFdmVudEVtaXR0ZXIgYXMgbmV3ICgpID0+IFR5cGVkRXZlbnRFbWl0dGVyPFBhcnRpY2lwYW50S2V5SGFuZGxlckNhbGxiYWNrcz4pIHtcbiAgcHJpdmF0ZSBjdXJyZW50S2V5SW5kZXg6IG51bWJlcjtcblxuICBwcml2YXRlIGNyeXB0b0tleVJpbmc6IEFycmF5PEtleVNldCB8IHVuZGVmaW5lZD47XG5cbiAgcHJpdmF0ZSBkZWNyeXB0aW9uRmFpbHVyZUNvdW50czogQXJyYXk8bnVtYmVyPjtcblxuICBwcml2YXRlIGtleVByb3ZpZGVyT3B0aW9uczogS2V5UHJvdmlkZXJPcHRpb25zO1xuXG4gIHByaXZhdGUgcmF0Y2hldFByb21pc2VNYXA6IE1hcDxudW1iZXIsIFByb21pc2U8Q3J5cHRvS2V5Pj47XG5cbiAgcHJpdmF0ZSBwYXJ0aWNpcGFudElkZW50aXR5OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHRydWUgaWYgdGhlIGN1cnJlbnQga2V5IGhhcyBub3QgYmVlbiBtYXJrZWQgYXMgaW52YWxpZFxuICAgKi9cbiAgZ2V0IGhhc1ZhbGlkS2V5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5oYXNJbnZhbGlkS2V5QXRJbmRleCh0aGlzLmN1cnJlbnRLZXlJbmRleCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihwYXJ0aWNpcGFudElkZW50aXR5OiBzdHJpbmcsIGtleVByb3ZpZGVyT3B0aW9uczogS2V5UHJvdmlkZXJPcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmN1cnJlbnRLZXlJbmRleCA9IDA7XG4gICAgaWYgKGtleVByb3ZpZGVyT3B0aW9ucy5rZXlyaW5nU2l6ZSA8IDEgfHwga2V5UHJvdmlkZXJPcHRpb25zLmtleXJpbmdTaXplID4gMjU2KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdLZXlyaW5nIHNpemUgbmVlZHMgdG8gYmUgYmV0d2VlbiAxIGFuZCAyNTYnKTtcbiAgICB9XG4gICAgdGhpcy5jcnlwdG9LZXlSaW5nID0gbmV3IEFycmF5KGtleVByb3ZpZGVyT3B0aW9ucy5rZXlyaW5nU2l6ZSkuZmlsbCh1bmRlZmluZWQpO1xuICAgIHRoaXMuZGVjcnlwdGlvbkZhaWx1cmVDb3VudHMgPSBuZXcgQXJyYXkoa2V5UHJvdmlkZXJPcHRpb25zLmtleXJpbmdTaXplKS5maWxsKDApO1xuICAgIHRoaXMua2V5UHJvdmlkZXJPcHRpb25zID0ga2V5UHJvdmlkZXJPcHRpb25zO1xuICAgIHRoaXMucmF0Y2hldFByb21pc2VNYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5wYXJ0aWNpcGFudElkZW50aXR5ID0gcGFydGljaXBhbnRJZGVudGl0eTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGtleSBhdCB0aGUgZ2l2ZW4gaW5kZXggaXMgbWFya2VkIGFzIGludmFsaWQuXG4gICAqXG4gICAqIEBwYXJhbSBrZXlJbmRleCB0aGUgaW5kZXggb2YgdGhlIGtleVxuICAgKi9cbiAgaGFzSW52YWxpZEtleUF0SW5kZXgoa2V5SW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmtleVByb3ZpZGVyT3B0aW9ucy5mYWlsdXJlVG9sZXJhbmNlID49IDAgJiZcbiAgICAgIHRoaXMuZGVjcnlwdGlvbkZhaWx1cmVDb3VudHNba2V5SW5kZXhdID4gdGhpcy5rZXlQcm92aWRlck9wdGlvbnMuZmFpbHVyZVRvbGVyYW5jZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogSW5mb3JtcyB0aGUga2V5IGhhbmRsZXIgdGhhdCBhIGRlY3J5cHRpb24gZmFpbHVyZSBvY2N1cnJlZCBmb3IgYW4gZW5jcnlwdGlvbiBrZXkuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ga2V5SW5kZXggdGhlIGtleSBpbmRleCBmb3Igd2hpY2ggdGhlIGZhaWx1cmUgb2NjdXJyZWQuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGtleSBpbmRleC5cbiAgICovXG4gIGRlY3J5cHRpb25GYWlsdXJlKGtleUluZGV4OiBudW1iZXIgPSB0aGlzLmN1cnJlbnRLZXlJbmRleCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmtleVByb3ZpZGVyT3B0aW9ucy5mYWlsdXJlVG9sZXJhbmNlIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZGVjcnlwdGlvbkZhaWx1cmVDb3VudHNba2V5SW5kZXhdICs9IDE7XG5cbiAgICBpZiAodGhpcy5kZWNyeXB0aW9uRmFpbHVyZUNvdW50c1trZXlJbmRleF0gPiB0aGlzLmtleVByb3ZpZGVyT3B0aW9ucy5mYWlsdXJlVG9sZXJhbmNlKSB7XG4gICAgICB3b3JrZXJMb2dnZXIud2FybihcbiAgICAgICAgYGtleSBmb3IgJHt0aGlzLnBhcnRpY2lwYW50SWRlbnRpdHl9IGF0IGluZGV4ICR7a2V5SW5kZXh9IGlzIGJlaW5nIG1hcmtlZCBhcyBpbnZhbGlkYCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluZm9ybXMgdGhlIGtleSBoYW5kbGVyIHRoYXQgYSBmcmFtZSB3YXMgc3VjY2Vzc2Z1bGx5IGRlY3J5cHRlZCB1c2luZyBhbiBlbmNyeXB0aW9uIGtleS5cbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSBrZXlJbmRleCB0aGUga2V5IGluZGV4IGZvciB3aGljaCB0aGUgc3VjY2VzcyBvY2N1cnJlZC4gRGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQga2V5IGluZGV4LlxuICAgKi9cbiAgZGVjcnlwdGlvblN1Y2Nlc3Moa2V5SW5kZXg6IG51bWJlciA9IHRoaXMuY3VycmVudEtleUluZGV4KTogdm9pZCB7XG4gICAgdGhpcy5yZXNldEtleVN0YXR1cyhrZXlJbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCB0aGlzIGFmdGVyIHVzZXIgaW5pdGlhdGVkIHJhdGNoZXQgb3IgYSBuZXcga2V5IGhhcyBiZWVuIHNldCBpbiBvcmRlciB0byBtYWtlIHN1cmUgdG8gbWFyayBwb3RlbnRpYWxseVxuICAgKiBpbnZhbGlkIGtleXMgYXMgdmFsaWQgYWdhaW5cbiAgICpcbiAgICogQHBhcmFtIGtleUluZGV4IHRoZSBpbmRleCBvZiB0aGUga2V5LiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBrZXkgaW5kZXguXG4gICAqL1xuICByZXNldEtleVN0YXR1cyhrZXlJbmRleD86IG51bWJlcik6IHZvaWQge1xuICAgIGlmIChrZXlJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmRlY3J5cHRpb25GYWlsdXJlQ291bnRzLmZpbGwoMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVjcnlwdGlvbkZhaWx1cmVDb3VudHNba2V5SW5kZXhdID0gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmF0Y2hldHMgdGhlIGN1cnJlbnQga2V5IChvciB0aGUgb25lIGF0IGtleUluZGV4IGlmIHByb3ZpZGVkKSBhbmRcbiAgICogcmV0dXJucyB0aGUgcmF0Y2hldGVkIG1hdGVyaWFsXG4gICAqIGlmIGBzZXRLZXlgIGlzIHRydWUgKGRlZmF1bHQpLCBpdCB3aWxsIGFsc28gc2V0IHRoZSByYXRjaGV0ZWQga2V5IGRpcmVjdGx5IG9uIHRoZSBjcnlwdG8ga2V5IHJpbmdcbiAgICogQHBhcmFtIGtleUluZGV4XG4gICAqIEBwYXJhbSBzZXRLZXlcbiAgICovXG4gIHJhdGNoZXRLZXkoa2V5SW5kZXg/OiBudW1iZXIsIHNldEtleSA9IHRydWUpOiBQcm9taXNlPENyeXB0b0tleT4ge1xuICAgIGNvbnN0IGN1cnJlbnRLZXlJbmRleCA9IGtleUluZGV4ID8/IHRoaXMuZ2V0Q3VycmVudEtleUluZGV4KCk7XG5cbiAgICBjb25zdCBleGlzdGluZ1Byb21pc2UgPSB0aGlzLnJhdGNoZXRQcm9taXNlTWFwLmdldChjdXJyZW50S2V5SW5kZXgpO1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmdQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcmF0Y2hldFByb21pc2UgPSBuZXcgUHJvbWlzZTxDcnlwdG9LZXk+KGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGtleVNldCA9IHRoaXMuZ2V0S2V5U2V0KGN1cnJlbnRLZXlJbmRleCk7XG4gICAgICAgIGlmICgha2V5U2V0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3QgcmF0Y2hldCBrZXkgd2l0aG91dCBhIHZhbGlkIGtleXNldCBvZiBwYXJ0aWNpcGFudCAke3RoaXMucGFydGljaXBhbnRJZGVudGl0eX1gLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudE1hdGVyaWFsID0ga2V5U2V0Lm1hdGVyaWFsO1xuICAgICAgICBjb25zdCBuZXdNYXRlcmlhbCA9IGF3YWl0IGltcG9ydEtleShcbiAgICAgICAgICBhd2FpdCByYXRjaGV0KGN1cnJlbnRNYXRlcmlhbCwgdGhpcy5rZXlQcm92aWRlck9wdGlvbnMucmF0Y2hldFNhbHQpLFxuICAgICAgICAgIGN1cnJlbnRNYXRlcmlhbC5hbGdvcml0aG0ubmFtZSxcbiAgICAgICAgICAnZGVyaXZlJyxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoc2V0S2V5KSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5zZXRLZXlGcm9tTWF0ZXJpYWwobmV3TWF0ZXJpYWwsIGN1cnJlbnRLZXlJbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5lbWl0KFxuICAgICAgICAgICAgS2V5SGFuZGxlckV2ZW50LktleVJhdGNoZXRlZCxcbiAgICAgICAgICAgIG5ld01hdGVyaWFsLFxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICAgICAgY3VycmVudEtleUluZGV4LFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShuZXdNYXRlcmlhbCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMucmF0Y2hldFByb21pc2VNYXAuZGVsZXRlKGN1cnJlbnRLZXlJbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5yYXRjaGV0UHJvbWlzZU1hcC5zZXQoY3VycmVudEtleUluZGV4LCByYXRjaGV0UHJvbWlzZSk7XG4gICAgcmV0dXJuIHJhdGNoZXRQcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIHRha2VzIGluIGEga2V5IG1hdGVyaWFsIHdpdGggYGRlcml2ZUJpdHNgIGFuZCBgZGVyaXZlS2V5YCBzZXQgYXMga2V5IHVzYWdlc1xuICAgKiBhbmQgZGVyaXZlcyBlbmNyeXB0aW9uIGtleXMgZnJvbSB0aGUgbWF0ZXJpYWwgYW5kIHNldHMgaXQgb24gdGhlIGtleSByaW5nIGJ1ZmZlclxuICAgKiB0b2dldGhlciB3aXRoIHRoZSBtYXRlcmlhbFxuICAgKiBhbHNvIHJlc2V0cyB0aGUgdmFsaWQga2V5IHByb3BlcnR5IGFuZCB1cGRhdGVzIHRoZSBjdXJyZW50S2V5SW5kZXhcbiAgICovXG4gIGFzeW5jIHNldEtleShtYXRlcmlhbDogQ3J5cHRvS2V5LCBrZXlJbmRleCA9IDApIHtcbiAgICBhd2FpdCB0aGlzLnNldEtleUZyb21NYXRlcmlhbChtYXRlcmlhbCwga2V5SW5kZXgpO1xuICAgIHRoaXMucmVzZXRLZXlTdGF0dXMoa2V5SW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIHRha2VzIGluIGEga2V5IG1hdGVyaWFsIHdpdGggYGRlcml2ZUJpdHNgIGFuZCBgZGVyaXZlS2V5YCBzZXQgYXMga2V5IHVzYWdlc1xuICAgKiBhbmQgZGVyaXZlcyBlbmNyeXB0aW9uIGtleXMgZnJvbSB0aGUgbWF0ZXJpYWwgYW5kIHNldHMgaXQgb24gdGhlIGtleSByaW5nIGJ1ZmZlcnNcbiAgICogdG9nZXRoZXIgd2l0aCB0aGUgbWF0ZXJpYWxcbiAgICogYWxzbyB1cGRhdGVzIHRoZSBjdXJyZW50S2V5SW5kZXhcbiAgICovXG4gIGFzeW5jIHNldEtleUZyb21NYXRlcmlhbChtYXRlcmlhbDogQ3J5cHRvS2V5LCBrZXlJbmRleDogbnVtYmVyLCBlbWl0UmF0Y2hldEV2ZW50ID0gZmFsc2UpIHtcbiAgICBjb25zdCBrZXlTZXQgPSBhd2FpdCBkZXJpdmVLZXlzKG1hdGVyaWFsLCB0aGlzLmtleVByb3ZpZGVyT3B0aW9ucy5yYXRjaGV0U2FsdCk7XG4gICAgY29uc3QgbmV3SW5kZXggPSBrZXlJbmRleCA+PSAwID8ga2V5SW5kZXggJSB0aGlzLmNyeXB0b0tleVJpbmcubGVuZ3RoIDogdGhpcy5jdXJyZW50S2V5SW5kZXg7XG4gICAgd29ya2VyTG9nZ2VyLmRlYnVnKGBzZXR0aW5nIG5ldyBrZXkgd2l0aCBpbmRleCAke2tleUluZGV4fWAsIHtcbiAgICAgIHVzYWdlOiBtYXRlcmlhbC51c2FnZXMsXG4gICAgICBhbGdvcml0aG06IG1hdGVyaWFsLmFsZ29yaXRobSxcbiAgICAgIHJhdGNoZXRTYWx0OiB0aGlzLmtleVByb3ZpZGVyT3B0aW9ucy5yYXRjaGV0U2FsdCxcbiAgICB9KTtcbiAgICB0aGlzLnNldEtleVNldChrZXlTZXQsIG5ld0luZGV4LCBlbWl0UmF0Y2hldEV2ZW50KTtcbiAgICBpZiAobmV3SW5kZXggPj0gMCkgdGhpcy5jdXJyZW50S2V5SW5kZXggPSBuZXdJbmRleDtcbiAgfVxuXG4gIHNldEtleVNldChrZXlTZXQ6IEtleVNldCwga2V5SW5kZXg6IG51bWJlciwgZW1pdFJhdGNoZXRFdmVudCA9IGZhbHNlKSB7XG4gICAgdGhpcy5jcnlwdG9LZXlSaW5nW2tleUluZGV4ICUgdGhpcy5jcnlwdG9LZXlSaW5nLmxlbmd0aF0gPSBrZXlTZXQ7XG5cbiAgICBpZiAoZW1pdFJhdGNoZXRFdmVudCkge1xuICAgICAgdGhpcy5lbWl0KEtleUhhbmRsZXJFdmVudC5LZXlSYXRjaGV0ZWQsIGtleVNldC5tYXRlcmlhbCwgdGhpcy5wYXJ0aWNpcGFudElkZW50aXR5LCBrZXlJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc2V0Q3VycmVudEtleUluZGV4KGluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLmN1cnJlbnRLZXlJbmRleCA9IGluZGV4ICUgdGhpcy5jcnlwdG9LZXlSaW5nLmxlbmd0aDtcbiAgICB0aGlzLnJlc2V0S2V5U3RhdHVzKGluZGV4KTtcbiAgfVxuXG4gIGdldEN1cnJlbnRLZXlJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50S2V5SW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyBjdXJyZW50bHkgdXNlZCBLZXlTZXQgb3IgdGhlIG9uZSBhdCBga2V5SW5kZXhgIGlmIHByb3ZpZGVkXG4gICAqIEBwYXJhbSBrZXlJbmRleFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0S2V5U2V0KGtleUluZGV4PzogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY3J5cHRvS2V5UmluZ1trZXlJbmRleCA/PyB0aGlzLmN1cnJlbnRLZXlJbmRleF07XG4gIH1cbn1cbiIsImltcG9ydCB7IHdvcmtlckxvZ2dlciB9IGZyb20gJy4uLy4uL2xvZ2dlcic7XG5pbXBvcnQgdHlwZSB7IFZpZGVvQ29kZWMgfSBmcm9tICcuLi8uLi9yb29tL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHsgQXN5bmNRdWV1ZSB9IGZyb20gJy4uLy4uL3V0aWxzL0FzeW5jUXVldWUnO1xuaW1wb3J0IHsgS0VZX1BST1ZJREVSX0RFRkFVTFRTIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IENyeXB0b3JFcnJvclJlYXNvbiB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBDcnlwdG9yRXZlbnQsIEtleUhhbmRsZXJFdmVudCB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7XG4gIEUyRUVXb3JrZXJNZXNzYWdlLFxuICBFcnJvck1lc3NhZ2UsXG4gIEluaXRBY2ssXG4gIEtleVByb3ZpZGVyT3B0aW9ucyxcbiAgUmF0Y2hldE1lc3NhZ2UsXG4gIFJhdGNoZXRSZXF1ZXN0TWVzc2FnZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgRnJhbWVDcnlwdG9yLCBlbmNyeXB0aW9uRW5hYmxlZE1hcCB9IGZyb20gJy4vRnJhbWVDcnlwdG9yJztcbmltcG9ydCB7IFBhcnRpY2lwYW50S2V5SGFuZGxlciB9IGZyb20gJy4vUGFydGljaXBhbnRLZXlIYW5kbGVyJztcblxuY29uc3QgcGFydGljaXBhbnRDcnlwdG9yczogRnJhbWVDcnlwdG9yW10gPSBbXTtcbmNvbnN0IHBhcnRpY2lwYW50S2V5czogTWFwPHN0cmluZywgUGFydGljaXBhbnRLZXlIYW5kbGVyPiA9IG5ldyBNYXAoKTtcbmxldCBzaGFyZWRLZXlIYW5kbGVyOiBQYXJ0aWNpcGFudEtleUhhbmRsZXIgfCB1bmRlZmluZWQ7XG5sZXQgbWVzc2FnZVF1ZXVlID0gbmV3IEFzeW5jUXVldWUoKTtcblxubGV0IGlzRW5jcnlwdGlvbkVuYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxubGV0IHVzZVNoYXJlZEtleTogYm9vbGVhbiA9IGZhbHNlO1xuXG5sZXQgc2lmVHJhaWxlcjogVWludDhBcnJheSB8IHVuZGVmaW5lZDtcblxubGV0IGtleVByb3ZpZGVyT3B0aW9uczogS2V5UHJvdmlkZXJPcHRpb25zID0gS0VZX1BST1ZJREVSX0RFRkFVTFRTO1xuXG5sZXQgcnRwTWFwOiBNYXA8bnVtYmVyLCBWaWRlb0NvZGVjPiA9IG5ldyBNYXAoKTtcblxud29ya2VyTG9nZ2VyLnNldERlZmF1bHRMZXZlbCgnaW5mbycpO1xuXG5vbm1lc3NhZ2UgPSAoZXYpID0+IHtcbiAgbWVzc2FnZVF1ZXVlLnJ1bihhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBraW5kLCBkYXRhIH06IEUyRUVXb3JrZXJNZXNzYWdlID0gZXYuZGF0YTtcblxuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSAnaW5pdCc6XG4gICAgICAgIHdvcmtlckxvZ2dlci5zZXRMZXZlbChkYXRhLmxvZ2xldmVsKTtcbiAgICAgICAgd29ya2VyTG9nZ2VyLmluZm8oJ3dvcmtlciBpbml0aWFsaXplZCcpO1xuICAgICAgICBrZXlQcm92aWRlck9wdGlvbnMgPSBkYXRhLmtleVByb3ZpZGVyT3B0aW9ucztcbiAgICAgICAgdXNlU2hhcmVkS2V5ID0gISFkYXRhLmtleVByb3ZpZGVyT3B0aW9ucy5zaGFyZWRLZXk7XG4gICAgICAgIC8vIGFja25vd2xlZGdlIGluaXQgc3VjY2Vzc2Z1bFxuICAgICAgICBjb25zdCBhY2tNc2c6IEluaXRBY2sgPSB7XG4gICAgICAgICAga2luZDogJ2luaXRBY2snLFxuICAgICAgICAgIGRhdGE6IHsgZW5hYmxlZDogaXNFbmNyeXB0aW9uRW5hYmxlZCB9LFxuICAgICAgICB9O1xuICAgICAgICBwb3N0TWVzc2FnZShhY2tNc2cpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2VuYWJsZSc6XG4gICAgICAgIHNldEVuY3J5cHRpb25FbmFibGVkKGRhdGEuZW5hYmxlZCwgZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KTtcbiAgICAgICAgd29ya2VyTG9nZ2VyLmluZm8oXG4gICAgICAgICAgYHVwZGF0ZWQgZTJlZSBlbmFibGVkIHN0YXR1cyBmb3IgJHtkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHl9IHRvICR7ZGF0YS5lbmFibGVkfWAsXG4gICAgICAgICk7XG4gICAgICAgIC8vIGFja25vd2xlZGdlIGVuYWJsZSBjYWxsIHN1Y2Nlc3NmdWxcbiAgICAgICAgcG9zdE1lc3NhZ2UoZXYuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGVjb2RlJzpcbiAgICAgICAgbGV0IGNyeXB0b3IgPSBnZXRUcmFja0NyeXB0b3IoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5LCBkYXRhLnRyYWNrSWQpO1xuICAgICAgICBjcnlwdG9yLnNldHVwVHJhbnNmb3JtKFxuICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgZGF0YS5yZWFkYWJsZVN0cmVhbSxcbiAgICAgICAgICBkYXRhLndyaXRhYmxlU3RyZWFtLFxuICAgICAgICAgIGRhdGEudHJhY2tJZCxcbiAgICAgICAgICBkYXRhLmNvZGVjLFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2VuY29kZSc6XG4gICAgICAgIGxldCBwdWJDcnlwdG9yID0gZ2V0VHJhY2tDcnlwdG9yKGRhdGEucGFydGljaXBhbnRJZGVudGl0eSwgZGF0YS50cmFja0lkKTtcbiAgICAgICAgcHViQ3J5cHRvci5zZXR1cFRyYW5zZm9ybShcbiAgICAgICAgICBraW5kLFxuICAgICAgICAgIGRhdGEucmVhZGFibGVTdHJlYW0sXG4gICAgICAgICAgZGF0YS53cml0YWJsZVN0cmVhbSxcbiAgICAgICAgICBkYXRhLnRyYWNrSWQsXG4gICAgICAgICAgZGF0YS5jb2RlYyxcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZXRLZXknOlxuICAgICAgICBpZiAodXNlU2hhcmVkS2V5KSB7XG4gICAgICAgICAgYXdhaXQgc2V0U2hhcmVkS2V5KGRhdGEua2V5LCBkYXRhLmtleUluZGV4KTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICAgICAgICB3b3JrZXJMb2dnZXIuaW5mbyhcbiAgICAgICAgICAgIGBzZXQgcGFydGljaXBhbnQgc2VuZGVyIGtleSAke2RhdGEucGFydGljaXBhbnRJZGVudGl0eX0gaW5kZXggJHtkYXRhLmtleUluZGV4fWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhd2FpdCBnZXRQYXJ0aWNpcGFudEtleUhhbmRsZXIoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KS5zZXRLZXkoZGF0YS5rZXksIGRhdGEua2V5SW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdvcmtlckxvZ2dlci5lcnJvcignbm8gcGFydGljaXBhbnQgSWQgd2FzIHByb3ZpZGVkIGFuZCBzaGFyZWQga2V5IHVzYWdlIGlzIGRpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZW1vdmVUcmFuc2Zvcm0nOlxuICAgICAgICB1bnNldENyeXB0b3JQYXJ0aWNpcGFudChkYXRhLnRyYWNrSWQsIGRhdGEucGFydGljaXBhbnRJZGVudGl0eSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndXBkYXRlQ29kZWMnOlxuICAgICAgICBnZXRUcmFja0NyeXB0b3IoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5LCBkYXRhLnRyYWNrSWQpLnNldFZpZGVvQ29kZWMoZGF0YS5jb2RlYyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2V0UlRQTWFwJzpcbiAgICAgICAgLy8gdGhpcyBpcyBvbmx5IHVzZWQgZm9yIHRoZSBsb2NhbCBwYXJ0aWNpcGFudFxuICAgICAgICBydHBNYXAgPSBkYXRhLm1hcDtcbiAgICAgICAgcGFydGljaXBhbnRDcnlwdG9ycy5mb3JFYWNoKChjcikgPT4ge1xuICAgICAgICAgIGlmIChjci5nZXRQYXJ0aWNpcGFudElkZW50aXR5KCkgPT09IGRhdGEucGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgICAgICAgICAgY3Iuc2V0UnRwTWFwKGRhdGEubWFwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JhdGNoZXRSZXF1ZXN0JzpcbiAgICAgICAgaGFuZGxlUmF0Y2hldFJlcXVlc3QoZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2V0U2lmVHJhaWxlcic6XG4gICAgICAgIGhhbmRsZVNpZlRyYWlsZXIoZGF0YS50cmFpbGVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xufTtcblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmF0Y2hldFJlcXVlc3QoZGF0YTogUmF0Y2hldFJlcXVlc3RNZXNzYWdlWydkYXRhJ10pIHtcbiAgaWYgKHVzZVNoYXJlZEtleSkge1xuICAgIGNvbnN0IGtleUhhbmRsZXIgPSBnZXRTaGFyZWRLZXlIYW5kbGVyKCk7XG4gICAgYXdhaXQga2V5SGFuZGxlci5yYXRjaGV0S2V5KGRhdGEua2V5SW5kZXgpO1xuICAgIGtleUhhbmRsZXIucmVzZXRLZXlTdGF0dXMoKTtcbiAgfSBlbHNlIGlmIChkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICBjb25zdCBrZXlIYW5kbGVyID0gZ2V0UGFydGljaXBhbnRLZXlIYW5kbGVyKGRhdGEucGFydGljaXBhbnRJZGVudGl0eSk7XG4gICAgYXdhaXQga2V5SGFuZGxlci5yYXRjaGV0S2V5KGRhdGEua2V5SW5kZXgpO1xuICAgIGtleUhhbmRsZXIucmVzZXRLZXlTdGF0dXMoKTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrZXJMb2dnZXIuZXJyb3IoXG4gICAgICAnbm8gcGFydGljaXBhbnQgSWQgd2FzIHByb3ZpZGVkIGZvciByYXRjaGV0IHJlcXVlc3QgYW5kIHNoYXJlZCBrZXkgdXNhZ2UgaXMgZGlzYWJsZWQnLFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VHJhY2tDcnlwdG9yKHBhcnRpY2lwYW50SWRlbnRpdHk6IHN0cmluZywgdHJhY2tJZDogc3RyaW5nKSB7XG4gIGxldCBjcnlwdG9ycyA9IHBhcnRpY2lwYW50Q3J5cHRvcnMuZmlsdGVyKChjKSA9PiBjLmdldFRyYWNrSWQoKSA9PT0gdHJhY2tJZCk7XG4gIGlmIChjcnlwdG9ycy5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgZGVidWdJbmZvID0gY3J5cHRvcnNcbiAgICAgIC5tYXAoKGMpID0+IHtcbiAgICAgICAgcmV0dXJuIHsgcGFydGljaXBhbnQ6IGMuZ2V0UGFydGljaXBhbnRJZGVudGl0eSgpIH07XG4gICAgICB9KVxuICAgICAgLmpvaW4oJywnKTtcbiAgICB3b3JrZXJMb2dnZXIuZXJyb3IoXG4gICAgICBgRm91bmQgbXVsdGlwbGUgY3J5cHRvcnMgZm9yIHRoZSBzYW1lIHRyYWNrSUQgJHt0cmFja0lkfS4gdGFyZ2V0IHBhcnRpY2lwYW50OiAke3BhcnRpY2lwYW50SWRlbnRpdHl9IGAsXG4gICAgICB7IHBhcnRpY2lwYW50czogZGVidWdJbmZvIH0sXG4gICAgKTtcbiAgfVxuICBsZXQgY3J5cHRvciA9IGNyeXB0b3JzWzBdO1xuICBpZiAoIWNyeXB0b3IpIHtcbiAgICB3b3JrZXJMb2dnZXIuaW5mbygnY3JlYXRpbmcgbmV3IGNyeXB0b3IgZm9yJywgeyBwYXJ0aWNpcGFudElkZW50aXR5IH0pO1xuICAgIGlmICgha2V5UHJvdmlkZXJPcHRpb25zKSB7XG4gICAgICB0aHJvdyBFcnJvcignTWlzc2luZyBrZXlQcm92aWRlciBvcHRpb25zJyk7XG4gICAgfVxuICAgIGNyeXB0b3IgPSBuZXcgRnJhbWVDcnlwdG9yKHtcbiAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICBrZXlzOiBnZXRQYXJ0aWNpcGFudEtleUhhbmRsZXIocGFydGljaXBhbnRJZGVudGl0eSksXG4gICAgICBrZXlQcm92aWRlck9wdGlvbnMsXG4gICAgICBzaWZUcmFpbGVyLFxuICAgIH0pO1xuICAgIGNyeXB0b3Iuc2V0UnRwTWFwKHJ0cE1hcCk7XG4gICAgc2V0dXBDcnlwdG9yRXJyb3JFdmVudHMoY3J5cHRvcik7XG4gICAgcGFydGljaXBhbnRDcnlwdG9ycy5wdXNoKGNyeXB0b3IpO1xuICB9IGVsc2UgaWYgKHBhcnRpY2lwYW50SWRlbnRpdHkgIT09IGNyeXB0b3IuZ2V0UGFydGljaXBhbnRJZGVudGl0eSgpKSB7XG4gICAgLy8gYXNzaWduIG5ldyBwYXJ0aWNpcGFudCBpZCB0byB0cmFjayBjcnlwdG9yIGFuZCBwYXNzIGluIGNvcnJlY3Qga2V5IGhhbmRsZXJcbiAgICBjcnlwdG9yLnNldFBhcnRpY2lwYW50KHBhcnRpY2lwYW50SWRlbnRpdHksIGdldFBhcnRpY2lwYW50S2V5SGFuZGxlcihwYXJ0aWNpcGFudElkZW50aXR5KSk7XG4gIH1cblxuICByZXR1cm4gY3J5cHRvcjtcbn1cblxuZnVuY3Rpb24gZ2V0UGFydGljaXBhbnRLZXlIYW5kbGVyKHBhcnRpY2lwYW50SWRlbnRpdHk6IHN0cmluZykge1xuICBpZiAodXNlU2hhcmVkS2V5KSB7XG4gICAgcmV0dXJuIGdldFNoYXJlZEtleUhhbmRsZXIoKTtcbiAgfVxuICBsZXQga2V5cyA9IHBhcnRpY2lwYW50S2V5cy5nZXQocGFydGljaXBhbnRJZGVudGl0eSk7XG4gIGlmICgha2V5cykge1xuICAgIGtleXMgPSBuZXcgUGFydGljaXBhbnRLZXlIYW5kbGVyKHBhcnRpY2lwYW50SWRlbnRpdHksIGtleVByb3ZpZGVyT3B0aW9ucyk7XG4gICAga2V5cy5vbihLZXlIYW5kbGVyRXZlbnQuS2V5UmF0Y2hldGVkLCBlbWl0UmF0Y2hldGVkS2V5cyk7XG4gICAgcGFydGljaXBhbnRLZXlzLnNldChwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gZ2V0U2hhcmVkS2V5SGFuZGxlcigpIHtcbiAgaWYgKCFzaGFyZWRLZXlIYW5kbGVyKSB7XG4gICAgd29ya2VyTG9nZ2VyLmRlYnVnKCdjcmVhdGluZyBuZXcgc2hhcmVkIGtleSBoYW5kbGVyJyk7XG4gICAgc2hhcmVkS2V5SGFuZGxlciA9IG5ldyBQYXJ0aWNpcGFudEtleUhhbmRsZXIoJ3NoYXJlZC1rZXknLCBrZXlQcm92aWRlck9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBzaGFyZWRLZXlIYW5kbGVyO1xufVxuXG5mdW5jdGlvbiB1bnNldENyeXB0b3JQYXJ0aWNpcGFudCh0cmFja0lkOiBzdHJpbmcsIHBhcnRpY2lwYW50SWRlbnRpdHk6IHN0cmluZykge1xuICBjb25zdCBjcnlwdG9ycyA9IHBhcnRpY2lwYW50Q3J5cHRvcnMuZmlsdGVyKFxuICAgIChjKSA9PiBjLmdldFBhcnRpY2lwYW50SWRlbnRpdHkoKSA9PT0gcGFydGljaXBhbnRJZGVudGl0eSAmJiBjLmdldFRyYWNrSWQoKSA9PT0gdHJhY2tJZCxcbiAgKTtcbiAgaWYgKGNyeXB0b3JzLmxlbmd0aCA+IDEpIHtcbiAgICB3b3JrZXJMb2dnZXIuZXJyb3IoJ0ZvdW5kIG11bHRpcGxlIGNyeXB0b3JzIGZvciB0aGUgc2FtZSBwYXJ0aWNpcGFudCBhbmQgdHJhY2tJRCBjb21iaW5hdGlvbicsIHtcbiAgICAgIHRyYWNrSWQsXG4gICAgICBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGNyeXB0b3IgPSBjcnlwdG9yc1swXTtcbiAgaWYgKCFjcnlwdG9yKSB7XG4gICAgd29ya2VyTG9nZ2VyLndhcm4oJ0NvdWxkIG5vdCB1bnNldCBwYXJ0aWNpcGFudCBvbiBjcnlwdG9yJywgeyB0cmFja0lkLCBwYXJ0aWNpcGFudElkZW50aXR5IH0pO1xuICB9IGVsc2Uge1xuICAgIGNyeXB0b3IudW5zZXRQYXJ0aWNpcGFudCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldEVuY3J5cHRpb25FbmFibGVkKGVuYWJsZTogYm9vbGVhbiwgcGFydGljaXBhbnRJZGVudGl0eTogc3RyaW5nKSB7XG4gIHdvcmtlckxvZ2dlci5kZWJ1Zyhgc2V0dGluZyBlbmNyeXB0aW9uIGVuYWJsZWQgZm9yIGFsbCB0cmFja3Mgb2YgJHtwYXJ0aWNpcGFudElkZW50aXR5fWAsIHtcbiAgICBlbmFibGUsXG4gIH0pO1xuICBlbmNyeXB0aW9uRW5hYmxlZE1hcC5zZXQocGFydGljaXBhbnRJZGVudGl0eSwgZW5hYmxlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2V0U2hhcmVkS2V5KGtleTogQ3J5cHRvS2V5LCBpbmRleD86IG51bWJlcikge1xuICB3b3JrZXJMb2dnZXIuaW5mbygnc2V0IHNoYXJlZCBrZXknLCB7IGluZGV4IH0pO1xuICBhd2FpdCBnZXRTaGFyZWRLZXlIYW5kbGVyKCkuc2V0S2V5KGtleSwgaW5kZXgpO1xufVxuXG5mdW5jdGlvbiBzZXR1cENyeXB0b3JFcnJvckV2ZW50cyhjcnlwdG9yOiBGcmFtZUNyeXB0b3IpIHtcbiAgY3J5cHRvci5vbihDcnlwdG9yRXZlbnQuRXJyb3IsIChlcnJvcikgPT4ge1xuICAgIGNvbnN0IG1zZzogRXJyb3JNZXNzYWdlID0ge1xuICAgICAga2luZDogJ2Vycm9yJyxcbiAgICAgIGRhdGE6IHsgZXJyb3I6IG5ldyBFcnJvcihgJHtDcnlwdG9yRXJyb3JSZWFzb25bZXJyb3IucmVhc29uXX06ICR7ZXJyb3IubWVzc2FnZX1gKSB9LFxuICAgIH07XG4gICAgcG9zdE1lc3NhZ2UobXNnKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVtaXRSYXRjaGV0ZWRLZXlzKG1hdGVyaWFsOiBDcnlwdG9LZXksIHBhcnRpY2lwYW50SWRlbnRpdHk6IHN0cmluZywga2V5SW5kZXg/OiBudW1iZXIpIHtcbiAgY29uc3QgbXNnOiBSYXRjaGV0TWVzc2FnZSA9IHtcbiAgICBraW5kOiBgcmF0Y2hldEtleWAsXG4gICAgZGF0YToge1xuICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgIGtleUluZGV4LFxuICAgICAgbWF0ZXJpYWwsXG4gICAgfSxcbiAgfTtcbiAgcG9zdE1lc3NhZ2UobXNnKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU2lmVHJhaWxlcih0cmFpbGVyOiBVaW50OEFycmF5KSB7XG4gIHNpZlRyYWlsZXIgPSB0cmFpbGVyO1xuICBwYXJ0aWNpcGFudENyeXB0b3JzLmZvckVhY2goKGMpID0+IHtcbiAgICBjLnNldFNpZlRyYWlsZXIodHJhaWxlcik7XG4gIH0pO1xufVxuXG4vLyBPcGVyYXRpb25zIHVzaW5nIFJUQ1J0cFNjcmlwdFRyYW5zZm9ybS5cbi8vIEB0cy1pZ25vcmVcbmlmIChzZWxmLlJUQ1RyYW5zZm9ybUV2ZW50KSB7XG4gIHdvcmtlckxvZ2dlci5kZWJ1Zygnc2V0dXAgdHJhbnNmb3JtIGV2ZW50Jyk7XG4gIC8vIEB0cy1pZ25vcmVcbiAgc2VsZi5vbnJ0Y3RyYW5zZm9ybSA9IChldmVudDogUlRDVHJhbnNmb3JtRXZlbnQpID0+IHtcbiAgICAvLyBAdHMtaWdub3JlIC50cmFuc2Zvcm1lciBwcm9wZXJ0eSBpcyBwYXJ0IG9mIFJUQ1RyYW5zZm9ybUV2ZW50XG4gICAgY29uc3QgdHJhbnNmb3JtZXIgPSBldmVudC50cmFuc2Zvcm1lcjtcbiAgICB3b3JrZXJMb2dnZXIuZGVidWcoJ3RyYW5zZm9ybWVyJywgdHJhbnNmb3JtZXIpO1xuICAgIC8vIEB0cy1pZ25vcmUgbW9ua2V5IHBhdGNoaW5nIG5vbiBzdGFuZGFyZCBmbGFnXG4gICAgdHJhbnNmb3JtZXIuaGFuZGxlZCA9IHRydWU7XG4gICAgY29uc3QgeyBraW5kLCBwYXJ0aWNpcGFudElkZW50aXR5LCB0cmFja0lkLCBjb2RlYyB9ID0gdHJhbnNmb3JtZXIub3B0aW9ucztcbiAgICBjb25zdCBjcnlwdG9yID0gZ2V0VHJhY2tDcnlwdG9yKHBhcnRpY2lwYW50SWRlbnRpdHksIHRyYWNrSWQpO1xuICAgIHdvcmtlckxvZ2dlci5kZWJ1ZygndHJhbnNmb3JtJywgeyBjb2RlYyB9KTtcbiAgICBjcnlwdG9yLnNldHVwVHJhbnNmb3JtKGtpbmQsIHRyYW5zZm9ybWVyLnJlYWRhYmxlLCB0cmFuc2Zvcm1lci53cml0YWJsZSwgdHJhY2tJZCwgY29kZWMpO1xuICB9O1xufVxuIl0sIm5hbWVzIjpbInJvb3QiLCJkZWZpbml0aW9uIiwibW9kdWxlIiwiZXhwb3J0cyIsImxvZyIsInRoaXMiLCJub29wIiwidW5kZWZpbmVkVHlwZSIsImlzSUUiLCJ3aW5kb3ciLCJuYXZpZ2F0b3IiLCJ0ZXN0IiwidXNlckFnZW50IiwibG9nTWV0aG9kcyIsIl9sb2dnZXJzQnlOYW1lIiwiZGVmYXVsdExvZ2dlciIsImJpbmRNZXRob2QiLCJvYmoiLCJtZXRob2ROYW1lIiwibWV0aG9kIiwiYmluZCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiY2FsbCIsImUiLCJhcHBseSIsImFyZ3VtZW50cyIsInRyYWNlRm9ySUUiLCJjb25zb2xlIiwidHJhY2UiLCJyZWFsTWV0aG9kIiwidW5kZWZpbmVkIiwicmVwbGFjZUxvZ2dpbmdNZXRob2RzIiwibGV2ZWwiLCJnZXRMZXZlbCIsImkiLCJsZW5ndGgiLCJtZXRob2RGYWN0b3J5IiwibmFtZSIsImRlYnVnIiwibGV2ZWxzIiwiU0lMRU5UIiwiZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyIsImRlZmF1bHRNZXRob2RGYWN0b3J5IiwiX2xldmVsIiwiX2xvZ2dlck5hbWUiLCJMb2dnZXIiLCJmYWN0b3J5Iiwic2VsZiIsImluaGVyaXRlZExldmVsIiwiZGVmYXVsdExldmVsIiwidXNlckxldmVsIiwic3RvcmFnZUtleSIsInBlcnNpc3RMZXZlbElmUG9zc2libGUiLCJsZXZlbE51bSIsImxldmVsTmFtZSIsInRvVXBwZXJDYXNlIiwibG9jYWxTdG9yYWdlIiwiaWdub3JlIiwiZG9jdW1lbnQiLCJjb29raWUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJnZXRQZXJzaXN0ZWRMZXZlbCIsInN0b3JlZExldmVsIiwiY29va2llTmFtZSIsImxvY2F0aW9uIiwiaW5kZXhPZiIsImV4ZWMiLCJzbGljZSIsImNsZWFyUGVyc2lzdGVkTGV2ZWwiLCJyZW1vdmVJdGVtIiwibm9ybWFsaXplTGV2ZWwiLCJpbnB1dCIsIlR5cGVFcnJvciIsInNldExldmVsIiwicGVyc2lzdCIsInNldERlZmF1bHRMZXZlbCIsInJlc2V0TGV2ZWwiLCJlbmFibGVBbGwiLCJUUkFDRSIsImRpc2FibGVBbGwiLCJyZWJ1aWxkIiwiY2hpbGROYW1lIiwiaW5pdGlhbExldmVsIiwiZ2V0TG9nZ2VyIiwibG9nZ2VyIiwiX2xvZyIsIm5vQ29uZmxpY3QiLCJnZXRMb2dnZXJzIiwiTG9nTGV2ZWwiLCJMb2dnZXJOYW1lcyIsImxpdmVraXRMb2dnZXIiLCJPYmplY3QiLCJ2YWx1ZXMiLCJtYXAiLCJpbmZvIiwid29ya2VyTG9nZ2VyIiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwibXNnIiwiRXJyb3IiLCJGTE9BVDMyX01BWCIsIkZMT0FUMzJfTUlOIiwiVUlOVDMyX01BWCIsIklOVDMyX01BWCIsIklOVDMyX01JTiIsImFzc2VydEludDMyIiwiYXJnIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiYXNzZXJ0VUludDMyIiwiYXNzZXJ0RmxvYXQzMiIsImlzRmluaXRlIiwiZW51bVR5cGVTeW1ib2wiLCJTeW1ib2wiLCJnZXRFbnVtVHlwZSIsImVudW1PYmplY3QiLCJ0Iiwic2V0RW51bVR5cGUiLCJ0eXBlTmFtZSIsIm9wdCIsIm1ha2VFbnVtVHlwZSIsInYiLCJubyIsImxvY2FsTmFtZSIsIl9vcHQiLCJuYW1lcyIsImNyZWF0ZSIsIm51bWJlcnMiLCJub3JtYWxWYWx1ZXMiLCJ2YWx1ZSIsIm4iLCJub3JtYWxpemVFbnVtVmFsdWUiLCJwdXNoIiwiZmluZE5hbWUiLCJmaW5kTnVtYmVyIiwibWFrZUVudW0iLCJhc3NpZ24iLCJNZXNzYWdlIiwiZXF1YWxzIiwib3RoZXIiLCJnZXRUeXBlIiwicnVudGltZSIsInV0aWwiLCJjbG9uZSIsImZyb21CaW5hcnkiLCJieXRlcyIsIm9wdGlvbnMiLCJ0eXBlIiwiZm9ybWF0IiwiYmluIiwibWFrZVJlYWRPcHRpb25zIiwicmVhZE1lc3NhZ2UiLCJyZWFkZXJGYWN0b3J5IiwiYnl0ZUxlbmd0aCIsImZyb21Kc29uIiwianNvblZhbHVlIiwianNvbiIsImZyb21Kc29uU3RyaW5nIiwianNvblN0cmluZyIsIkpTT04iLCJwYXJzZSIsImNvbmNhdCIsIm1lc3NhZ2UiLCJTdHJpbmciLCJ0b0JpbmFyeSIsIm1ha2VXcml0ZU9wdGlvbnMiLCJ3cml0ZXIiLCJ3cml0ZXJGYWN0b3J5Iiwid3JpdGVNZXNzYWdlIiwiZmluaXNoIiwidG9Kc29uIiwidG9Kc29uU3RyaW5nIiwiX2EiLCJzdHJpbmdpZnkiLCJwcmV0dHlTcGFjZXMiLCJ0b0pTT04iLCJlbWl0RGVmYXVsdFZhbHVlcyIsImdldFByb3RvdHlwZU9mIiwiY29uc3RydWN0b3IiLCJtYWtlTWVzc2FnZVR5cGUiLCJmaWVsZHMiLCJzdWJzdHJpbmciLCJsYXN0SW5kZXhPZiIsImRhdGEiLCJpbml0RmllbGRzIiwiaW5pdFBhcnRpYWwiLCJzZXRQcm90b3R5cGVPZiIsIm5ld0ZpZWxkTGlzdCIsImEiLCJiIiwidmFyaW50NjRyZWFkIiwibG93Qml0cyIsImhpZ2hCaXRzIiwic2hpZnQiLCJidWYiLCJwb3MiLCJhc3NlcnRCb3VuZHMiLCJtaWRkbGVCeXRlIiwidmFyaW50NjR3cml0ZSIsImxvIiwiaGkiLCJoYXNOZXh0IiwiYnl0ZSIsInNwbGl0Qml0cyIsImhhc01vcmVCaXRzIiwiVFdPX1BXUl8zMl9EQkwiLCJpbnQ2NEZyb21TdHJpbmciLCJkZWMiLCJtaW51cyIsImJhc2UiLCJhZGQxZTZkaWdpdCIsImJlZ2luIiwiZW5kIiwiZGlnaXQxZTYiLCJuZWdhdGUiLCJuZXdCaXRzIiwiaW50NjRUb1N0cmluZyIsImJpdHMiLCJuZWdhdGl2ZSIsInJlc3VsdCIsInVJbnQ2NFRvU3RyaW5nIiwidG9VbnNpZ25lZCIsImxvdyIsIm1pZCIsImhpZ2giLCJkaWdpdEEiLCJkaWdpdEIiLCJkaWdpdEMiLCJNYXRoIiwiZmxvb3IiLCJ0b1N0cmluZyIsImRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyIsImRpZ2l0MWU3IiwicGFydGlhbCIsInZhcmludDMyd3JpdGUiLCJ2YXJpbnQzMnJlYWQiLCJyZWFkQnl0ZXMiLCJtYWtlSW50NjRTdXBwb3J0IiwiZHYiLCJEYXRhVmlldyIsIkFycmF5QnVmZmVyIiwib2siLCJCaWdJbnQiLCJnZXRCaWdJbnQ2NCIsImdldEJpZ1VpbnQ2NCIsInNldEJpZ0ludDY0Iiwic2V0QmlnVWludDY0IiwicHJvY2VzcyIsImVudiIsIkJVRl9CSUdJTlRfRElTQUJMRSIsIk1JTiIsIk1BWCIsIlVNSU4iLCJVTUFYIiwiemVybyIsInN1cHBvcnRlZCIsImJpIiwidVBhcnNlIiwiZW5jIiwiZ2V0SW50MzIiLCJ1RW5jIiwic2V0SW50MzIiLCJ1RGVjIiwiYXNzZXJ0SW50NjRTdHJpbmciLCJhc3NlcnRVSW50NjRTdHJpbmciLCJwcm90b0ludDY0IiwiU2NhbGFyVHlwZSIsIkxvbmdUeXBlIiwic2NhbGFyRXF1YWxzIiwiQllURVMiLCJVaW50OEFycmF5IiwiVUlOVDY0IiwiRklYRUQ2NCIsIklOVDY0IiwiU0ZJWEVENjQiLCJTSU5UNjQiLCJzY2FsYXJaZXJvVmFsdWUiLCJsb25nVHlwZSIsIkJPT0wiLCJET1VCTEUiLCJGTE9BVCIsIlNUUklORyIsImlzU2NhbGFyWmVyb1ZhbHVlIiwiV2lyZVR5cGUiLCJCaW5hcnlXcml0ZXIiLCJ0ZXh0RW5jb2RlciIsInN0YWNrIiwiVGV4dEVuY29kZXIiLCJjaHVua3MiLCJsZW4iLCJvZmZzZXQiLCJzZXQiLCJmb3JrIiwiam9pbiIsImNodW5rIiwicHJldiIsInBvcCIsInVpbnQzMiIsInJhdyIsInRhZyIsImZpZWxkTm8iLCJpbnQzMiIsImJvb2wiLCJzdHJpbmciLCJlbmNvZGUiLCJmbG9hdCIsImJ1ZmZlciIsInNldEZsb2F0MzIiLCJkb3VibGUiLCJzZXRGbG9hdDY0IiwiZml4ZWQzMiIsInNldFVpbnQzMiIsInNmaXhlZDMyIiwic2ludDMyIiwic2ZpeGVkNjQiLCJ2aWV3IiwidGMiLCJmaXhlZDY0IiwiaW50NjQiLCJzaW50NjQiLCJzaWduIiwidWludDY0IiwiQmluYXJ5UmVhZGVyIiwidGV4dERlY29kZXIiLCJ2YXJpbnQ2NCIsImJ5dGVPZmZzZXQiLCJUZXh0RGVjb2RlciIsIndpcmVUeXBlIiwic2tpcCIsInN0YXJ0IiwiVmFyaW50IiwiQml0NjQiLCJCaXQzMiIsIkxlbmd0aERlbGltaXRlZCIsIlN0YXJ0R3JvdXAiLCJmbiIsInd0IiwiRW5kR3JvdXAiLCJzdWJhcnJheSIsIlJhbmdlRXJyb3IiLCJ6emUiLCJzIiwiZ2V0VWludDMyIiwiZ2V0RmxvYXQzMiIsImdldEZsb2F0NjQiLCJkZWNvZGUiLCJtYWtlRXh0ZW5zaW9uIiwiZXh0ZW5kZWUiLCJmaWVsZCIsImZpIiwic3BsaXQiLCJqc29uTmFtZSIsImxpc3QiLCJjcmVhdGVFeHRlbnNpb25Db250YWluZXIiLCJleHRlbnNpb24iLCJjb250YWluZXIiLCJpbml0RXh0ZW5zaW9uRmllbGQiLCJleHQiLCJyZXBlYXRlZCIsImRlZmF1bHQiLCJraW5kIiwiVCIsIkwiLCJmaWVsZFdyYXBwZXIiLCJ1bndyYXBGaWVsZCIsImZpbHRlclVua25vd25GaWVsZHMiLCJ1bmtub3duRmllbGRzIiwiZmlsdGVyIiwidWYiLCJlbmNUYWJsZSIsImRlY1RhYmxlIiwiY2hhckNvZGVBdCIsInByb3RvQmFzZTY0IiwiYmFzZTY0U3RyIiwiZXMiLCJieXRlUG9zIiwiZ3JvdXBQb3MiLCJwIiwiYmFzZTY0IiwiZ2V0RXh0ZW5zaW9uIiwiYXNzZXJ0RXh0ZW5kZWUiLCJ1ZnMiLCJsaXN0VW5rbm93bkZpZWxkcyIsImdldCIsInJlYWRGaWVsZCIsInNldEV4dGVuc2lvbiIsInJlYWRPcHQiLCJ3cml0ZU9wdCIsImhhc0V4dGVuc2lvbiIsImRpc2NhcmRVbmtub3duRmllbGRzIiwib25Vbmtub3duRmllbGQiLCJmIiwid3JpdGVGaWVsZCIsInJlYWRlciIsIm1lc3NhZ2VUeXBlIiwiZmluZCIsImlzRmllbGRTZXQiLCJ0YXJnZXQiLCJvbmVvZiIsImNhc2UiLCJyZXEiLCJrZXlzIiwiY2xlYXJGaWVsZCIsImltcGxpY2l0UHJlc2VuY2UiLCJpc01lc3NhZ2UiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZXZlcnkiLCJtIiwiYWN0dWFsVHlwZSIsIndyYXBGaWVsZCIsIklOVDMyIiwiVUlOVDMyIiwianNvblJlYWREZWZhdWx0cyIsImlnbm9yZVVua25vd25GaWVsZHMiLCJqc29uV3JpdGVEZWZhdWx0cyIsImVudW1Bc0ludGVnZXIiLCJ1c2VQcm90b0ZpZWxkTmFtZSIsInRva2VuTnVsbCIsInRva2VuSWdub3JlZFVua25vd25FbnVtIiwibWFrZUpzb25Gb3JtYXQiLCJBcnJheSIsImlzQXJyYXkiLCJkZWJ1Z0pzb25WYWx1ZSIsIm9uZW9mU2VlbiIsIk1hcCIsInJlZ2lzdHJ5IiwidHlwZVJlZ2lzdHJ5IiwianNvbktleSIsImVudHJpZXMiLCJmaW5kSnNvbk5hbWUiLCJzZWVuIiwiZm91bmQiLCJmaW5kRXh0ZW5zaW9uIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwiYnlOdW1iZXIiLCJjYW5FbWl0RmllbGREZWZhdWx0VmFsdWUiLCJmaW5kRXh0ZW5zaW9uRm9yIiwiciIsInJlYWRTY2FsYXIiLCJCSUdJTlQiLCJ3cml0ZVNjYWxhciIsInBhcmVudFR5cGUiLCJ0YXJnZXRBcnJheSIsImpzb25JdGVtIiwiZW51bVZhbHVlIiwicmVhZEVudW0iLCJ0YXJnZXRNYXAiLCJqc29uTWFwS2V5IiwianNvbk1hcFZhbHVlIiwia2V5IiwicmVhZE1hcEtleSIsIksiLCJWIiwiY3VycmVudFZhbHVlIiwic2NhbGFyVmFsdWUiLCJudWxsQXNaZXJvVmFsdWUiLCJOYU4iLCJQT1NJVElWRV9JTkZJTklUWSIsIk5FR0FUSVZFX0lORklOSVRZIiwidHJpbSIsImlzTmFOIiwiRklYRUQzMiIsIlNGSVhFRDMyIiwiU0lOVDMyIiwibG9uZyIsInVMb25nIiwianNvbk9iaiIsImVudHJ5S2V5IiwiZW50cnlWYWx1ZSIsImVudW1UeXBlIiwid3JpdGVFbnVtIiwianNvbkFyciIsInZhbCIsInVua25vd25GaWVsZHNTeW1ib2wiLCJyZWFkRGVmYXVsdHMiLCJyZWFkVW5rbm93bkZpZWxkcyIsIndyaXRlRGVmYXVsdHMiLCJ3cml0ZVVua25vd25GaWVsZHMiLCJtYWtlQmluYXJ5Rm9ybWF0IiwiYyIsImxlbmd0aE9yRW5kVGFnRmllbGRObyIsImRlbGltaXRlZE1lc3NhZ2VFbmNvZGluZyIsInNjYWxhclR5cGUiLCJyZWFkIiwicmVhZFNjYWxhckxUU3RyaW5nIiwiYXJyIiwiaXNQYWNrZWQiLCJyZWFkTWVzc2FnZUZpZWxkIiwibWFwS2V5IiwibWFwVmFsIiwicmVhZE1hcEVudHJ5IiwiZGVsaW1pdGVkIiwicGFja2VkIiwid3JpdGVQYWNrZWQiLCJpdGVtIiwid3JpdGVNZXNzYWdlRmllbGQiLCJ3cml0ZU1hcEVudHJ5Iiwia2V5VmFsdWUiLCJwYXJzZUludCIsInNjYWxhclR5cGVJbmZvIiwidG9Mb3dlckNhc2UiLCJtYWtlVXRpbENvbW1vbiIsInNvdXJjZSIsIm1lbWJlciIsImJ5TWVtYmVyIiwic2siLCJzb3VyY2VGaWVsZCIsImZpbmRGaWVsZCIsInRvVThBcnIiLCJjb3B5IiwiayIsIm10IiwidmEiLCJ2YiIsImFueSIsImNsb25lU2luZ3VsYXJGaWVsZCIsIm1ha2VQcm90b1J1bnRpbWUiLCJzeW50YXgiLCJJbnRlcm5hbEZpZWxkTGlzdCIsIm5vcm1hbGl6ZXIiLCJfZmllbGRzIiwiX25vcm1hbGl6ZXIiLCJqc29uTmFtZXMiLCJhbGwiLCJudW1iZXJzQXNjIiwic29ydCIsIm1lbWJlcnMiLCJvIiwibG9jYWxGaWVsZE5hbWUiLCJwcm90b05hbWUiLCJpbk9uZW9mIiwicHJvdG9DYW1lbENhc2UiLCJzYWZlT2JqZWN0UHJvcGVydHkiLCJzYWZlTWVzc2FnZVByb3BlcnR5IiwibG9jYWxPbmVvZk5hbWUiLCJmaWVsZEpzb25OYW1lIiwic25ha2VDYXNlIiwiY2FwTmV4dCIsImNoYXJBdCIsInJlc2VydmVkT2JqZWN0UHJvcGVydGllcyIsIlNldCIsInJlc2VydmVkTWVzc2FnZVByb3BlcnRpZXMiLCJmYWxsYmFjayIsImhhcyIsIkludGVybmFsT25lb2ZJbmZvIiwiYWRkRmllbGQiLCJfbG9va3VwIiwibm9ybWFsaXplRmllbGRJbmZvcyIsImZpZWxkSW5mb3MiLCJwYWNrZWRCeURlZmF1bHQiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwib29uYW1lIiwicHJvdG8zIiwiVHJhY2tUeXBlIiwiVHJhY2tTb3VyY2UiLCJTdHJlYW1TdGF0ZSIsImNvbW1vblZlcnNpb25JZGVudGlmaWVyIiwiYnJvd3NlckRldGFpbHMiLCJnZXRCcm93c2VyIiwiZm9yY2UiLCJ1YSIsImJyb3dzZXIiLCJicm93c2Vyc0xpc3QiLCJfcmVmIiwiZGVzY3JpYmUiLCJ2ZXJzaW9uIiwiZ2V0TWF0Y2giLCJvcyIsImluY2x1ZGVzIiwib3NWZXJzaW9uIiwiZ2V0T1NWZXJzaW9uIiwiZXhwIiwiaWQiLCJtYXRjaCIsInJlcGxhY2UiLCJWaWRlb1ByZXNldCIsIndpZHRoT3JPcHRpb25zIiwiaGVpZ2h0IiwibWF4Qml0cmF0ZSIsIm1heEZyYW1lcmF0ZSIsInByaW9yaXR5Iiwid2lkdGgiLCJhc3BlY3RSYXRpbyIsImVuY29kaW5nIiwicmVzb2x1dGlvbiIsImZyYW1lUmF0ZSIsIkF1ZGlvUHJlc2V0cyIsInRlbGVwaG9uZSIsInNwZWVjaCIsIm11c2ljIiwibXVzaWNTdGVyZW8iLCJtdXNpY0hpZ2hRdWFsaXR5IiwibXVzaWNIaWdoUXVhbGl0eVN0ZXJlbyIsImg5MCIsImgxODAiLCJoMjE2IiwiaDM2MCIsImg1NDAiLCJoNzIwIiwiaDEwODAiLCJoMTQ0MCIsImgyMTYwIiwiaDEyMCIsImgyNDAiLCJoNDgwIiwiaDM2MGZwczMiLCJoMzYwZnBzMTUiLCJoNzIwZnBzNSIsImg3MjBmcHMxNSIsImg3MjBmcHMzMCIsImgxMDgwZnBzMTUiLCJoMTA4MGZwczMwIiwib3JpZ2luYWwiLCJSIiwiUmVmbGVjdCIsIlJlZmxlY3RBcHBseSIsInJlY2VpdmVyIiwiYXJncyIsIlJlZmxlY3RPd25LZXlzIiwib3duS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIlByb2Nlc3NFbWl0V2FybmluZyIsIndhcm5pbmciLCJ3YXJuIiwiTnVtYmVySXNOYU4iLCJFdmVudEVtaXR0ZXIiLCJpbml0IiwiZXZlbnRzTW9kdWxlIiwib25jZSIsIl9ldmVudHMiLCJfZXZlbnRzQ291bnQiLCJfbWF4TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsImNoZWNrTGlzdGVuZXIiLCJsaXN0ZW5lciIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsInNldE1heExpc3RlbmVycyIsIl9nZXRNYXhMaXN0ZW5lcnMiLCJ0aGF0IiwiZ2V0TWF4TGlzdGVuZXJzIiwiZW1pdCIsImRvRXJyb3IiLCJldmVudHMiLCJlcnJvciIsImVyIiwiZXJyIiwiY29udGV4dCIsImhhbmRsZXIiLCJsaXN0ZW5lcnMiLCJhcnJheUNsb25lIiwiX2FkZExpc3RlbmVyIiwicHJlcGVuZCIsImV4aXN0aW5nIiwibmV3TGlzdGVuZXIiLCJ1bnNoaWZ0Iiwid2FybmVkIiwidyIsImVtaXR0ZXIiLCJjb3VudCIsImFkZExpc3RlbmVyIiwib24iLCJwcmVwZW5kTGlzdGVuZXIiLCJvbmNlV3JhcHBlciIsImZpcmVkIiwicmVtb3ZlTGlzdGVuZXIiLCJ3cmFwRm4iLCJfb25jZVdyYXAiLCJzdGF0ZSIsIndyYXBwZWQiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwicG9zaXRpb24iLCJvcmlnaW5hbExpc3RlbmVyIiwic3BsaWNlT25lIiwib2ZmIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiX2xpc3RlbmVycyIsInVud3JhcCIsImV2bGlzdGVuZXIiLCJ1bndyYXBMaXN0ZW5lcnMiLCJyYXdMaXN0ZW5lcnMiLCJsaXN0ZW5lckNvdW50IiwiZXZlbnROYW1lcyIsImluZGV4IiwicmV0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJlcnJvckxpc3RlbmVyIiwicmVzb2x2ZXIiLCJldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIiLCJhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlciIsImZsYWdzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIndyYXBMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJSb29tRXZlbnQiLCJQYXJ0aWNpcGFudEV2ZW50IiwiRW5naW5lRXZlbnQiLCJUcmFja0V2ZW50IiwiQkFDS0dST1VORF9SRUFDVElPTl9ERUxBWSIsInJlY3ljbGVkRWxlbWVudHMiLCJWaWRlb1F1YWxpdHkiLCJUcmFjayIsIm1lZGlhVHJhY2siLCJsb2dnZXJPcHRpb25zIiwiYXR0YWNoZWRFbGVtZW50cyIsImlzTXV0ZWQiLCJzdHJlYW1TdGF0ZSIsIkFjdGl2ZSIsImlzSW5CYWNrZ3JvdW5kIiwiX2N1cnJlbnRCaXRyYXRlIiwiYXBwVmlzaWJpbGl0eUNoYW5nZWRMaXN0ZW5lciIsImJhY2tncm91bmRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwidmlzaWJpbGl0eVN0YXRlIiwic2V0VGltZW91dCIsImhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkIiwibG9nZ2VyTmFtZSIsImxvZ2dlckNvbnRleHRDYiIsIl9tZWRpYVN0cmVhbVRyYWNrIiwiX21lZGlhU3RyZWFtSUQiLCJTb3VyY2UiLCJVbmtub3duIiwibG9nQ29udGV4dCIsImdldExvZ0NvbnRleHRGcm9tVHJhY2siLCJjdXJyZW50Qml0cmF0ZSIsIm1lZGlhU3RyZWFtVHJhY2siLCJtZWRpYVN0cmVhbUlEIiwiYXR0YWNoIiwiZWxlbWVudCIsImVsZW1lbnRUeXBlIiwiS2luZCIsIlZpZGVvIiwiYWRkQXBwVmlzaWJpbGl0eUxpc3RlbmVyIiwiZm9yRWFjaCIsInBhcmVudEVsZW1lbnQiLCJzcGxpY2UiLCJjcmVhdGVFbGVtZW50IiwiYXR0YWNoVG9FbGVtZW50IiwiYWxsTWVkaWFTdHJlYW1UcmFja3MiLCJzcmNPYmplY3QiLCJnZXRUcmFja3MiLCJoYXNBdWRpbyIsInNvbWUiLCJ0ciIsInBsYXkiLCJ0aGVuIiwiQXVkaW9QbGF5YmFja1N0YXJ0ZWQiLCJWaWRlb1BsYXliYWNrU3RhcnRlZCIsImNhdGNoIiwiQXVkaW9QbGF5YmFja0ZhaWxlZCIsIlZpZGVvUGxheWJhY2tGYWlsZWQiLCJtdXRlZCIsIkVsZW1lbnRBdHRhY2hlZCIsImRldGFjaCIsImRldGFjaFRyYWNrIiwiaWR4IiwicmVjeWNsZUVsZW1lbnQiLCJFbGVtZW50RGV0YWNoZWQiLCJkZXRhY2hlZCIsImVsbSIsInJlbW92ZUFwcFZpc2liaWxpdHlMaXN0ZW5lciIsInN0b3AiLCJzdG9wTW9uaXRvciIsImVuYWJsZSIsImVuYWJsZWQiLCJkaXNhYmxlIiwibW9uaXRvckludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInRpbWVTeW5jSGFuZGxlIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ1cGRhdGVMb2dnZXJPcHRpb25zIiwiSFRNTEF1ZGlvRWxlbWVudCIsInNob3VsZENhY2hlIiwicGF1c2UiLCJlbCIsImlzV2ViIiwidHJhY2siLCJtZWRpYVN0cmVhbSIsIk1lZGlhU3RyZWFtIiwiZXhpc3RpbmdUcmFja3MiLCJnZXRBdWRpb1RyYWNrcyIsImdldFZpZGVvVHJhY2tzIiwiZXQiLCJyZW1vdmVUcmFjayIsImFkZFRyYWNrIiwiaXNTYWZhcmkiLCJIVE1MVmlkZW9FbGVtZW50IiwiYXV0b3BsYXkiLCJwbGF5c0lubGluZSIsImlzRmlyZUZveCIsImtpbmRUb1Byb3RvIiwiQXVkaW8iLCJBVURJTyIsIlZJREVPIiwiREFUQSIsImtpbmRGcm9tUHJvdG8iLCJzb3VyY2VUb1Byb3RvIiwiQ2FtZXJhIiwiQ0FNRVJBIiwiTWljcm9waG9uZSIsIk1JQ1JPUEhPTkUiLCJTY3JlZW5TaGFyZSIsIlNDUkVFTl9TSEFSRSIsIlNjcmVlblNoYXJlQXVkaW8iLCJTQ1JFRU5fU0hBUkVfQVVESU8iLCJVTktOT1dOIiwic291cmNlRnJvbVByb3RvIiwic3RyZWFtU3RhdGVGcm9tUHJvdG8iLCJQcm90b1N0cmVhbVN0YXRlIiwiQUNUSVZFIiwiUEFVU0VEIiwiUGF1c2VkIiwidHJhY2tJRCIsInNpZCIsInN0cmVhbUlEIiwic3RyZWFtVHJhY2tJRCIsInRyYWNrU2lkIiwiaXNFbmFibGVkIiwidHJhY2tJbmZvIiwibWltZVR5cGUiLCJ0cmFja05hbWUiLCJlbmNyeXB0ZWQiLCJpc0VuY3J5cHRlZCIsIk11dGV4IiwiX2xvY2tpbmciLCJfbG9ja3MiLCJpc0xvY2tlZCIsImxvY2siLCJ1bmxvY2tOZXh0Iiwid2lsbExvY2siLCJ3aWxsVW5sb2NrIiwiUXVldWVUYXNrU3RhdHVzIiwiQXN5bmNRdWV1ZSIsInBlbmRpbmdUYXNrcyIsInRhc2tNdXRleCIsIm5leHRUYXNrSW5kZXgiLCJydW4iLCJ0YXNrIiwidGFza0luZm8iLCJlbnF1ZXVlZEF0IiwiRGF0ZSIsIm5vdyIsInN0YXR1cyIsIldBSVRJTkciLCJ1bmxvY2siLCJleGVjdXRlZEF0IiwiUlVOTklORyIsIkNPTVBMRVRFRCIsImRlbGV0ZSIsImZsdXNoIiwiX19hd2FpdGVyIiwic25hcHNob3QiLCJmcm9tIiwiRU5DUllQVElPTl9BTEdPUklUSE0iLCJERUNSWVBUSU9OX0ZBSUxVUkVfVE9MRVJBTkNFIiwiVU5FTkNSWVBURURfQllURVMiLCJkZWx0YSIsImF1ZGlvIiwiZW1wdHkiLCJJVl9MRU5HVEgiLCJTQUxUIiwiS0VZX1BST1ZJREVSX0RFRkFVTFRTIiwic2hhcmVkS2V5IiwicmF0Y2hldFNhbHQiLCJyYXRjaGV0V2luZG93U2l6ZSIsImZhaWx1cmVUb2xlcmFuY2UiLCJrZXlyaW5nU2l6ZSIsIk1BWF9TSUZfQ09VTlQiLCJNQVhfU0lGX0RVUkFUSU9OIiwiTGl2ZWtpdEVycm9yIiwiY29kZSIsIkNvbm5lY3Rpb25FcnJvclJlYXNvbiIsIk1lZGlhRGV2aWNlRmFpbHVyZSIsImdldEZhaWx1cmUiLCJOb3RGb3VuZCIsIlBlcm1pc3Npb25EZW5pZWQiLCJEZXZpY2VJblVzZSIsIk90aGVyIiwiQ3J5cHRvckVycm9yUmVhc29uIiwiQ3J5cHRvckVycm9yIiwicmVhc29uIiwiSW50ZXJuYWxFcnJvciIsInBhcnRpY2lwYW50SWRlbnRpdHkiLCJLZXlQcm92aWRlckV2ZW50IiwiS2V5SGFuZGxlckV2ZW50IiwiRW5jcnlwdGlvbkV2ZW50IiwiQ3J5cHRvckV2ZW50IiwiaXNWaWRlb0ZyYW1lIiwiZnJhbWUiLCJpbXBvcnRLZXkiLCJrZXlCeXRlc18xIiwia2V5Qnl0ZXMiLCJhbGdvcml0aG0iLCJ1c2FnZSIsImNyeXB0byIsInN1YnRsZSIsImdldEFsZ29PcHRpb25zIiwiYWxnb3JpdGhtTmFtZSIsInNhbHQiLCJlbmNvZGVkU2FsdCIsImhhc2giLCJpdGVyYXRpb25zIiwiZGVyaXZlS2V5cyIsIm1hdGVyaWFsIiwiYWxnb3JpdGhtT3B0aW9ucyIsImVuY3J5cHRpb25LZXkiLCJkZXJpdmVLZXkiLCJyYXRjaGV0IiwiZGVyaXZlQml0cyIsIm5lZWRzUmJzcFVuZXNjYXBpbmciLCJmcmFtZURhdGEiLCJwYXJzZVJic3AiLCJzdHJlYW0iLCJkYXRhT3V0Iiwia1plcm9zSW5TdGFydFNlcXVlbmNlIiwia0VtdWxhdGlvbkJ5dGUiLCJ3cml0ZVJic3AiLCJkYXRhX2luIiwibnVtQ29uc2VjdXRpdmVaZXJvcyIsIlNpZkd1YXJkIiwiY29uc2VjdXRpdmVTaWZDb3VudCIsImxhc3RTaWZSZWNlaXZlZEF0IiwidXNlckZyYW1lc1NpbmNlU2lmIiwicmVjb3JkU2lmIiwic2lmU2VxdWVuY2VTdGFydGVkQXQiLCJyZWNvcmRVc2VyRnJhbWUiLCJyZXNldCIsImlzU2lmQWxsb3dlZCIsImVuY3J5cHRpb25FbmFibGVkTWFwIiwiQmFzZUZyYW1lQ3J5cHRvciIsImVuY29kZUZ1bmN0aW9uIiwiZW5jb2RlZEZyYW1lIiwiY29udHJvbGxlciIsImRlY29kZUZ1bmN0aW9uIiwiRnJhbWVDcnlwdG9yIiwib3B0cyIsInNlbmRDb3VudHMiLCJydHBNYXAiLCJrZXlQcm92aWRlck9wdGlvbnMiLCJzaWZUcmFpbGVyIiwic2lmR3VhcmQiLCJwYXJ0aWNpcGFudCIsIm1lZGlhVHJhY2tJZCIsInRyYWNrSWQiLCJmYWxsYmFja0NvZGVjIiwidmlkZW9Db2RlYyIsInNldFBhcnRpY2lwYW50IiwidW5zZXRQYXJ0aWNpcGFudCIsImdldFBhcnRpY2lwYW50SWRlbnRpdHkiLCJnZXRUcmFja0lkIiwic2V0VmlkZW9Db2RlYyIsImNvZGVjIiwic2V0UnRwTWFwIiwic2V0dXBUcmFuc2Zvcm0iLCJvcGVyYXRpb24iLCJyZWFkYWJsZSIsIndyaXRhYmxlIiwicGFzc2VkVHJhY2tJZCIsInRyYW5zZm9ybUZuIiwidHJhbnNmb3JtU3RyZWFtIiwiVHJhbnNmb3JtU3RyZWFtIiwidHJhbnNmb3JtIiwicGlwZVRocm91Z2giLCJwaXBlVG8iLCJzZXRTaWZUcmFpbGVyIiwidHJhaWxlciIsImVucXVldWUiLCJrZXlTZXQiLCJnZXRLZXlTZXQiLCJnZXRDdXJyZW50S2V5SW5kZXgiLCJNaXNzaW5nS2V5Iiwia2V5SW5kZXgiLCJpdiIsIm1ha2VJViIsImdldE1ldGFkYXRhIiwic3luY2hyb25pemF0aW9uU291cmNlIiwidGltZXN0YW1wIiwiZnJhbWVJbmZvIiwiZ2V0VW5lbmNyeXB0ZWRCeXRlcyIsImZyYW1lSGVhZGVyIiwidW5lbmNyeXB0ZWRCeXRlcyIsImZyYW1lVHJhaWxlciIsImNpcGhlclRleHQiLCJlbmNyeXB0IiwiYWRkaXRpb25hbERhdGEiLCJuZXdEYXRhV2l0aG91dEhlYWRlciIsImlzSDI2NCIsIm5ld0RhdGEiLCJpc0ZyYW1lU2VydmVySW5qZWN0ZWQiLCJoYXNJbnZhbGlkS2V5QXRJbmRleCIsImRlY29kZWRGcmFtZSIsImRlY3J5cHRGcmFtZSIsImRlY3J5cHRpb25TdWNjZXNzIiwiSW52YWxpZEtleSIsImhhc1ZhbGlkS2V5IiwiZGVjcnlwdGlvbkZhaWx1cmUiLCJlbmNvZGVkRnJhbWVfMSIsImtleUluZGV4XzEiLCJfdGhpcyIsImluaXRpYWxNYXRlcmlhbCIsInJhdGNoZXRPcHRzIiwicmF0Y2hldENvdW50IiwiZW5jcnlwdGVkRGF0YSIsIm5ld1VpbnQ4IiwiaXZMZW5ndGgiLCJjaXBoZXJUZXh0U3RhcnQiLCJjaXBoZXJUZXh0TGVuZ3RoIiwicGxhaW5UZXh0IiwiZGVjcnlwdCIsIlJUQ0VuY29kZWRBdWRpb0ZyYW1lIiwicmF0Y2hldGVkS2V5U2V0IiwibmV3TWF0ZXJpYWwiLCJyYXRjaGV0S2V5Iiwic2V0S2V5U2V0Iiwic2V0Q3VycmVudEtleUluZGV4IiwiaXZWaWV3IiwicmFuZG9tIiwic2VuZENvdW50IiwiZGV0ZWN0ZWRDb2RlYyIsImdldFZpZGVvQ29kZWMiLCJvbGRDb2RlYyIsIm5hbHVJbmRpY2VzIiwiZmluZE5BTFVJbmRpY2VzIiwibmFsdUluZGV4IiwiTkFMVVR5cGUiLCJTTElDRV9JRFIiLCJTTElDRV9OT05fSURSIiwicGFyc2VOQUxVVHlwZSIsInNpemUiLCJwYXlsb2FkVHlwZSIsInNlYXJjaExlbmd0aCIsInN0YXJ0Qnl0ZSIsImtOYWx1VHlwZU1hc2siLCJ0cmFpbGVyQnl0ZXMiLCJQYXJ0aWNpcGFudEtleUhhbmRsZXIiLCJjdXJyZW50S2V5SW5kZXgiLCJjcnlwdG9LZXlSaW5nIiwiZmlsbCIsImRlY3J5cHRpb25GYWlsdXJlQ291bnRzIiwicmF0Y2hldFByb21pc2VNYXAiLCJyZXNldEtleVN0YXR1cyIsInNldEtleSIsImV4aXN0aW5nUHJvbWlzZSIsInJhdGNoZXRQcm9taXNlIiwiY3VycmVudE1hdGVyaWFsIiwic2V0S2V5RnJvbU1hdGVyaWFsIiwiS2V5UmF0Y2hldGVkIiwibWF0ZXJpYWxfMSIsIl90aGlzMiIsImVtaXRSYXRjaGV0RXZlbnQiLCJuZXdJbmRleCIsInVzYWdlcyIsInBhcnRpY2lwYW50Q3J5cHRvcnMiLCJwYXJ0aWNpcGFudEtleXMiLCJzaGFyZWRLZXlIYW5kbGVyIiwibWVzc2FnZVF1ZXVlIiwiaXNFbmNyeXB0aW9uRW5hYmxlZCIsInVzZVNoYXJlZEtleSIsIm9ubWVzc2FnZSIsImV2IiwibG9nbGV2ZWwiLCJhY2tNc2ciLCJwb3N0TWVzc2FnZSIsInNldEVuY3J5cHRpb25FbmFibGVkIiwiY3J5cHRvciIsImdldFRyYWNrQ3J5cHRvciIsInJlYWRhYmxlU3RyZWFtIiwid3JpdGFibGVTdHJlYW0iLCJwdWJDcnlwdG9yIiwic2V0U2hhcmVkS2V5IiwiZ2V0UGFydGljaXBhbnRLZXlIYW5kbGVyIiwidW5zZXRDcnlwdG9yUGFydGljaXBhbnQiLCJjciIsImhhbmRsZVJhdGNoZXRSZXF1ZXN0IiwiaGFuZGxlU2lmVHJhaWxlciIsImtleUhhbmRsZXIiLCJnZXRTaGFyZWRLZXlIYW5kbGVyIiwiY3J5cHRvcnMiLCJkZWJ1Z0luZm8iLCJwYXJ0aWNpcGFudHMiLCJzZXR1cENyeXB0b3JFcnJvckV2ZW50cyIsImVtaXRSYXRjaGV0ZWRLZXlzIiwiUlRDVHJhbnNmb3JtRXZlbnQiLCJvbnJ0Y3RyYW5zZm9ybSIsImV2ZW50IiwidHJhbnNmb3JtZXIiLCJoYW5kbGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/livekit-client@2.5.9/node_modules/livekit-client/dist/livekit-client.e2ee.worker.mjs\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	!function() {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = function(chunkId) {
/******/ 			// return url for filenames based on template
/******/ 			return "static/webpack/" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	!function() {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = function(chunkId) {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	!function() {
/******/ 		__webpack_require__.hmrF = function() { return "static/webpack/" + __webpack_require__.h() + ".c29e86809edaa4a0.hot-update.json"; };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	!function() {
/******/ 		__webpack_require__.h = function() { return "dc490b75486ede74"; }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	!function() {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = function() {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: function(script) { return script; },
/******/ 					createScriptURL: function(url) { return url; }
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	!function() {
/******/ 		__webpack_require__.ts = function(script) { return __webpack_require__.tt().createScript(script); };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script url */
/******/ 	!function() {
/******/ 		__webpack_require__.tu = function(url) { return __webpack_require__.tt().createScriptURL(url); };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	!function() {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId, fetchPriority) {
/******/ 				return trackBlockingPromise(require.e(chunkId, fetchPriority));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				//inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results);
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							}, [])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								} else {
/******/ 									return setStatus("ready").then(function () {
/******/ 										return updatedModules;
/******/ 									});
/******/ 								}
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "/_next/";
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	!function() {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push(function(options) {
/******/ 			var originalFactory = options.factory;
/******/ 			options.factory = function(moduleObject, moduleExports, webpackRequire) {
/******/ 				var hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				var cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : function() {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/******/ 	/* webpack/runtime/css loading */
/******/ 	!function() {
/******/ 		var createStylesheet = function(chunkId, fullhref, resolve, reject) {
/******/ 			var linkTag = document.createElement("link");
/******/ 		
/******/ 			linkTag.rel = "stylesheet";
/******/ 			linkTag.type = "text/css";
/******/ 			var onLinkComplete = function(event) {
/******/ 				// avoid mem leaks.
/******/ 				linkTag.onerror = linkTag.onload = null;
/******/ 				if (event.type === 'load') {
/******/ 					resolve();
/******/ 				} else {
/******/ 					var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 					var realHref = event && event.target && event.target.href || fullhref;
/******/ 					var err = new Error("Loading CSS chunk " + chunkId + " failed.\n(" + realHref + ")");
/******/ 					err.code = "CSS_CHUNK_LOAD_FAILED";
/******/ 					err.type = errorType;
/******/ 					err.request = realHref;
/******/ 					linkTag.parentNode.removeChild(linkTag)
/******/ 					reject(err);
/******/ 				}
/******/ 			}
/******/ 			linkTag.onerror = linkTag.onload = onLinkComplete;
/******/ 			linkTag.href = fullhref;
/******/ 		
/******/ 			document.head.appendChild(linkTag);
/******/ 			return linkTag;
/******/ 		};
/******/ 		var findStylesheet = function(href, fullhref) {
/******/ 			var existingLinkTags = document.getElementsByTagName("link");
/******/ 			for(var i = 0; i < existingLinkTags.length; i++) {
/******/ 				var tag = existingLinkTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");
/******/ 				if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return tag;
/******/ 			}
/******/ 			var existingStyleTags = document.getElementsByTagName("style");
/******/ 			for(var i = 0; i < existingStyleTags.length; i++) {
/******/ 				var tag = existingStyleTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href");
/******/ 				if(dataHref === href || dataHref === fullhref) return tag;
/******/ 			}
/******/ 		};
/******/ 		var loadStylesheet = function(chunkId) {
/******/ 			return new Promise(function(resolve, reject) {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				if(findStylesheet(href, fullhref)) return resolve();
/******/ 				createStylesheet(chunkId, fullhref, resolve, reject);
/******/ 			});
/******/ 		}
/******/ 		// no chunk loading
/******/ 		
/******/ 		var oldTags = [];
/******/ 		var newTags = [];
/******/ 		var applyHandler = function(options) {
/******/ 			return { dispose: function() {
/******/ 				for(var i = 0; i < oldTags.length; i++) {
/******/ 					var oldTag = oldTags[i];
/******/ 					if(oldTag.parentNode) oldTag.parentNode.removeChild(oldTag);
/******/ 				}
/******/ 				oldTags.length = 0;
/******/ 			}, apply: function() {
/******/ 				for(var i = 0; i < newTags.length; i++) newTags[i].rel = "stylesheet";
/******/ 				newTags.length = 0;
/******/ 			} };
/******/ 		}
/******/ 		__webpack_require__.hmrC.miniCss = function(chunkIds, removedChunks, removedModules, promises, applyHandlers, updatedModulesList) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			chunkIds.forEach(function(chunkId) {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				var oldTag = findStylesheet(href, fullhref);
/******/ 				if(!oldTag) return;
/******/ 				promises.push(new Promise(function(resolve, reject) {
/******/ 					var tag = createStylesheet(chunkId, fullhref, function() {
/******/ 						tag.as = "style";
/******/ 						tag.rel = "preload";
/******/ 						resolve();
/******/ 					}, reject);
/******/ 					oldTags.push(oldTag);
/******/ 					newTags.push(tag);
/******/ 				}));
/******/ 			});
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	!function() {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = __webpack_require__.hmrS_importScripts = __webpack_require__.hmrS_importScripts || {
/******/ 			"_app-pages-browser_node_modules_pnpm_livekit-client_2_5_9_node_modules_livekit-client_dist_li-6f1212": 1
/******/ 		};
/******/ 		
/******/ 		// no chunk install function needed
/******/ 		// no chunk loading
/******/ 		
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			var success = false;
/******/ 			self["webpackHotUpdate_N_E"] = function(_, moreModules, runtime) {
/******/ 				for(var moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						currentUpdate[moduleId] = moreModules[moduleId];
/******/ 						if(updatedModulesList) updatedModulesList.push(moduleId);
/******/ 					}
/******/ 				}
/******/ 				if(runtime) currentUpdateRuntime.push(runtime);
/******/ 				success = true;
/******/ 			};
/******/ 			// start update chunk loading
/******/ 			importScripts(__webpack_require__.tu(__webpack_require__.p + __webpack_require__.hu(chunkId)));
/******/ 			if(!success) throw new Error("Loading update chunk failed for unknown reason");
/******/ 		}
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.importScriptsHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result;
/******/ 					if (newModuleFactory) {
/******/ 						result = getAffectedModuleEffects(moduleId);
/******/ 					} else {
/******/ 						result = {
/******/ 							type: "disposed",
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err2) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err2,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err2);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.importScripts = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.importScripts = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.importScriptsHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = function() {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then(function(response) {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("(app-pages-browser)/./node_modules/.pnpm/livekit-client@2.5.9/node_modules/livekit-client/dist/livekit-client.e2ee.worker.mjs");
/******/ 	_N_E = __webpack_exports__;
/******/ 	
/******/ })()
;